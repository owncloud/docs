Opal.modules["stringio"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $defs = Opal.defs, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_ge = Opal.rb_ge, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_ivar = Opal.return_ivar, $eqeq = Opal.eqeq, $alias = Opal.alias, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,call,close,attr_accessor,check_readable,==,length,===,>=,raise,>,+,-,seek,check_writable,String,[],eof?,write,read,tell');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringIO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.position = $proto.string = nil;
    
    $defs(self, '$open', function $$open(string, mode) {
      var block = $$open.$$p || nil, self = this, io = nil, res = nil;

      $$open.$$p = null;
      
      ;
      if (string == null) string = "";
      if (mode == null) mode = nil;
      io = self.$new(string, mode);
      res = block.$call(io);
      io.$close();
      return res;
    }, -1);
    self.$attr_accessor("string");
    
    $def(self, '$initialize', function $$initialize(string, mode) {
      var $yield = $$initialize.$$p || nil, self = this;

      $$initialize.$$p = null;
      
      if (string == null) string = "";
      if (mode == null) mode = "rw";
      self.string = string;
      self.position = 0;
      return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [nil, mode], null);
    }, -1);
    
    $def(self, '$eof?', function $StringIO_eof$ques$1() {
      var self = this;

      
      self.$check_readable();
      return self.position['$=='](self.string.$length());
    });
    
    $def(self, '$seek', function $$seek(pos, whence) {
      var self = this, $ret_or_1 = nil;

      
      if (whence == null) whence = $$$($$('IO'), 'SEEK_SET');
      self.read_buffer = "";
      if ($eqeqeq($$$($$('IO'), 'SEEK_SET'), ($ret_or_1 = whence))) {
        
        if (!$truthy($rb_ge(pos, 0))) {
          self.$raise($$$($$('Errno'), 'EINVAL'))
        };
        self.position = pos;
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_CUR'), $ret_or_1)) {
        if ($truthy($rb_gt($rb_plus(self.position, pos), self.string.$length()))) {
          self.position = self.string.$length()
        } else {
          self.position = $rb_plus(self.position, pos)
        }
      } else if ($eqeqeq($$$($$('IO'), 'SEEK_END'), $ret_or_1)) {
        if ($truthy($rb_gt(pos, self.string.$length()))) {
          self.position = 0
        } else {
          self.position = $rb_minus(self.position, pos)
        }
      } else {
        nil
      };
      return 0;
    }, -2);
    
    $def(self, '$tell', $return_ivar("position"));
    
    $def(self, '$rewind', function $$rewind() {
      var self = this;

      return self.$seek(0)
    });
    
    $def(self, '$write', function $$write(string) {
      var self = this, before = nil, after = nil;

      
      self.$check_writable();
      self.read_buffer = "";
      string = self.$String(string);
      if ($eqeq(self.string.$length(), self.position)) {
        
        self.string = $rb_plus(self.string, string);
        return (self.position = $rb_plus(self.position, string.$length()));
      } else {
        
        before = self.string['$[]'](Opal.Range.$new(0, $rb_minus(self.position, 1), false));
        after = self.string['$[]'](Opal.Range.$new($rb_plus(self.position, string.$length()), -1, false));
        self.string = $rb_plus($rb_plus(before, string), after);
        return (self.position = $rb_plus(self.position, string.$length()));
      };
    });
    
    $def(self, '$read', function $$read(length, outbuf) {
      var self = this, string = nil, str = nil;

      
      if (length == null) length = nil;
      if (outbuf == null) outbuf = nil;
      self.$check_readable();
      if ($truthy(self['$eof?']())) {
        return nil
      };
      string = ($truthy(length) ? (((str = self.string['$[]'](self.position, length)), (self.position = $rb_plus(self.position, length)), ($truthy($rb_gt(self.position, self.string.$length())) ? ((self.position = self.string.$length())) : nil), str)) : (((str = self.string['$[]'](Opal.Range.$new(self.position, -1, false))), (self.position = self.string.$length()), str)));
      if ($truthy(outbuf)) {
        return outbuf.$write(string)
      } else {
        return string
      };
    }, -1);
    
    $def(self, '$sysread', function $$sysread(length) {
      var self = this;

      
      self.$check_readable();
      return self.$read(length);
    });
    $alias(self, "eof", "eof?");
    $alias(self, "pos", "tell");
    $alias(self, "pos=", "seek");
    return $alias(self, "readpartial", "read");
  })($nesting[0], $$('IO'), $nesting)
};
