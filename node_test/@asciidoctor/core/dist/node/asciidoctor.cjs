'use strict';

var module$1 = require('module');
var url = require('url');
var path = require('path');
var fs = require('fs');
var Opal = require('@asciidoctor/opal-runtime');
var unxhr = require('unxhr');

var _documentCurrentScript = typeof document !== 'undefined' ? document.currentScript : null;
/* global Asciidoctor, ASCIIDOCTOR_JS_VERSION */

const __path__ = path;
const __XMLHttpRequest__ = unxhr.XMLHttpRequest;
const __asciidoctorDistDir__ = path.dirname(url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('asciidoctor-node.cjs', document.baseURI).href))));
const __require__ = module$1.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (_documentCurrentScript && _documentCurrentScript.src || new URL('asciidoctor-node.cjs', document.baseURI).href)));

function asciidoctorNode (moduleConfig) {
Opal.modules["asciidoctor/js/opal_ext/electron/io"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $gvars = Opal.gvars, $send = Opal.send, $a, nil = Opal.nil;
  if ($gvars.stdout == null) $gvars.stdout = nil;
  if ($gvars.stderr == null) $gvars.stderr = nil;

  Opal.add_stubs('write_proc=');
  
  $gvars.stdout['$write_proc='](function(s){console.log(s);});
  return ($a = [function(s){console.error(s);}], $send($gvars.stderr, 'write_proc=', $a), $a[$a.length - 1]);
};

Opal.modules["asciidoctor/js/opal_ext/node"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $const_set = Opal.const_set, $eqeq = Opal.eqeq, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting); Opal.nil;

  Opal.add_stubs('==,require');
  
  
  var isElectron = typeof navigator === 'object' && typeof navigator.userAgent === 'string' && typeof navigator.userAgent.indexOf('Electron') !== -1,
      platform,
      engine,
      framework,
      ioModule;

  if (typeof moduleConfig === 'object' && typeof moduleConfig.runtime === 'object') {
    var runtime = moduleConfig.runtime;
    platform = runtime.platform;
    engine = runtime.engine;
    framework = runtime.framework;
    ioModule = runtime.ioModule;
  }

  ioModule = ioModule || 'node';
  platform = platform || 'node';
  engine = engine || 'v8';
  if (isElectron) {
    framework = framework || 'electron';
  } else {
    framework = framework || '';
  }
  $const_set($nesting[0], 'JAVASCRIPT_IO_MODULE', ioModule);
  $const_set($nesting[0], 'JAVASCRIPT_PLATFORM', platform);
  $const_set($nesting[0], 'JAVASCRIPT_ENGINE', engine);
  $const_set($nesting[0], 'JAVASCRIPT_FRAMEWORK', framework);
  if ($eqeq($$('JAVASCRIPT_FRAMEWORK'), "electron")) {
    self.$require("asciidoctor/js/opal_ext/electron/io");
  }  
// Load Opal modules
Opal.load("pathname");
Opal.load("nodejs");
};

Opal.modules["asciidoctor/js/asciidoctor_ext/node/abstract_node"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = []; Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'AbstractNode');

      
      return $def(self, '$generate_data_uri_from_uri', function $$generate_data_uri_from_uri(image_uri, cache_uri) {
        var self = this;
        
      var contentType = '';
      var b64encoded = '';
      var status = -1;

      try {
        var xhr = new __XMLHttpRequest__();
        xhr.open('GET', image_uri, false);
        xhr.responseType = 'arraybuffer';
        xhr.addEventListener('load', function() {
          status = this.status;
          if (status === 200) {
            var arrayBuffer = this.response;
            b64encoded = Buffer.from(arrayBuffer).toString('base64');
            contentType = this.getResponseHeader('content-type');
          }
        });
        xhr.send(null);
      }
      catch (e) {
        // something bad happened!
        status = 0;
      }
      if (status === 404 || (status === 0 && !b64encoded)) {
        self.$logger().$warn('could not retrieve image data from URI: ' + image_uri);
        return image_uri
      }
      return 'data:' + contentType + ';base64,' + b64encoded
    ;
      }, -2)
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/node/open_uri"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $slice = Opal.slice, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,new,<<,rewind');
  
  self.$require("stringio");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'OpenURI');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $defs($$('OpenURI'), '$open_uri', function $$open_uri(uri, $a) {
      var $yield = $$open_uri.$$p || nil, io = nil, data = nil;

      $$open_uri.$$p = null;
      
      $slice(arguments, 1);
      io = $$$('StringIO').$new();
      data = "";
      
      var contentType = '';
      var status = -1;

      try {
        var xhr = new __XMLHttpRequest__();
        xhr.open('GET', uri, false);
        xhr.responseType = 'text';
        xhr.addEventListener('load', function() {
          status = this.status;
          if (status === 200) {
            data = this.responseText;
            contentType = this.getResponseHeader('content-type');
          }
        });
        xhr.send(null);
      }
      catch (e) {
        // something bad happened!
        status = 0;
      }
      if (status === 404 || (status === 0 && !data)) {
        throw $$('IOError').$new('No such file or directory: ' + uri)
      }
      io['$<<'](data);
      io.$rewind();
      if (($yield !== nil)) {
        return Opal.yield1($yield, io);
      } else {
        return io
      }    }, -2)
  })($nesting[0], $nesting);
};

Opal.modules["asciidoctor/js/asciidoctor_ext/node/stylesheet"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('rstrip,read,join');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Stylesheets');

      var $proto = self.$$prototype;

      $proto.primary_stylesheet_data = nil;
      return $def(self, '$primary_stylesheet_data', function $$primary_stylesheet_data() {
        var self = this, stylesheets_dir = nil, $ret_or_1 = nil;

        
        if ($truthy(__path__.basename(__asciidoctorDistDir__) === 'node' && __path__.basename(__path__.dirname(__asciidoctorDistDir__)) === 'dist')) {
          stylesheets_dir = __path__.join(__path__.dirname(__asciidoctorDistDir__), 'css');
        } else {
          stylesheets_dir = __path__.join(__asciidoctorDistDir__, 'css');
        }        return (self.primary_stylesheet_data = ($truthy(($ret_or_1 = self.primary_stylesheet_data)) ? ($ret_or_1) : ($$$('IO').$read($$$('File').$join(stylesheets_dir, "asciidoctor.css")).$rstrip())));
      })
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/node/template"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $return_ivar = Opal.return_ivar, $defs = Opal.defs, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $eqeq = Opal.eqeq, $send = Opal.send, $rb_lt = Opal.rb_lt, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[],clear,===,caches,class,scan,node_name,raise,ctx,==,strip,rstrip,key?,merge,[]=,file,private,new,each,directory?,system_path,scan_dir,update,select,glob,file?,basename,<,size,split,start_with?,slice,length,to_sym,node_require');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'TemplateConverter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.templates = $proto.caches = $proto.backend = $proto.engine = $proto.template_dirs = nil;
      
      self.caches = $hash2(["scans", "templates"], {"scans": $hash2([], {}), "templates": $hash2([], {})});
      $defs(self, '$caches', $return_ivar("caches"));
      $defs(self, '$clear_caches', function $$clear_caches() {
        var self = this;
        if (self.caches == null) self.caches = nil;

        
        if ($truthy(self.caches['$[]']("scans"))) {
          self.caches['$[]']("scans").$clear();
        }        if ($truthy(self.caches['$[]']("templates"))) {
          return self.caches['$[]']("templates").$clear()
        } else {
          return nil
        }      });
      
      $def(self, '$initialize', function $$initialize(backend, template_dirs, opts) {
        var self = this, $ret_or_1 = nil;

        
        if (opts == null) opts = $hash2([], {});
        self.backend = backend;
        self.templates = $hash2([], {});
        self.template_dirs = template_dirs;
        self.engine = opts['$[]']("template_engine");
        self.engine_options = ($truthy(($ret_or_1 = opts['$[]']("template_engine_options"))) ? ($ret_or_1) : ($hash2([], {})));
        if ($eqeqeq(true, ($ret_or_1 = opts['$[]']("template_cache")))) {
          self.caches = self.$class().$caches();
        } else if ($eqeqeq($$$('Hash'), $ret_or_1)) {
          self.caches = opts['$[]']("template_cache");
        } else {
          self.caches = $hash2([], {});
        }        return self.$scan();
      }, -3);
      
      $def(self, '$convert', function $$convert(node, template_name, opts) {
        var self = this, template = nil, $ret_or_1 = nil, helpers_ctx = nil;

        
        if (template_name == null) template_name = nil;
        if (opts == null) opts = nil;
        if (!$truthy((template = self.templates['$[]']((template_name = ($truthy(($ret_or_1 = template_name)) ? ($ret_or_1) : (node.$node_name()))))))) {
          self.$raise("Could not find a custom template to handle transform: " + (template_name));
        }        helpers_ctx = ($truthy(($ret_or_1 = self.templates['$[]']("helpers.js"))) ? (self.templates['$[]']("helpers.js").$ctx()) : ($ret_or_1));
        if ($eqeq(template_name, "document")) {
          return (template.render({node: node, opts: fromHash(opts), helpers: helpers_ctx})).$strip()
        } else {
          return (template.render({node: node, opts: fromHash(opts), helpers: helpers_ctx})).$rstrip()
        }      }, -2);
      
      $def(self, '$handles?', function $TemplateConverter_handles$ques$1(name) {
        var self = this;

        return self.templates['$key?'](name)
      });
      
      $def(self, '$templates', function $$templates() {
        var self = this;

        return self.templates.$merge()
      });
      
      $def(self, '$register', function $$register(name, template) {
        var $a, $b, self = this, template_cache = nil, $ret_or_1 = nil;

        return ($a = [name, ($truthy((template_cache = ($truthy(($ret_or_1 = self.caches['$[]']("templates"))) ? (template.$file) : ($ret_or_1)))) ? (($b = [template.$file(), template], $send(template_cache, '[]=', $b), $b[$b.length - 1])) : (template))], $send(self.templates, '[]=', $a), $a[$a.length - 1])
      });
      self.$private();
      
      $def(self, '$scan', function $$scan() {
        var self = this, path_resolver = nil, backend = nil, engine = nil;

        
        path_resolver = $$('PathResolver').$new();
        backend = self.backend;
        engine = self.engine;
        return $send(self.template_dirs, 'each', [], function $$2(template_dir){var $a, self = $$2.$$s == null ? this : $$2.$$s, file_pattern = nil, engine_dir = nil, backend_dir = nil, pattern = nil, scan_cache = nil, template_cache = nil, templates = nil;
          if (self.caches == null) self.caches = nil;
          if (self.templates == null) self.templates = nil;

          
          if (template_dir == null) template_dir = nil;
          if (!$truthy($$$('File')['$directory?']((template_dir = path_resolver.$system_path(template_dir))))) {
            return nil
          }          if ($truthy(engine)) {
            
            file_pattern = "*." + (engine);
            if ($truthy($$$('File')['$directory?']((engine_dir = "" + (template_dir) + "/" + (engine))))) {
              template_dir = engine_dir;
            }          } else {
            file_pattern = "*";
          }          if ($truthy($$$('File')['$directory?']((backend_dir = "" + (template_dir) + "/" + (backend))))) {
            template_dir = backend_dir;
          }          pattern = "" + (template_dir) + "/" + (file_pattern);
          if ($truthy((scan_cache = self.caches['$[]']("scans")))) {
            
            template_cache = self.caches['$[]']("templates");
            if (!$truthy((templates = scan_cache['$[]'](pattern)))) {
              templates = ($a = [pattern, self.$scan_dir(template_dir, pattern, template_cache)], $send(scan_cache, '[]=', $a), $a[$a.length - 1]);
            }            $send(templates, 'each', [], function $$3(name, template){var $b, $c, self = $$3.$$s == null ? this : $$3.$$s;
              if (self.templates == null) self.templates = nil;

              
              if (name == null) name = nil;
              if (template == null) template = nil;
              return ($b = [name, ($c = [template.$file(), template], $send(template_cache, '[]=', $c), $c[$c.length - 1])], $send(self.templates, '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
          } else {
            self.templates.$update(self.$scan_dir(template_dir, pattern, self.caches['$[]']("templates")));
          }          return nil;}, {$$s: self});
      });
      
      $def(self, '$node_require', function $$node_require(module_name) {
        
        
      try {
        return __require__(module_name)
      }
      catch (e) {
        throw $$('IOError').$new("Unable to require the module '" + (module_name) + "', please make sure that the module is installed.")
      }
    
      });
      return $def(self, '$scan_dir', function $$scan_dir(template_dir, pattern, template_cache) {
        var $a, self = this, result = nil, helpers = nil;

        
        if (template_cache == null) template_cache = nil;
        $a = [$hash2([], {}), nil], (result = $a[0]), (helpers = $a[1]);
              var enginesContext = {};
        $send($send($$$('Dir').$glob(pattern), 'select', [], function $$4(match){
          
          if (match == null) match = nil;
          return $$$('File')['$file?'](match);}), 'each', [], function $$5(file){var $b, self = $$5.$$s == null ? this : $$5.$$s, basename = nil, path_segments = nil, name = nil, template = nil, extsym = nil, nunjucks = nil, handlebars = nil, ejs = nil, pug = nil;

          
          if (file == null) file = nil;
          if (($eqeq((basename = $$$('File').$basename(file)), "helpers.js") || ($eqeq((basename = $$$('File').$basename(file)), "helpers.cjs")))) {
            
            helpers = file;
            return nil;
          } else if ($truthy($rb_lt((path_segments = basename.$split(".")).$size(), 2))) {
            return nil
          }          if ($eqeq((name = path_segments['$[]'](0)), "block_ruler")) {
            name = "thematic_break";
          } else if ($truthy(name['$start_with?']("block_"))) {
            name = name.$slice(6, name.$length());
          }          if (!($truthy(template_cache) && ($truthy((template = template_cache['$[]'](file)))))) {
            
            extsym = path_segments['$[]'](-1).$to_sym();
            
            switch (extsym) {
              case "nunjucks":
              case "njk":
                
                nunjucks = self.$node_require("nunjucks");
                
            var env;
            if (enginesContext.nunjucks && enginesContext.nunjucks.environment) {
              env = enginesContext.nunjucks.environment;
            } else {
              var opts = self.engine_options['nunjucks'] || {};
              delete opts.web; // unsupported option
              env = nunjucks.configure(template_dir, opts);
              enginesContext.nunjucks = { environment: env };
            }
            template = Object.assign(nunjucks.compile(fs.readFileSync(file, 'utf8'), env), { '$file': function() { return file } })
          ;
                break;
              case "handlebars":
              case "hbs":
                
                handlebars = self.$node_require("handlebars");
                
            var env;
            var opts = self.engine_options['handlebars'] || {};
            if (enginesContext.handlebars && enginesContext.handlebars.environment) {
              env = enginesContext.handlebars.environment;
            } else {
              env = handlebars.create();
              enginesContext.handlebars = { environment: env };
            }
            template = { render: env.compile(fs.readFileSync(file, 'utf8'), opts), '$file': function() { return file } }
          ;
                break;
              case "ejs":
                
                ejs = self.$node_require("ejs");
                
            var opts = self.engine_options['ejs'] || {};
            opts.filename = file;
            // unsupported options
            delete opts.async;
            delete opts.client;
            template = { render: ejs.compile(fs.readFileSync(file, 'utf8'), opts), '$file': function() { return file } }
          ;
                break;
              case "pug":
                
                pug = self.$node_require("pug");
                
            var opts = self.engine_options['pug'] || {};
            opts.filename = file;
            template = { render: pug.compileFile(file, opts), '$file': function() { return file } }
          ;
                break;
              case "js":
              case "cjs":
                template = { render: __require__(file), '$file': function() { return file } };
                break;
              default:
                
            var registry = Opal.Asciidoctor.TemplateEngine.registry;
            var templateEngine = registry[extsym];
            if (templateEngine && typeof templateEngine.compile === 'function') {
              template = Object.assign(templateEngine.compile(file, name), { '$file': function() { return file } });
            } else {
              template = undefined;
            }
          
            }          }          if ($truthy(template)) {
            return ($b = [name, template], $send(result, '[]=', $b), $b[$b.length - 1])
          } else {
            return nil
          }}, {$$s: self});
        if ((($truthy(helpers) || ($truthy($$$('File')['$file?']((helpers = "" + (template_dir) + "/helpers.js"))))) || ($truthy($$$('File')['$file?']((helpers = "" + (template_dir) + "/helpers.cjs")))))) {
          
          
        var ctx = __require__(helpers);
        if (typeof ctx.configure === 'function') {
          ctx.configure(enginesContext);
        }
          result['$[]=']("helpers.js", { '$file': function() { return helpers }, $ctx: function() { return ctx } });
        }        return result;
      }, -3);
    })($$('Converter'), $$$($$('Converter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/node"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("asciidoctor/js/asciidoctor_ext/node/abstract_node");
  self.$require("asciidoctor/js/asciidoctor_ext/node/open_uri");
  self.$require("asciidoctor/js/asciidoctor_ext/node/stylesheet");
  return self.$require("asciidoctor/js/asciidoctor_ext/node/template");
};

Opal.modules["set"] = Opal.return_val(Opal.nil); /* Generated by Opal 1.7.3 */

Opal.modules["asciidoctor/js/opal_ext/kernel"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $def = Opal.def, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('new');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Kernel');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    
    $def(self, '$open', function $$open(path, $a) {
      var $post_args, rest, $yield = $$open.$$p || nil, file = nil;

      $$open.$$p = null;
      
      $post_args = $slice(arguments, 1);
      rest = $post_args;
      file = $send($$('File'), 'new', [path].concat($to_a(rest)));
      if (($yield !== nil)) {
        return Opal.yield1($yield, file);
      } else {
        return file
      }    }, -2);
    return $def(self, '$__dir__', $return_val(""));
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/opal_ext/file"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $gvars = Opal.gvars, $return_val = Opal.return_val, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,delete,gsub,read,size,to_enum,chomp,each_line,readlines,split');
  
  (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'File');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.eof = $proto.path = nil;
    
    self.$attr_reader("eof");
    self.$attr_reader("lineno");
    self.$attr_reader("path");
    
    $def(self, '$initialize', function $$initialize(path, flags) {
      var self = this, encoding_flag_regexp = nil;

      
      if (flags == null) flags = "r";
      self.path = path;
      self.contents = nil;
      self.eof = false;
      self.lineno = 0;
      flags = flags.$delete("b");
      encoding_flag_regexp = /:(.*)/;
      flags = flags.$gsub(encoding_flag_regexp, "");
      return (self.flags = flags);
    }, -2);
    
    $def(self, '$read', function $$read() {
      var self = this, res = nil;

      if ($truthy(self.eof)) {
        return ""
      } else {
        
        res = $$('File').$read(self.path);
        self.eof = true;
        self.lineno = res.$size();
        return res;
      }
    });
    
    $def(self, '$each_line', function $$each_line(separator) {
      var block = $$each_line.$$p || nil, self = this, lines = nil;
      if ($gvars["/"] == null) $gvars["/"] = nil;

      $$each_line.$$p = null;
      if (separator == null) separator = $gvars["/"];
      if ($truthy(self.eof)) {
        return ((block !== nil) ? (self) : ([].$to_enum()))
      }      if ((block !== nil)) {
        
        lines = $$('File').$read(self.path);
        
        self.eof = false;
        self.lineno = 0;
        var chomped  = lines.$chomp(),
            trailing = lines.length != chomped.length,
            splitted = chomped.split(separator);
        for (var i = 0, length = splitted.length; i < length; i++) {
          self.lineno += 1;
          if (i < length - 1 || trailing) {
            Opal.yield1(block, splitted[i] + separator);
          }
          else {
            Opal.yield1(block, splitted[i]);
          }
        }
        self.eof = true;
        return self;
      } else {
        return self.$read().$each_line()
      }    }, -1);
    
    $def(self, '$readlines', function $$readlines() {
      var self = this;

      return $$('File').$readlines(self.path)
    });
    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$readlines', function $$readlines(path, separator) {
        var content = nil;
        if ($gvars["/"] == null) $gvars["/"] = nil;

        
        if (separator == null) separator = $gvars["/"];
        content = $$('File').$read(path);
        return content.$split(separator);
      }, -2);
      
      $def(self, '$file?', $return_val(true));
      
      $def(self, '$readable?', $return_val(true));
      return $def(self, '$read', $return_val(""));
    })(Opal.get_singleton_class(self), $nesting);
  })($nesting[0], null, $nesting);
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'IO');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $defs(self, '$read', function $$read(path) {
      
      return $$('File').$read(path)
    })
  })($nesting[0], null, $nesting);
};

Opal.modules["asciidoctor/js/opal_ext/match_data"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $send = Opal.send, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('[]=');
  return (function($base, $super) {
    var self = $klass($base, $super, 'MatchData');

    var $proto = self.$$prototype;

    $proto.matches = nil;
    return $def(self, '$[]=', function $MatchData_$$$eq$1(idx, val) {
      var $a, self = this;

      return ($a = [idx, val], $send(self.matches, '[]=', $a), $a[$a.length - 1])
    })
  })($nesting[0], null)
};

Opal.modules["asciidoctor/js/opal_ext/string"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $def = Opal.def, $alias = Opal.alias, $rb_ge = Opal.rb_ge, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('method_defined?,<,length,bytes,to_s,byteslice,limit_bytesize,>=,==,-,_original_byteslice,unpack,_original_unpack');
  return (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    
    if (!$truthy(self['$method_defined?']("limit_bytesize"))) {
      
      $def(self, '$limit_bytesize', function $$limit_bytesize(size) {
        var self = this, result = nil;

        
        if (!$truthy($rb_lt(size, self.$bytes().$length()))) {
          return self.$to_s()
        }        result = self.$byteslice(0, size);
        return result.$to_s();
      });
    }    if (!$truthy(self['$method_defined?']("limit"))) {
      $alias(self, "limit", "limit_bytesize");
    }    $alias(self, "_original_byteslice", "byteslice");
    
    $def(self, '$byteslice', function $$byteslice(index, length) {
      var self = this;

      
      if (length == null) length = 1;
      if ((($eqeq(index, 3) && ($truthy($rb_ge(length, index)))) && ($truthy(self.charCodeAt() === 65279)))) {
        return (self.substr(1)).$byteslice(0, $rb_minus(length, 3))
      } else {
        return self.$_original_byteslice(index, length)
      }    }, -2);
    $alias(self, "_original_unpack", "unpack");
    return $def(self, '$unpack', function $$unpack(format) {
      var self = this;

      if ($eqeq(format, "C3")) {
        if ($truthy(self.charCodeAt() === 65279)) {
          return [239, 187, 191]
        } else {
          
          var bytes = [];
          for (var i=0; i < 3; i++) {
            if (i < self.length) {
              bytes.push(self.charCodeAt(i));
            } else {
              bytes.push(nil);
            }
          }
          return bytes
        
        }
      } else {
        return self.$_original_unpack(format)
      }
    });
  })($nesting[0], null)
};

Opal.modules["asciidoctor/js/opal_ext/uri"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $defs = Opal.defs, $return_self = Opal.return_self, $def = Opal.def, $nesting = []; Opal.nil;

  Opal.add_stubs('extend');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'URI');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $defs(self, '$parse', function $$parse(str) {
      
      return str.$extend($$('URI'))
    });
    return $def(self, '$path', $return_self);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/opal_ext/base64"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $defs = Opal.defs, $ensure_kwargs = Opal.ensure_kwargs, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('delete');
  return (function($base) {
    var self = $module($base, 'Base64');

    
    
    
    var encode, decode;
    encode = Opal.global.btoa || function (input) {
      var buffer;
      if (input instanceof Buffer) {
        buffer = input;
      } else {
        buffer = Buffer.from(input.toString(), 'binary');
      }
      return buffer.toString('base64');
    };
    decode = Opal.global.atob || function (input) {
      return Buffer.from(input, 'base64').toString('binary');
    };
    $defs(self, '$decode64', function $$decode64(string) {
      
      return decode(string.replace(/\r?\n/g, ''));
    });
    $defs(self, '$encode64', function $$encode64(string) {
      
      return encode(string).replace(/(.{60})/g, "$1\n").replace(/([^\n])$/g, "$1\n");
    });
    $defs(self, '$strict_decode64', function $$strict_decode64(string) {
      
      return decode(string);
    });
    $defs(self, '$strict_encode64', function $$strict_encode64(string) {
      
      return encode(string);
    });
    $defs(self, '$urlsafe_decode64', function $$urlsafe_decode64(string) {
      
      return decode(string.replace(/\-/g, '+').replace(/_/g, '/'));
    });
    return $defs(self, '$urlsafe_encode64', function $$urlsafe_encode64(string, $kwargs) {
      var padding, str = nil;

      
      $kwargs = $ensure_kwargs($kwargs);
      
      padding = $kwargs.$$smap["padding"];if (padding == null) padding = true;
      str = encode(string).replace(/\+/g, '-').replace(/\//g, '_');
      if (!$truthy(padding)) {
        str = str.$delete("=");
      }      return str;
    }, -2);
  })($nesting[0])
};

Opal.modules["asciidoctor/js/opal_ext/number"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $def = Opal.def, $nesting = [], $$ = Opal.$r($nesting); Opal.nil;

  Opal.add_stubs('coerce_to!,>');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Number');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return $def(self, '$round', function $$round(ndigits) {
      var self = this;
      ndigits = $$('Opal')['$coerce_to!'](ndigits, $$('Integer'), "to_int");
      if ($truthy($rb_gt(ndigits, 0))) {
        return Number(self.toFixed(ndigits));
      } else {
        return Math.round(self);
      }    }, -1)
  })($nesting[0], $$('Numeric'), $nesting)
};

Opal.modules["asciidoctor/js/opal_ext"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("asciidoctor/js/opal_ext/kernel");
  self.$require("asciidoctor/js/opal_ext/file");
  self.$require("asciidoctor/js/opal_ext/match_data");
  self.$require("asciidoctor/js/opal_ext/string");
  self.$require("asciidoctor/js/opal_ext/uri");
  self.$require("asciidoctor/js/opal_ext/base64");
  self.$require("asciidoctor/js/opal_ext/number");
  
// suppress "not supported" warning messages from Opal
Opal.config.unsupported_features_severity = 'ignore';

// Load specific runtime
self.$require("asciidoctor/js/opal_ext/node");
};

Opal.modules["asciidoctor/js/rx"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send, $gvars = Opal.gvars, $truthy = Opal.truthy, $defs = Opal.defs, $rb_plus = Opal.rb_plus, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('gsub,+,unpack_hex_range');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $const_set($nesting[0], 'HEX_RANGE_RX', /([A-F0-9]{4})(?:-([A-F0-9]{4}))?/);
    $defs(self, '$unpack_hex_range', function $$unpack_hex_range(str) {
      
      return $send(str, 'gsub', [$$('HEX_RANGE_RX')], function $$1(){var $a, $ret_or_1 = nil;

        return "\\u" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + (($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) ? ("-\\u" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) : ($ret_or_1)))})
    });
    $const_set($nesting[0], 'P_L', $rb_plus("A-Za-z", self.$unpack_hex_range("00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D037F03860388-038A038C038E-03A103A3-03F503F7-0481048A-052F0531-055605590561-058705D0-05EA05F0-05F20620-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280840-085808A0-08B20904-0939093D09500958-09610971-09800985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10CF10CF20D05-0D0C0D0E-0D100D12-0D3A0D3D0D4E0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC-0EDF0F000F40-0F470F49-0F6C0F88-0F8C1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510C710CD10D0-10FA10FC-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA16F1-16F81700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191E1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1BBA-1BE51C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11CF51CF61D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209C21022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2CF22CF32D00-2D252D272D2D2D30-2D672D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31BA31F0-31FF3400-4DB54E00-9FCCA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A66EA67F-A69DA6A0-A6E5A717-A71FA722-A788A78B-A78EA790-A7ADA7B0A7B1A7F7-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFA9E0-A9E4A9E6-A9EFA9FA-A9FEAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA7E-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDAAE0-AAEAAAF2-AAF4AB01-AB06AB09-AB0EAB11-AB16AB20-AB26AB28-AB2EAB30-AB5AAB5C-AB5FAB64AB65ABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC")));
    $const_set($nesting[0], 'P_Nl', self.$unpack_hex_range("16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF"));
    $const_set($nesting[0], 'P_Nd', $rb_plus("0-9", self.$unpack_hex_range("0660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0DE6-0DEF0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19D91A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9A9F0-A9F9AA50-AA59ABF0-ABF9FF10-FF19")));
    $const_set($nesting[0], 'P_Pc', self.$unpack_hex_range("005F203F20402054FE33FE34FE4D-FE4FFF3F"));
    $const_set($nesting[0], 'CC_ALPHA', "" + ($$('P_L')) + ($$('P_Nl')));
    $const_set($nesting[0], 'CG_ALPHA', "[" + ($$('CC_ALPHA')) + "]");
    $const_set($nesting[0], 'CC_ALNUM', "" + ($$('CC_ALPHA')) + ($$('P_Nd')));
    $const_set($nesting[0], 'CG_ALNUM', "[" + ($$('CC_ALNUM')) + "]");
    $const_set($nesting[0], 'CC_WORD', "" + ($$('CC_ALNUM')) + ($$('P_Pc')));
    $const_set($nesting[0], 'CG_WORD', "[" + ($$('CC_WORD')) + "]");
    $const_set($nesting[0], 'CG_BLANK', "[ \\t]");
    $const_set($nesting[0], 'CC_EOL', "(?=\\n|$)");
    $const_set($nesting[0], 'CG_GRAPH', "[^\\s\\x00-\\x1F\\x7F]");
    $const_set($nesting[0], 'CC_ALL', "[\\s\\S]");
    return $const_set($nesting[0], 'CC_ANY', "[^\\n]");
  })($nesting[0], $nesting)
};

Opal.modules["strscan"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Opal = Opal.Opal, $return_ivar = Opal.return_ivar, $send = Opal.send, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_reader,anchor,empty?,===,to_s,coerce_to!,scan_until,length,size,rest,pos=,beginning_of_line?,get_byte,private');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'StringScanner');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.pos = $proto.string = $proto.working = $proto.matched = $proto.prev_pos = $proto.match = nil;
    
    self.$attr_reader("pos", "matched");
    
    $def(self, '$initialize', function $$initialize(string) {
      var self = this;

      
      self.string = string;
      self.pos = 0;
      self.matched = nil;
      self.working = string;
      return (self.match = []);
    });
    self.$attr_reader("string");
    
    $def(self, '$beginning_of_line?', function $StringScanner_beginning_of_line$ques$1() {
      var self = this;

      return self.pos === 0 || self.string.charAt(self.pos - 1) === "\n"
    });
    
    $def(self, '$scan', function $$scan(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return self.matched = nil;
      }
      self.prev_pos = self.pos;
      self.pos     += result[0].length;
      self.working  = self.working.substring(result[0].length);
      self.matched  = result[0];
      self.match    = result;

      return result[0];
    });
    
    $def(self, '$scan_until', function $$scan_until(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var working = self.working;

      for(var i = 0; working.length != i; ++i) {
        var result  = pattern.exec(working.substr(i));
        if (result !== null) {
          var matched_size = i + result[0].length;
          var matched = working.substr(0, matched_size);

          self.matched  = result[0];
          self.match  = result;
          self.prev_pos = self.pos + i; // Position of first character of matched
          self.pos += matched_size; // Position one after last character of matched
          self.working = working.substr(matched_size);

          return matched
        }
      }
      return self.matched = nil;
    });
    
    $def(self, '$[]', function $StringScanner_$$$2(idx) {
      var self = this, $ret_or_1 = nil;

      
      if ($truthy(self.match['$empty?']())) {
        return nil
      }      if ($eqeqeq($$('Symbol'), ($ret_or_1 = idx))) {
        idx = idx.$to_s();
      } else if (!$eqeqeq($$('String'), $ret_or_1)) {
        idx = $Opal['$coerce_to!'](idx, $$('Integer'), "to_int");
      }      
      var match = self.match;

      if (idx < 0) {
        idx += match.length;
      }

      if (idx < 0 || idx >= match.length) {
        return nil;
      }

      if (match[idx] == null) {
        return nil;
      }

      return match[idx];
    });
    
    $def(self, '$check', function $$check(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return self.matched = nil;
      }

      return self.matched = result[0];
    });
    
    $def(self, '$check_until', function $$check_until(pattern) {
      var self = this;

      
      var old_prev_pos = self.prev_pos;
      var old_pos      = self.pos;
      var old_working  = self.working;

      var result = self.$scan_until(pattern);

      self.prev_pos = old_prev_pos;
      self.pos      = old_pos;
      self.working  = old_working;

      return result;
    
    });
    
    $def(self, '$peek', function $$peek(length) {
      var self = this;

      return self.working.substring(0, length)
    });
    
    $def(self, '$eos?', function $StringScanner_eos$ques$3() {
      var self = this;

      return self.working.length === 0
    });
    
    $def(self, '$exist?', function $StringScanner_exist$ques$4(pattern) {
      var self = this;

      
      var result = pattern.exec(self.working);

      if (result == null) {
        return nil;
      }
      else if (result.index == 0) {
        return 0;
      }
      else {
        return result.index + 1;
      }
    
    });
    
    $def(self, '$skip', function $$skip(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        self.match = [];
        return self.matched = nil;
      }
      else {
        var match_str = result[0];
        var match_len = match_str.length;

        self.matched   = match_str;
        self.match     = result;
        self.prev_pos  = self.pos;
        self.pos      += match_len;
        self.working   = self.working.substring(match_len);

        return match_len;
      }
    });
    
    $def(self, '$skip_until', function $$skip_until(pattern) {
      var self = this;

      
      var result = self.$scan_until(pattern);

      if (result === nil) {
        return nil;
      }
      else {
        self.matched = result.substr(-1);

        return result.length;
      }
    
    });
    
    $def(self, '$get_byte', function $$get_byte() {
      var self = this;

      
      var result = nil;

      if (self.pos < self.string.length) {
        self.prev_pos  = self.pos;
        self.pos      += 1;
        result      = self.matched = self.working.substring(0, 1);
        self.working   = self.working.substring(1);
      }
      else {
        self.matched = nil;
      }

      return result;
    
    });
    
    $def(self, '$match?', function $StringScanner_match$ques$5(pattern) {
      var self = this;

      
      pattern = self.$anchor(pattern);
      
      var result = pattern.exec(self.working);

      if (result == null) {
        return nil;
      }
      else {
        self.prev_pos = self.pos;

        return result[0].length;
      }
    });
    
    $def(self, '$pos=', function $StringScanner_pos$eq$6(pos) {
      var self = this;

      
      
      if (pos < 0) {
        pos += self.string.$length();
      }
      self.pos = pos;
      return (self.working = self.string.slice(pos));
    });
    
    $def(self, '$matched_size', function $$matched_size() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.matched.length
    
    });
    
    $def(self, '$post_match', function $$post_match() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.string.substr(self.pos);
    
    });
    
    $def(self, '$pre_match', function $$pre_match() {
      var self = this;

      
      if (self.matched === nil) {
        return nil;
      }

      return self.string.substr(0, self.prev_pos);
    
    });
    
    $def(self, '$reset', function $$reset() {
      var self = this;

      
      self.working = self.string;
      self.matched = nil;
      return (self.pos = 0);
    });
    
    $def(self, '$rest', $return_ivar("working"));
    
    $def(self, '$rest?', function $StringScanner_rest$ques$7() {
      var self = this;

      return self.working.length !== 0
    });
    
    $def(self, '$rest_size', function $$rest_size() {
      var self = this;

      return self.$rest().$size()
    });
    
    $def(self, '$terminate', function $$terminate() {
      var $a, self = this;

      
      self.match = nil;
      return ($a = [self.string.$length()], $send(self, 'pos=', $a), $a[$a.length - 1]);
    });
    
    $def(self, '$unscan', function $$unscan() {
      var self = this;

      
      self.pos = self.prev_pos;
      self.prev_pos = nil;
      self.match = nil;
      return self;
    });
    $alias(self, "bol?", "beginning_of_line?");
    $alias(self, "getch", "get_byte");
    self.$private();
    return $def(self, '$anchor', function $$anchor(pattern) {
      
      
      var flags = pattern.toString().match(/\/([^\/]+)$/);
      flags = flags ? flags[1] : undefined;
      return new RegExp('^(?:' + pattern.source + ')', flags);
    
    });
  })($nesting[0], null, $nesting)
};

Opal.modules["asciidoctor/js"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("asciidoctor/js/opal_ext");
  self.$require("asciidoctor/js/rx");
  return self.$require("strscan");
};

Opal.modules["asciidoctor/core_ext/nil_or_empty"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $truthy = Opal.truthy, $alias = Opal.alias, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('method_defined?,nil?,empty?');
  
  (function($base, $super) {
    var self = $klass($base, $super, 'NilClass');

    
    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return $alias(self, "nil_or_empty?", "nil?")
    }
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'String');

    
    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return $alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Array');

    
    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return $alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null);
  (function($base, $super) {
    var self = $klass($base, $super, 'Hash');

    
    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return $alias(self, "nil_or_empty?", "empty?")
    }
  })($nesting[0], null);
  return (function($base, $super) {
    var self = $klass($base, $super, 'Numeric');

    
    if ($truthy(self['$method_defined?']("nil_or_empty?"))) {
      return nil
    } else {
      return $alias(self, "nil_or_empty?", "nil?")
    }
  })($nesting[0], null);
};

Opal.modules["asciidoctor/core_ext/hash/merge"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $eqeq = Opal.eqeq, $send = Opal.send, $slice = Opal.slice, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, self = Opal.top, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('==,arity,instance_method,send,new,<,length,dup,>,inject,merge,[]');
  if ($eqeq($$('Hash').$instance_method("merge").$arity(), 1)) {
    return $$('Hash').$send("prepend", $send($$('Module'), 'new', [], function $$1(){var self = $$1.$$s == null ? this : $$1.$$s;

      return $def(self, '$merge', function $$merge($a) {
        var $post_args, args; $$merge.$$p || nil; var self = this, len = nil;

        $$merge.$$p = null;
        
        $post_args = $slice(arguments);
        args = $post_args;
        if ($truthy($rb_lt((len = args.$length()), 1))) {
          return self.$dup()
        } else {
          
          if ($truthy($rb_gt(len, 1))) {
            return $send(args, 'inject', [self], function $$2(acc, arg){
              
              if (acc == null) acc = nil;
              if (arg == null) arg = nil;
              return acc.$merge(arg);})
          } else {
            
            return $send2(self, $find_super(self, 'merge', $$merge, false, true), 'merge', [args['$[]'](0)], null);
          }        }      }, -1)}, {$$s: self}))
  } else {
    return nil
  }
};

Opal.modules["asciidoctor/core_ext/match_data/names"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $truthy = Opal.truthy, $klass = Opal.klass, $def = Opal.def, $nesting = [], $$ = Opal.$r($nesting), nil = Opal.nil;

  Opal.add_stubs('method_defined?');
  if ($truthy($$('MatchData')['$method_defined?']("names"))) {
    return nil
  } else {
    return (function($base, $super) {
      var self = $klass($base, $super, 'MatchData');

      
      return $def(self, '$names', function $$names() {
        
        return []
      })
    })($nesting[0], null)
  }
};

Opal.modules["asciidoctor/core_ext"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  
  self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/nil_or_empty");
  self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/hash/merge");
  return self.$require("asciidoctor/core_ext.rb"+ '/../' + "core_ext/match_data/names");
};

Opal.modules["asciidoctor/helpers"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $gvars = Opal.gvars, $def = Opal.def, $send = Opal.send, $neqeq = Opal.neqeq, $const_set = Opal.const_set, $hash2 = Opal.hash2, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $Class = Opal.Class, $Object = Opal.Object, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('module_function,require,include?,include,==,path,message,raise,warn,logger,chomp,empty?,slice,unpack,[],[]=,byteslice,bytesize,map,rstrip,encode,encoding,nil_or_empty?,!=,tap,each_line,<<,!,start_with?,match?,gsub,rindex,index,basename,extname,length,directory?,dirname,mkdir_p,mkdir,private_constant,join,divmod,*,===,+,to_s,to_i,succ,class_for_name,const_get');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Helpers');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$module_function();
      
      $def(self, '$require_library', function $$require_library(name, gem_name, on_failure) {
        var self = this, details = nil;
        if ($gvars["!"] == null) $gvars["!"] = nil;

        
        if (gem_name == null) gem_name = true;
        if (on_failure == null) on_failure = "abort";
        try {
          return self.$require(name)
        } catch ($err) {
          if (Opal.rescue($err, [$$$('LoadError')])) {
            try {
              
              if (!$truthy(self['$include?']($$('Logging')))) {
                self.$include($$('Logging'));
              };
              if ($truthy(gem_name)) {
                
                if ($eqeq(gem_name, true)) {
                  gem_name = name;
                };
                
                switch (on_failure) {
                  case "abort":
                    
                    details = ($eqeq($gvars["!"].$path(), gem_name) ? ("") : (" (reason: " + (($truthy($gvars["!"].$path()) ? ("cannot load '" + ($gvars["!"].$path()) + "'") : ($gvars["!"].$message()))) + ")"));
                    self.$raise($$$('LoadError'), "asciidoctor: FAILED: required gem '" + (gem_name) + "' is not available" + (details) + ". Processing aborted.");
                    break;
                  case "warn":
                    
                    details = ($eqeq($gvars["!"].$path(), gem_name) ? ("") : (" (reason: " + (($truthy($gvars["!"].$path()) ? ("cannot load '" + ($gvars["!"].$path()) + "'") : ($gvars["!"].$message()))) + ")"));
                    self.$logger().$warn("optional gem '" + (gem_name) + "' is not available" + (details) + ". Functionality disabled.");
                    break;
                  default:
                    nil;
                };
              } else 
              switch (on_failure) {
                case "abort":
                  self.$raise($$$('LoadError'), "asciidoctor: FAILED: " + ($gvars["!"].$message().$chomp(".")) + ". Processing aborted.");
                  break;
                case "warn":
                  self.$logger().$warn("" + ($gvars["!"].$message().$chomp(".")) + ". Functionality disabled.");
                  break;
                default:
                  nil;
              };
              return nil;
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }      }, -2);
      
      $def(self, '$prepare_source_array', function $$prepare_source_array(data, trim_end) {
        var leading_2_bytes = nil, leading_bytes = nil, first = nil;

        
        if (trim_end == null) trim_end = true;
        if ($truthy(data['$empty?']())) {
          return []
        }        if ($eqeq((leading_2_bytes = (leading_bytes = (first = data['$[]'](0)).$unpack("C3")).$slice(0, 2)), $$('BOM_BYTES_UTF_16LE'))) {
          
          data['$[]='](0, first.$byteslice(2, first.$bytesize()));
          return ($truthy(trim_end) ? ($send(data, 'map', [], function $$1(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16LE')).$rstrip();})) : ($send(data, 'map', [], function $$2(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16LE')).$chomp();})));
        } else if ($eqeq(leading_2_bytes, $$('BOM_BYTES_UTF_16BE'))) {
          
          data['$[]='](0, first.$byteslice(2, first.$bytesize()));
          return ($truthy(trim_end) ? ($send(data, 'map', [], function $$3(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16BE')).$rstrip();})) : ($send(data, 'map', [], function $$4(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16BE')).$chomp();})));
        } else if ($eqeq(leading_bytes, $$('BOM_BYTES_UTF_8'))) {
          data['$[]='](0, first.$byteslice(3, first.$bytesize()));
        }        if ($eqeq(first.$encoding(), $$('UTF_8'))) {
          if ($truthy(trim_end)) {
            return $send(data, 'map', [], function $$5(line){
              
              if (line == null) line = nil;
              return line.$rstrip();})
          } else {
            return $send(data, 'map', [], function $$6(line){
              
              if (line == null) line = nil;
              return line.$chomp();})
          }
        } else if ($truthy(trim_end)) {
          return $send(data, 'map', [], function $$7(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8')).$rstrip();})
        } else {
          return $send(data, 'map', [], function $$8(line){
            
            if (line == null) line = nil;
            return line.$encode($$('UTF_8')).$chomp();})
        }      }, -2);
      
      $def(self, '$prepare_source_string', function $$prepare_source_string(data, trim_end) {
        var leading_2_bytes = nil, leading_bytes = nil;

        
        if (trim_end == null) trim_end = true;
        if ($truthy(data['$nil_or_empty?']())) {
          return []
        }        if ($eqeq((leading_2_bytes = (leading_bytes = data.$unpack("C3")).$slice(0, 2)), $$('BOM_BYTES_UTF_16LE'))) {
          data = data.$byteslice(2, data.$bytesize()).$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16LE'));
        } else if ($eqeq(leading_2_bytes, $$('BOM_BYTES_UTF_16BE'))) {
          data = data.$byteslice(2, data.$bytesize()).$encode($$('UTF_8'), $$$($$$('Encoding'), 'UTF_16BE'));
        } else if ($eqeq(leading_bytes, $$('BOM_BYTES_UTF_8'))) {
          
          data = data.$byteslice(3, data.$bytesize());
          if (!$eqeq(data.$encoding(), $$('UTF_8'))) {
            data = data.$encode($$('UTF_8'));
          }        } else if ($neqeq(data.$encoding(), $$('UTF_8'))) {
          data = data.$encode($$('UTF_8'));
        }        if ($truthy(trim_end)) {
          return $send([], 'tap', [], function $$9(lines){
            
            if (lines == null) lines = nil;
            return $send(data, 'each_line', [], function $$10(line){
              
              if (line == null) line = nil;
              return lines['$<<'](line.$rstrip());});})
        } else {
          return $send([], 'tap', [], function $$11(lines){
            
            if (lines == null) lines = nil;
            return $send(data, 'each_line', [], function $$12(line){
              
              if (line == null) line = nil;
              return lines['$<<'](line.$chomp());});})
        }      }, -2);
      if ($eqeq($$$('RUBY_ENGINE'), "jruby")) {
        
        $def(self, '$uriish?', function $Helpers_uriish$ques$13(str) {
          var $ret_or_1 = nil, $ret_or_2 = nil;

          if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = str['$include?'](":"))) ? (str['$start_with?']("uri:classloader:")['$!']()) : ($ret_or_2))))) {
            
            return $$('UriSniffRx')['$match?'](str);
          } else {
            return $ret_or_1
          }
        });
      } else {
        
        $def(self, '$uriish?', function $Helpers_uriish$ques$14(str) {
          var $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = str['$include?'](":")))) {
            
            return $$('UriSniffRx')['$match?'](str);
          } else {
            return $ret_or_1
          }
        });
      }      
      $def(self, '$encode_uri_component', function $$encode_uri_component(str) {
        
        
        return encodeURIComponent(str).replace(/%20|[!'()*]/g, function (m) {
          return m === '%20' ? '+' : '%' + m.charCodeAt(0).toString(16)
        })
      
      });
      
      $def(self, '$encode_spaces_in_uri', function $$encode_spaces_in_uri(str) {
        
        if ($truthy(str['$include?'](" "))) {
          
          return str.$gsub(" ", "%20");
        } else {
          return str
        }
      });
      
      $def(self, '$rootname', function $$rootname(filename) {
        var last_dot_idx = nil;

        if ($truthy((last_dot_idx = filename.$rindex(".")))) {
          if ($truthy(filename.$index("/", last_dot_idx))) {
            return filename
          } else {
            
            return filename.$slice(0, last_dot_idx);
          }
        } else {
          return filename
        }
      });
      
      $def(self, '$basename', function $$basename(filename, drop_ext) {
        var self = this;

        
        if (drop_ext == null) drop_ext = nil;
        if ($truthy(drop_ext)) {
          return $$$('File').$basename(filename, ($eqeq(drop_ext, true) ? (self.$extname(filename)) : (drop_ext)))
        } else {
          return $$$('File').$basename(filename)
        }      }, -2);
      
      $def(self, '$extname?', function $Helpers_extname$ques$15(path) {
        var $ret_or_1 = nil, last_dot_idx = nil;

        if ($truthy(($ret_or_1 = (last_dot_idx = path.$rindex("."))))) {
          return path.$index("/", last_dot_idx)['$!']()
        } else {
          return $ret_or_1
        }
      });
      if ($truthy($$$($$$('File'), 'ALT_SEPARATOR'))) {
        
        $def(self, '$extname', function $$extname(path, fallback) {
          var last_dot_idx = nil;

          
          if (fallback == null) fallback = "";
          if ($truthy((last_dot_idx = path.$rindex(".")))) {
            if (($truthy(path.$index("/", last_dot_idx)) || ($truthy(path.$index($$$($$$('File'), 'ALT_SEPARATOR'), last_dot_idx))))) {
              return fallback
            } else {
              
              return path.$slice(last_dot_idx, path.$length());
            }
          } else {
            return fallback
          }        }, -2);
      } else {
        
        $def(self, '$extname', function $$extname(path, fallback) {
          var last_dot_idx = nil;

          
          if (fallback == null) fallback = "";
          if ($truthy((last_dot_idx = path.$rindex(".")))) {
            if ($truthy(path.$index("/", last_dot_idx))) {
              return fallback
            } else {
              
              return path.$slice(last_dot_idx, path.$length());
            }
          } else {
            return fallback
          }        }, -2);
      }      
      $def(self, '$mkdir_p', function $$mkdir_p(dir) {
        var self = this, parent_dir = nil;

        if ($truthy($$$('File')['$directory?'](dir))) {
          return nil
        } else {
          
          if (!$eqeq((parent_dir = $$$('File').$dirname(dir)), ".")) {
            self.$mkdir_p(parent_dir);
          }          
          try {
            return $$$('Dir').$mkdir(dir)
          } catch ($err) {
            if (Opal.rescue($err, [$$$('SystemCallError')])) {
              try {
                if ($truthy($$$('File')['$directory?'](dir))) {
                  return nil
                } else {
                  return self.$raise()
                }
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          }        }
      });
      $const_set($nesting[0], 'ROMAN_NUMERALS', $hash2(["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"], {"M": 1000, "CM": 900, "D": 500, "CD": 400, "C": 100, "XC": 90, "L": 50, "XL": 40, "X": 10, "IX": 9, "V": 5, "IV": 4, "I": 1}));
      self.$private_constant("ROMAN_NUMERALS");
      
      $def(self, '$int_to_roman', function $$int_to_roman(val) {
        
        return $send($$('ROMAN_NUMERALS'), 'map', [], function $$16(l, i){var $a, $b, repeat = nil;

          
          if (l == null) l = nil;
          if (i == null) i = nil;
          $b = val.$divmod(i), $a = $to_ary($b), (repeat = ($a[0] == null ? nil : $a[0])), (val = ($a[1] == null ? nil : $a[1]));
          return $rb_times(l, repeat);}).$join()
      });
      
      $def(self, '$nextval', function $$nextval(current) {
        var intval = nil;

        if ($eqeqeq($$$('Integer'), current)) {
          return $rb_plus(current, 1)
        } else if ($eqeq((intval = current.$to_i()).$to_s(), current.$to_s())) {
          return $rb_plus(intval, 1)
        } else {
          return current.$succ()
        }
      });
      
      $def(self, '$resolve_class', function $$resolve_class(object) {
        var self = this;

        if ($eqeqeq($Class, object)) {
          return object
        } else {
          
          if ($eqeqeq($$$('String'), object)) {
            
            return self.$class_for_name(object);
          } else {
            return nil
          }        }
      });
      return $def(self, '$class_for_name', function $$class_for_name(qualified_name) {
        var self = this, resolved = nil;

        try {
          
          if (!$eqeqeq($Class, (resolved = $Object.$const_get(qualified_name, false)))) {
            self.$raise();
          };
          return resolved;
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return self.$raise($$$('NameError'), "Could not resolve class for name: " + (qualified_name))
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["logger"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send, $def = Opal.def, $eqeqeq = Opal.eqeqeq, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,to_h,map,constants,const_get,to_s,format,chr,strftime,message_as_string,===,+,message,class,join,backtrace,inspect,attr_reader,attr_accessor,new,key,upcase,raise,add,to_proc,<=,<,write,call,[],now');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Logger');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.level = $proto.progname = $proto.pipe = $proto.formatter = nil;
    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Severity');

      var $nesting = [self].concat($parent_nesting);

      
      $const_set($nesting[0], 'DEBUG', 0);
      $const_set($nesting[0], 'INFO', 1);
      $const_set($nesting[0], 'WARN', 2);
      $const_set($nesting[0], 'ERROR', 3);
      $const_set($nesting[0], 'FATAL', 4);
      return $const_set($nesting[0], 'UNKNOWN', 5);
    })($nesting[0], $nesting);
    self.$include($$('Severity'));
    $const_set($nesting[0], 'SEVERITY_LABELS', $send($$('Severity').$constants(), 'map', [], function $Logger$1(s){
      
      if (s == null) s = nil;
      return [$$('Severity').$const_get(s), s.$to_s()];}).$to_h());
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Formatter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'MESSAGE_FORMAT', "%s, [%s] %5s -- %s: %s\n");
      $const_set($nesting[0], 'DATE_TIME_FORMAT', "%Y-%m-%dT%H:%M:%S.%6N");
      
      $def(self, '$call', function $$call(severity, time, progname, msg) {
        var self = this;

        return self.$format($$('MESSAGE_FORMAT'), severity.$chr(), time.$strftime($$('DATE_TIME_FORMAT')), severity, progname, self.$message_as_string(msg))
      });
      return $def(self, '$message_as_string', function $$message_as_string(msg) {
        var $ret_or_1 = nil, $ret_or_2 = nil;

        if ($eqeqeq($$$('String'), ($ret_or_1 = msg))) {
          return msg
        } else if ($eqeqeq($$$('Exception'), $ret_or_1)) {
          return $rb_plus("" + (msg.$message()) + " (" + (msg.$class()) + ")\n", ($truthy(($ret_or_2 = msg.$backtrace())) ? ($ret_or_2) : ([])).$join("\n"))
        } else {
          return msg.$inspect()
        }
      });
    })($nesting[0], null, $nesting);
    self.$attr_reader("level");
    self.$attr_accessor("progname");
    self.$attr_accessor("formatter");
    
    $def(self, '$initialize', function $$initialize(pipe) {
      var self = this;

      
      self.pipe = pipe;
      self.level = $$('DEBUG');
      return (self.formatter = $$('Formatter').$new());
    });
    
    $def(self, '$level=', function $Logger_level$eq$2(severity) {
      var self = this, level = nil;

      if ($eqeqeq($$$('Integer'), severity)) {
        return (self.level = severity)
      } else if ($truthy((level = $$('SEVERITY_LABELS').$key(severity.$to_s().$upcase())))) {
        return (self.level = level)
      } else {
        return self.$raise($$('ArgumentError'), "invalid log level: " + (severity))
      }
    });
    
    $def(self, '$info', function $$info(progname) {
      var block = $$info.$$p || nil, self = this;

      $$info.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('INFO'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$debug', function $$debug(progname) {
      var block = $$debug.$$p || nil, self = this;

      $$debug.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('DEBUG'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$warn', function $$warn(progname) {
      var block = $$warn.$$p || nil, self = this;

      $$warn.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('WARN'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$error', function $$error(progname) {
      var block = $$error.$$p || nil, self = this;

      $$error.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('ERROR'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$fatal', function $$fatal(progname) {
      var block = $$fatal.$$p || nil, self = this;

      $$fatal.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('FATAL'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$unknown', function $$unknown(progname) {
      var block = $$unknown.$$p || nil, self = this;

      $$unknown.$$p = null;
      if (progname == null) progname = nil;
      return $send(self, 'add', [$$('UNKNOWN'), nil, progname], block.$to_proc());
    }, -1);
    
    $def(self, '$info?', function $Logger_info$ques$3() {
      var self = this;

      return $rb_le(self.level, $$('INFO'))
    });
    
    $def(self, '$debug?', function $Logger_debug$ques$4() {
      var self = this;

      return $rb_le(self.level, $$('DEBUG'))
    });
    
    $def(self, '$warn?', function $Logger_warn$ques$5() {
      var self = this;

      return $rb_le(self.level, $$('WARN'))
    });
    
    $def(self, '$error?', function $Logger_error$ques$6() {
      var self = this;

      return $rb_le(self.level, $$('ERROR'))
    });
    
    $def(self, '$fatal?', function $Logger_fatal$ques$7() {
      var self = this;

      return $rb_le(self.level, $$('FATAL'))
    });
    return $def(self, '$add', function $$add(severity, message, progname) {
      var block = $$add.$$p || nil, self = this, $ret_or_1 = nil;

      $$add.$$p = null;
      if (message == null) message = nil;
      if (progname == null) progname = nil;
      if ($truthy($rb_lt((severity = ($truthy(($ret_or_1 = severity)) ? ($ret_or_1) : ($$('UNKNOWN')))), self.level))) {
        return true
      }      progname = ($truthy(($ret_or_1 = progname)) ? ($ret_or_1) : (self.progname));
      if (!$truthy(message)) {
        if ((block !== nil)) {
          message = Opal.yieldX(block, []);
        } else {
          
          message = progname;
          progname = self.progname;
        }
      }      self.pipe.$write(self.formatter.$call(($truthy(($ret_or_1 = $$('SEVERITY_LABELS')['$[]'](severity))) ? ($ret_or_1) : ("ANY")), $$$('Time').$now(), progname, message));
      return true;
    }, -2);
  })($nesting[0], null, $nesting)
};

Opal.modules["asciidoctor/logging"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $send = Opal.send, $def = Opal.def, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $const_set = Opal.const_set, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $gvars = Opal.gvars, $alias = Opal.alias, $defs = Opal.defs, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,attr_reader,progname=,formatter=,new,level=,>,[],===,inspect,to_h,map,constants,const_get,<<,clear,empty?,max,attr_accessor,memoize_logger,private,logger,extend,private_class_method,merge');
  
  self.$require("logger");
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Logger');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.max_severity = nil;
      
      self.$attr_reader("max_severity");
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, args, $b, $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        $post_args = $slice(arguments);
        args = $post_args;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a(args), $yield);
        self['$progname=']("asciidoctor");
        self['$formatter=']($$('BasicFormatter').$new());
        return ($b = [$$('WARN')], $send(self, 'level=', $b), $b[$b.length - 1]);
      }, -1);
      
      $def(self, '$add', function $$add(severity, message, progname) {
        var $yield = $$add.$$p || nil, self = this, $ret_or_1 = nil;

        $$add.$$p = null;
        
        if (message == null) message = nil;
        if (progname == null) progname = nil;
        if ($truthy($rb_gt((severity = ($truthy(($ret_or_1 = severity)) ? ($ret_or_1) : ($$('UNKNOWN')))), (self.max_severity = ($truthy(($ret_or_1 = self.max_severity)) ? ($ret_or_1) : (severity)))))) {
          self.max_severity = severity;
        }        return $send2(self, $find_super(self, 'add', $$add, false, true), 'add', [severity, message, progname], $yield);
      }, -2);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BasicFormatter');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $const_set($nesting[0], 'SEVERITY_LABEL_SUBSTITUTES', $hash2(["WARN", "FATAL"], {"WARN": "WARNING", "FATAL": "FAILED"}));
        return $def(self, '$call', function $$call(severity, _, progname, msg) {
          var $ret_or_1 = nil;

          return "" + (progname) + ": " + (($truthy(($ret_or_1 = $$('SEVERITY_LABEL_SUBSTITUTES')['$[]'](severity))) ? ($ret_or_1) : (severity))) + ": " + (($eqeqeq($$$('String'), msg) ? (msg) : (msg.$inspect()))) + ($$('LF'))
        });
      })($nesting[0], $$('Formatter'), $nesting);
      return (function($base) {
        var self = $module($base, 'AutoFormattingMessage');

        
        return $def(self, '$inspect', function $$inspect() {
          var self = this, sloc = nil;

          if ($truthy((sloc = self['$[]']("source_location")))) {
            return "" + (sloc) + ": " + (self['$[]']("text"))
          } else {
            return self['$[]']("text")
          }
        })
      })($nesting[0]);
    })($nesting[0], $$$('Logger'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'MemoryLogger');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.messages = nil;
      
      $const_set($nesting[0], 'SEVERITY_SYMBOL_BY_VALUE', $send($$('Severity').$constants(false), 'map', [], function $MemoryLogger$1(c){
        
        if (c == null) c = nil;
        return [$$('Severity').$const_get(c), c];}).$to_h());
      self.$attr_reader("messages");
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self['$level=']($$('WARN'));
        return (self.messages = []);
      });
      
      $def(self, '$add', function $$add(severity, message, progname) {
        var $yield = $$add.$$p || nil, self = this, $ret_or_1 = nil;

        $$add.$$p = null;
        
        if (message == null) message = nil;
        if (progname == null) progname = nil;
        message = ($truthy(($ret_or_1 = message)) ? ($ret_or_1) : (($yield !== nil) ? (Opal.yieldX($yield, [])) : (progname)));
        self.messages['$<<']($hash2(["severity", "message"], {"severity": $$('SEVERITY_SYMBOL_BY_VALUE')['$[]'](($truthy(($ret_or_1 = severity)) ? ($ret_or_1) : ($$('UNKNOWN')))), "message": message}));
        return true;
      }, -2);
      
      $def(self, '$clear', function $$clear() {
        var self = this;

        return self.messages.$clear()
      });
      
      $def(self, '$empty?', function $MemoryLogger_empty$ques$2() {
        var self = this;

        return self.messages['$empty?']()
      });
      return $def(self, '$max_severity', function $$max_severity() {
        var self = this;

        if ($truthy(self['$empty?']())) {
          return nil
        } else {
          return $send(self.messages, 'map', [], function $$3(m){
            
            if (m == null) m = nil;
            return $$('Severity').$const_get(m['$[]']("severity"));}).$max()
        }
      });
    })($nesting[0], $$$('Logger'), $nesting);
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'NullLogger');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.max_severity = nil;
      
      self.$attr_reader("max_severity");
      
      $def(self, '$initialize', function $$initialize() {
        var $a, self = this;

        return ($a = [$$('WARN')], $send(self, 'level=', $a), $a[$a.length - 1])
      });
      return $def(self, '$add', function $$add(severity, message, progname) {
        var self = this, $ret_or_1 = nil;
        if ($truthy($rb_gt((severity = ($truthy(($ret_or_1 = severity)) ? ($ret_or_1) : ($$('UNKNOWN')))), (self.max_severity = ($truthy(($ret_or_1 = self.max_severity)) ? ($ret_or_1) : (severity)))))) {
          self.max_severity = severity;
        }        return true;
      }, -2);
    })($nesting[0], $$$('Logger'), $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'LoggerManager');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.logger_class = $$('Logger');
      return (function(self, $parent_nesting) {

        
        self.$attr_accessor("logger_class");
        
        $def(self, '$logger', function $$logger(pipe) {
          var self = this, $ret_or_1 = nil;
          if (self.logger == null) self.logger = nil;
          if (self.logger_class == null) self.logger_class = nil;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          
          if (pipe == null) pipe = $gvars.stderr;
          self.$memoize_logger();
          return (self.logger = ($truthy(($ret_or_1 = self.logger)) ? ($ret_or_1) : (self.logger_class.$new(pipe))));
        }, -1);
        
        $def(self, '$logger=', function $logger$eq$4(new_logger) {
          var self = this, $ret_or_1 = nil;
          if (self.logger_class == null) self.logger_class = nil;
          if ($gvars.stderr == null) $gvars.stderr = nil;

          return (self.logger = ($truthy(($ret_or_1 = new_logger)) ? ($ret_or_1) : (self.logger_class.$new($gvars.stderr))))
        });
        self.$private();
        return $def(self, '$memoize_logger', function $$memoize_logger() {
          var self = this;

          return (function(self, $parent_nesting) {
            
            
            $alias(self, "logger", "logger");
            return self.$attr_reader("logger");
          })(Opal.get_singleton_class(self))
        });
      })(Opal.get_singleton_class(self));
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'Logging');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $defs(self, '$included', function $$included(into) {
        
        return into.$extend($$('Logging'))
      });
      self.$private_class_method("included");
      
      $def(self, '$logger', function $$logger() {
        
        return $$('LoggerManager').$logger()
      });
      return $def(self, '$message_with_context', function $$message_with_context(text, context) {
        
        
        if (context == null) context = $hash2([], {});
        return $hash2(["text"], {"text": text}).$merge(context).$extend($$$($$('Logger'), 'AutoFormattingMessage'));
      }, -2);
    })($nesting[0], $nesting);
  })($nesting[0], $nesting);
};

Opal.modules["asciidoctor/rx"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $regexp = Opal.regexp, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $hash = Opal.hash, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('join,to_a,new,[]=,empty?,escape');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    $module($nesting[0], 'Rx');
    $const_set($nesting[0], 'AuthorInfoLineRx', $regexp(["^(", $$('CG_WORD'), "[", $$('CC_WORD'), "\\-'.]*)(?: +(", $$('CG_WORD'), "[", $$('CC_WORD'), "\\-'.]*))?(?: +(", $$('CG_WORD'), "[", $$('CC_WORD'), "\\-'.]*))?(?: +<([^>]+)>)?$"]));
    $const_set($nesting[0], 'AuthorDelimiterRx', /;(?: |$)/);
    $const_set($nesting[0], 'RevisionInfoLineRx', $regexp(["^(?:[^\\d{]*(", $$('CC_ANY'), "*?),)? *(?!:)(", $$('CC_ANY'), "*?)(?: *(?!^),?: *(", $$('CC_ANY'), "*))?$"]));
    $const_set($nesting[0], 'ManpageTitleVolnumRx', $regexp(["^(", $$('CC_ANY'), "+?) *\\( *(", $$('CC_ANY'), "+?) *\\)$"]));
    $const_set($nesting[0], 'ManpageNamePurposeRx', $regexp(["^(", $$('CC_ANY'), "+?) +- +(", $$('CC_ANY'), "+)$"]));
    $const_set($nesting[0], 'ConditionalDirectiveRx', $regexp(["^(\\\\)?(ifdef|ifndef|ifeval|endif)::(\\S*?(?:([,+])\\S*?)?)\\[(", $$('CC_ANY'), "+)?\\]$"]));
    $const_set($nesting[0], 'EvalExpressionRx', $regexp(["^(", $$('CC_ANY'), "+?) *([=!><]=|[><]) *(", $$('CC_ANY'), "+)$"]));
    $const_set($nesting[0], 'IncludeDirectiveRx', $regexp(["^(\\\\)?include::([^\\s\\[](?:[^\\[]*[^\\s\\[])?)\\[(", $$('CC_ANY'), "+)?\\]$"]));
    $const_set($nesting[0], 'TagDirectiveRx', /\b(?:tag|(e)nd)::(\S+?)\[\](?=$|[ \r])/m);
    $const_set($nesting[0], 'AttributeEntryRx', $regexp(["^:(!?", $$('CG_WORD'), "[^:]*):(?:[ \\t]+(", $$('CC_ANY'), "*))?$"]));
    $const_set($nesting[0], 'InvalidAttributeNameCharsRx', $regexp(["[^", $$('CC_WORD'), "-]"]));
    $const_set($nesting[0], 'AttributeEntryPassMacroRx', $regexp(["^pass:([a-z]+(?:,[a-z-]+)*)?\\[(", $$('CC_ALL'), "*)\\]$"]));
    $const_set($nesting[0], 'AttributeReferenceRx', $regexp(["(\\\\)?\\{(", $$('CG_WORD'), "[", $$('CC_WORD'), "-]*|(set|counter2?):", $$('CC_ANY'), "+?)(\\\\)?\\}"]));
    $const_set($nesting[0], 'BlockAnchorRx', $regexp(["^\\[\\[(?:|([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+))?)\\]\\]$"]));
    $const_set($nesting[0], 'BlockAttributeListRx', $regexp(["^\\[(|[", $$('CC_WORD'), ".#%{,\"']", $$('CC_ANY'), "*)\\]$"]));
    $const_set($nesting[0], 'BlockAttributeLineRx', $regexp(["^\\[(?:|[", $$('CC_WORD'), ".#%{,\"']", $$('CC_ANY'), "*|\\[(?:|[", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*(?:, *", $$('CC_ANY'), "+)?)\\])\\]$"]));
    $const_set($nesting[0], 'BlockTitleRx', $regexp(["^\\.(\\.?[^ \\t.]", $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'AdmonitionParagraphRx', $regexp(["^(", $$('ADMONITION_STYLES').$to_a().$join("|"), "):[ \\t]+"]));
    $const_set($nesting[0], 'LiteralParagraphRx', $regexp(["^([ \\t]+", $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'AtxSectionTitleRx', $regexp(["^(=={0,5})[ \\t]+(", $$('CC_ANY'), "+?)(?:[ \\t]+\\1)?$"]));
    $const_set($nesting[0], 'ExtAtxSectionTitleRx', $regexp(["^(=={0,5}|#\\\#{0,5})[ \\t]+(", $$('CC_ANY'), "+?)(?:[ \\t]+\\1)?$"]));
    $const_set($nesting[0], 'SetextSectionTitleRx', $regexp(["^((?!\\.)", $$('CC_ANY'), "*?", $$('CG_ALNUM'), $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'InlineSectionAnchorRx', $regexp([" (\\\\)?\\[\\[([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+))?\\]\\]$"]));
    $const_set($nesting[0], 'InvalidSectionIdCharsRx', $regexp(["<[^>]+>|&(?:[a-z][a-z]+\\d{0,2}|#\\d\\d\\d{0,4}|#x[\\da-f][\\da-f][\\da-f]{0,3});|[^ ", $$('CC_WORD'), "\\-.]+?"]));
    $const_set($nesting[0], 'SectionLevelStyleRx', /^sect\d$/);
    $const_set($nesting[0], 'AnyListRx', $regexp(["^(?:[ \\t]*(?:-|\\*\\**|\\.\\.*|\\u2022|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]|(?!//[^/])[ \\t]*[^ \\t]", $$('CC_ANY'), "*?(?::::{0,2}|;;)(?:$|[ \\t])|<(?:\\d+|\\.)>[ \\t])"]));
    $const_set($nesting[0], 'UnorderedListRx', $regexp(["^[ \\t]*(-|\\*\\**|\\u2022)[ \\t]+(", $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'OrderedListRx', $regexp(["^[ \\t]*(\\.\\.*|\\d+\\.|[a-zA-Z]\\.|[IVXivx]+\\))[ \\t]+(", $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'OrderedListMarkerRxMap', $hash2(["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"], {"arabic": /\d+\./, "loweralpha": /[a-z]\./, "lowerroman": /[ivx]+\)/, "upperalpha": /[A-Z]\./, "upperroman": /[IVX]+\)/}));
    $const_set($nesting[0], 'DescriptionListRx', $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$('CC_ANY'), "*?)(:::{0,2}|;;)(?:$|[ \\t]+(", $$('CC_ANY'), "*)$)"]));
    $const_set($nesting[0], 'DescriptionListSiblingRx', $hash2(["::", ":::", "::::", ";;"], {"::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$('CC_ANY'), "*?[^:]|[^ \\t:])(::)(?:$|[ \\t]+(", $$('CC_ANY'), "*)$)"]), ":::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$('CC_ANY'), "*?[^:]|[^ \\t:])(:::)(?:$|[ \\t]+(", $$('CC_ANY'), "*)$)"]), "::::": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$('CC_ANY'), "*?[^:]|[^ \\t:])(::::)(?:$|[ \\t]+(", $$('CC_ANY'), "*)$)"]), ";;": $regexp(["^(?!//[^/])[ \\t]*([^ \\t]", $$('CC_ANY'), "*?)(;;)(?:$|[ \\t]+(", $$('CC_ANY'), "*)$)"])}));
    $const_set($nesting[0], 'CalloutListRx', $regexp(["^<(\\d+|\\.)>[ \\t]+(", $$('CC_ANY'), "*)$"]));
    $const_set($nesting[0], 'CalloutExtractRx', /((?:\/\/|#|--|;;) ?)?(\\)?<!?(|--)(\d+|\.)\3>(?=(?: ?\\?<!?\3(?:\d+|\.)\3>)*$)/);
    $const_set($nesting[0], 'CalloutExtractRxt', "(\\\\)?<()(\\d+|\\.)>(?=(?: ?\\\\?<(?:\\d+|\\.)>)*$)");
    $const_set($nesting[0], 'CalloutExtractRxMap', $send($$$('Hash'), 'new', [], function $Asciidoctor$1(h, k){var $a;

      
      if (h == null) h = nil;
      if (k == null) k = nil;
      return ($a = [k, $regexp(["(", ($truthy(k['$empty?']()) ? ("") : ("" + ($$$('Regexp').$escape(k)) + " ?")), ")?", $$('CalloutExtractRxt')])], $send(h, '[]=', $a), $a[$a.length - 1]);}));
    $const_set($nesting[0], 'CalloutScanRx', $regexp(["\\\\?<!?(|--)(\\d+|\\.)\\1>(?=(?: ?\\\\?<!?\\1(?:\\d+|\\.)\\1>)*", $$('CC_EOL'), ")"]));
    $const_set($nesting[0], 'CalloutSourceRx', $regexp(["((?://|#|--|;;) ?)?(\\\\)?&lt;!?(|--)(\\d+|\\.)\\3&gt;(?=(?: ?\\\\?&lt;!?\\3(?:\\d+|\\.)\\3&gt;)*", $$('CC_EOL'), ")"]));
    $const_set($nesting[0], 'CalloutSourceRxt', "(\\\\)?&lt;()(\\d+|\\.)&gt;(?=(?: ?\\\\?&lt;(?:\\d+|\\.)&gt;)*" + ($$('CC_EOL')) + ")");
    $const_set($nesting[0], 'CalloutSourceRxMap', $send($$$('Hash'), 'new', [], function $Asciidoctor$2(h, k){var $a;

      
      if (h == null) h = nil;
      if (k == null) k = nil;
      return ($a = [k, $regexp(["(", ($truthy(k['$empty?']()) ? ("") : ("" + ($$$('Regexp').$escape(k)) + " ?")), ")?", $$('CalloutSourceRxt')])], $send(h, '[]=', $a), $a[$a.length - 1]);}));
    $const_set($nesting[0], 'ListRxMap', $hash2(["ulist", "olist", "dlist", "colist"], {"ulist": $$('UnorderedListRx'), "olist": $$('OrderedListRx'), "dlist": $$('DescriptionListRx'), "colist": $$('CalloutListRx')}));
    $const_set($nesting[0], 'ColumnSpecRx', /^(?:(\d+)\*)?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?(\d+%?|~)?([a-z])?$/);
    $const_set($nesting[0], 'CellSpecStartRx', /^[ \t]*(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
    $const_set($nesting[0], 'CellSpecEndRx', /[ \t]+(?:(\d+(?:\.\d*)?|(?:\d*\.)?\d+)([*+]))?([<^>](?:\.[<^>]?)?|(?:[<^>]?\.)?[<^>])?([a-z])?$/);
    $const_set($nesting[0], 'CustomBlockMacroRx', $regexp(["^(", $$('CG_WORD'), "[", $$('CC_WORD'), "-]*)::(|\\S|\\S", $$('CC_ANY'), "*?\\S)\\[(", $$('CC_ANY'), "+)?\\]$"]));
    $const_set($nesting[0], 'BlockMediaMacroRx', $regexp(["^(image|video|audio)::(\\S|\\S", $$('CC_ANY'), "*?\\S)\\[(", $$('CC_ANY'), "+)?\\]$"]));
    $const_set($nesting[0], 'BlockTocMacroRx', $regexp(["^toc::\\[(", $$('CC_ANY'), "+)?\\]$"]));
    $const_set($nesting[0], 'InlineAnchorRx', $regexp(["(\\\\)?(?:\\[\\[([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+?))?\\]\\]|anchor:([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)\\[(?:\\]|(", $$('CC_ANY'), "*?[^\\\\])\\]))"]));
    $const_set($nesting[0], 'InlineAnchorScanRx', $regexp(["(?:^|[^\\\\\\[])\\[\\[([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+?))?\\]\\]|(?:^|[^\\\\])anchor:([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)\\[(?:\\]|(", $$('CC_ANY'), "*?[^\\\\])\\])"]));
    $const_set($nesting[0], 'LeadingInlineAnchorRx', $regexp(["^\\[\\[([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+?))?\\]\\]"]));
    $const_set($nesting[0], 'InlineBiblioAnchorRx', $regexp(["^\\[\\[\\[([", $$('CC_ALPHA'), "_:][", $$('CC_WORD'), "\\-:.]*)(?:, *(", $$('CC_ANY'), "+?))?\\]\\]\\]"]));
    $const_set($nesting[0], 'InlineEmailRx', $regexp(["([\\\\>:/])?", $$('CG_WORD'), "(?:&amp;|[", $$('CC_WORD'), "\\-.%+])*@", $$('CG_ALNUM'), "[", $$('CC_ALNUM'), "_\\-.]*\\.[a-zA-Z]{2,5}\\b"]));
    $const_set($nesting[0], 'InlineFootnoteMacroRx', $regexp(["\\\\?footnote(?:(ref):|:([", $$('CC_WORD'), "-]+)?)\\[(?:|(", $$('CC_ALL'), "*?[^\\\\]))\\](?!</a>)"], 'm'));
    $const_set($nesting[0], 'InlineImageMacroRx', $regexp(["\\\\?i(?:mage|con):([^:\\s\\[](?:[^\\n\\[]*[^\\s\\[])?)\\[(|", $$('CC_ALL'), "*?[^\\\\])\\]"], 'm'));
    $const_set($nesting[0], 'InlineIndextermMacroRx', $regexp(["\\\\?(?:(indexterm2?):\\[(", $$('CC_ALL'), "*?[^\\\\])\\]|\\(\\((", $$('CC_ALL'), "+?)\\)\\)(?!\\)))"], 'm'));
    $const_set($nesting[0], 'InlineKbdBtnMacroRx', $regexp(["(\\\\)?(kbd|btn):\\[(", $$('CC_ALL'), "*?[^\\\\])\\]"], 'm'));
    $const_set($nesting[0], 'InlineLinkRx', $regexp(["(^|link:|", $$('CG_BLANK'), "|&lt;|[>\\(\\)\\[\\];\"'])(\\\\?(?:https?|file|ftp|irc)://)(?:([^\\s\\[\\]]+)\\[(|", $$('CC_ALL'), "*?[^\\\\])\\]|([^\\s\\[\\]<]*([^\\s,.?!\\[\\]<\\)])))"], 'm'));
    $const_set($nesting[0], 'InlineLinkMacroRx', $regexp(["\\\\?(?:link|(mailto)):(|[^:\\s\\[][^\\s\\[]*)\\[(|", $$('CC_ALL'), "*?[^\\\\])\\]"], 'm'));
    $const_set($nesting[0], 'MacroNameRx', $regexp(["^", $$('CG_WORD'), "[", $$('CC_WORD'), "-]*$"]));
    $const_set($nesting[0], 'InlineStemMacroRx', $regexp(["\\\\?(stem|(?:latex|ascii)math):([a-z]+(?:,[a-z-]+)*)?\\[(", $$('CC_ALL'), "*?[^\\\\])\\]"], 'm'));
    $const_set($nesting[0], 'InlineMenuMacroRx', $regexp(["\\\\?menu:(", $$('CG_WORD'), "|[", $$('CC_WORD'), "&][^\\n\\[]*[^\\s\\[])\\[ *(?:|(", $$('CC_ALL'), "*?[^\\\\]))\\]"], 'm'));
    $const_set($nesting[0], 'InlineMenuRx', $regexp(["\\\\?\"([", $$('CC_WORD'), "&][^\"]*?[ \\n]+&gt;[ \\n]+[^\"]*)\""]));
    $const_set($nesting[0], 'InlinePassRx', $hash(false, ["+", "-]", $regexp(["((?:^|[^", $$('CC_WORD'), ";:\\\\])(?=(\\[)|\\+)|\\\\(?=\\[)|(?=\\\\\\+))(?:\\2(x-|[^\\]]+ x-)\\]|(?:\\[([^\\]]+)\\])?(?=(\\\\)?\\+))(\\5?(\\+|`)(\\S|\\S", $$('CC_ALL'), "*?\\S)\\7)(?!", $$('CG_WORD'), ")"], 'm')], true, ["`", nil, $regexp(["(^|[^`", $$('CC_WORD'), "])(?:(\\Z)()|\\[([^\\]]+)\\](?=(\\\\))?)?(\\5?(`)([^`\\s]|[^`\\s]", $$('CC_ALL'), "*?\\S)\\7)(?![`", $$('CC_WORD'), "])"], 'm')]));
    $const_set($nesting[0], 'InlinePassMacroRx', $regexp(["(?:(?:(\\\\?)\\[([^\\]]+)\\])?(\\\\{0,2})(\\+\\+\\+?|\\$\\$)(", $$('CC_ALL'), "*?)\\4|(\\\\?)pass:([a-z]+(?:,[a-z-]+)*)?\\[(|", $$('CC_ALL'), "*?[^\\\\])\\])"], 'm'));
    $const_set($nesting[0], 'InlineXrefMacroRx', $regexp(["\\\\?(?:&lt;&lt;([", $$('CC_WORD'), "#/.:{]", $$('CC_ALL'), "*?)&gt;&gt;|xref:([", $$('CC_WORD'), "#/.:{]", $$('CC_ALL'), "*?)\\[(?:\\]|(", $$('CC_ALL'), "*?[^\\\\])\\]))"], 'm'));
    $const_set($nesting[0], 'HardLineBreakRx', $regexp(["^(", $$('CC_ANY'), "*) \\+$"], 'm'));
    $const_set($nesting[0], 'MarkdownThematicBreakRx', /^ {0,3}([-*_])( *)\1\2\1$/);
    $const_set($nesting[0], 'ExtLayoutBreakRx', /^(?:'{3,}|<{3,}|([-*_])( *)\1\2\1)$/);
    $const_set($nesting[0], 'BlankLineRx', /\n{2,}/);
    $const_set($nesting[0], 'EscapedSpaceRx', /\\([ \t\n])/);
    $const_set($nesting[0], 'ReplaceableTextRx', /[&']|--|\.\.\.|\([CRT]M?\)/);
    $const_set($nesting[0], 'SpaceDelimiterRx', /([^\\])[ \t\n]+/);
    $const_set($nesting[0], 'SubModifierSniffRx', /[+-]/);
    $const_set($nesting[0], 'TrailingDigitsRx', /\d+$/);
    $const_set($nesting[0], 'UriSniffRx', $regexp(["^", $$('CG_ALPHA'), "[", $$('CC_ALNUM'), ".+-]+:/{0,2}"]));
    return $const_set($nesting[0], 'XmlSanitizeRx', /<[^>]+>/);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/substitutors"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $hash2 = Opal.hash2, $hash = Opal.hash, $rb_plus = Opal.rb_plus, $regexp = Opal.regexp, $not = Opal.not, $truthy = Opal.truthy, $send = Opal.send, $def = Opal.def, $alias = Opal.alias, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $to_ary = Opal.to_ary, $neqeq = Opal.neqeq, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_gt = Opal.rb_gt, $slice = Opal.slice, $rb_minus = Opal.rb_minus, $rb_lt = Opal.rb_lt, $rb_times = Opal.rb_times, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('freeze,+,keys,!,empty?,===,[],join,include?,extract_passthroughs,each,sub_specialchars,sub_quotes,sub_attributes,sub_replacements,sub_macros,highlight_source,sub_callouts,sub_post_replacements,warn,logger,restore_passthroughs,clear,split,apply_subs,gsub,match?,compat_mode,convert_quoted_text,attributes,==,shift,store_attribute,!=,attribute_undefined,counter,key?,downcase,attribute_missing,info,squeeze,delete,reject,start_with?,do_replacement,inline_macros?,extensions,inline_macros,regexp,instance,slice,length,names,config,merge,[]=,normalize_text,parse_attributes,process_method,expand_subs,text=,text,convert,class,strip,index,min,compact,>,end_with?,map,chop,new,pop,rstrip,register,tr,basename,parse,lstrip,split_simple_csv,-,partition,extract_attributes_from_text,sub,encode_uri_component,style,extname?,rindex,catalog,info?,fetch,outfilesuffix,natural_xrefs,resolve_id,find,footnotes,id,<,size,<<,attr?,attr,to_s,read_next_id,callouts,highlight?,syntax_highlighter,sub_source,extract_callouts,name,to_i,to_sym,resolve_lines_to_highlight,highlight,nil_or_empty?,restore_callouts,count,to_a,|,sort,*,parse_quoted_text_attributes,resolve_pass_subs,basebackend?,error,chr,drop,&,resolve_subs,resolve_block_subs,parse_into,private,shorthand_property_syntax,each_char');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Substitutors');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      $const_set($nesting[0], 'SpecialCharsRx', /[<&>]/);
      $const_set($nesting[0], 'SpecialCharsTr', $hash2([">", "<", "&"], {">": "&gt;", "<": "&lt;", "&": "&amp;"}));
      $const_set($nesting[0], 'QuotedTextSniffRx', $hash(false, /[*_`#^~]/, true, /[*'_+#^~]/));
      $const_set($nesting[0], 'BASIC_SUBS', ["specialcharacters"]).$freeze();
      $const_set($nesting[0], 'HEADER_SUBS', ["specialcharacters", "attributes"]).$freeze();
      $const_set($nesting[0], 'NO_SUBS', []).$freeze();
      $const_set($nesting[0], 'NORMAL_SUBS', ["specialcharacters", "quotes", "attributes", "replacements", "macros", "post_replacements"]).$freeze();
      $const_set($nesting[0], 'REFTEXT_SUBS', ["specialcharacters", "quotes", "replacements"]).$freeze();
      $const_set($nesting[0], 'VERBATIM_SUBS', ["specialcharacters", "callouts"]).$freeze();
      $const_set($nesting[0], 'SUB_GROUPS', $hash2(["none", "normal", "verbatim", "specialchars"], {"none": $$('NO_SUBS'), "normal": $$('NORMAL_SUBS'), "verbatim": $$('VERBATIM_SUBS'), "specialchars": $$('BASIC_SUBS')}));
      $const_set($nesting[0], 'SUB_HINTS', $hash2(["a", "m", "n", "p", "q", "r", "c", "v"], {"a": "attributes", "m": "macros", "n": "normal", "p": "post_replacements", "q": "quotes", "r": "replacements", "c": "specialcharacters", "v": "verbatim"}));
      $const_set($nesting[0], 'SUB_OPTIONS', $hash2(["block", "inline"], {"block": $rb_plus($rb_plus($$('SUB_GROUPS').$keys(), $$('NORMAL_SUBS')), ["callouts"]), "inline": $rb_plus($$('SUB_GROUPS').$keys(), $$('NORMAL_SUBS'))}));
      $const_set($nesting[0], 'CAN', "\u0018");
      $const_set($nesting[0], 'DEL', "\u007F");
      $const_set($nesting[0], 'PASS_START', "\u0096");
      $const_set($nesting[0], 'PASS_END', "\u0097");
      $const_set($nesting[0], 'PassSlotRx', $regexp([$$('PASS_START'), "(\\d+)", $$('PASS_END')]));
      $const_set($nesting[0], 'HighlightedPassSlotRx', $regexp(["<span\\b[^>]*>", $$('PASS_START'), "</span>[^\\d]*(\\d+)[^\\d]*<span\\b[^>]*>", $$('PASS_END'), "</span>"]));
      $const_set($nesting[0], 'RS', "\\");
      $const_set($nesting[0], 'R_SB', "]");
      $const_set($nesting[0], 'ESC_R_SB', "\\]");
      $const_set($nesting[0], 'PLUS', "+");
      
      $def(self, '$apply_subs', function $$apply_subs(text, subs) {
        var self = this, is_multiline = nil, passthrus = nil, $ret_or_1 = nil, clear_passthrus = nil;
        if (self.passthroughs == null) self.passthroughs = nil;
        if (self.passthroughs_locked == null) self.passthroughs_locked = nil;

        
        if (subs == null) subs = $$('NORMAL_SUBS');
        if (($truthy(text['$empty?']()) || ($not(subs)))) {
          return text
        }        if ($truthy((is_multiline = $$$('Array')['$==='](text)))) {
          text = ($truthy(text['$[]'](1)) ? (text.$join($$('LF'))) : (text['$[]'](0)));
        }        if ($truthy(subs['$include?']("macros"))) {
          
          text = self.$extract_passthroughs(text);
          if (!$truthy(self.passthroughs['$empty?']())) {
            
            passthrus = self.passthroughs;
            self.passthroughs_locked = ($truthy(($ret_or_1 = self.passthroughs_locked)) ? ($ret_or_1) : ((clear_passthrus = true)));
          }        }        $send(subs, 'each', [], function $$1(type){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (type == null) type = nil;
          
          switch (type) {
            case "specialcharacters":
              return (text = self.$sub_specialchars(text))
            case "quotes":
              return (text = self.$sub_quotes(text))
            case "attributes":
              if ($truthy(text['$include?']($$('ATTR_REF_HEAD')))) {
                return (text = self.$sub_attributes(text))
              } else {
                return nil
              }
            case "replacements":
              return (text = self.$sub_replacements(text))
            case "macros":
              return (text = self.$sub_macros(text))
            case "highlight":
              return (text = self.$highlight_source(text, subs['$include?']("callouts")))
            case "callouts":
              if ($truthy(subs['$include?']("highlight"))) {
                return nil
              } else {
                return (text = self.$sub_callouts(text))
              }
            case "post_replacements":
              return (text = self.$sub_post_replacements(text))
            default:
              return self.$logger().$warn("unknown substitution type " + (type))
          }}, {$$s: self});
        if ($truthy(passthrus)) {
          
          text = self.$restore_passthroughs(text);
          if ($truthy(clear_passthrus)) {
            
            passthrus.$clear();
            self.passthroughs_locked = nil;
          }        }        if ($truthy(is_multiline)) {
          
          return text.$split($$('LF'), -1);
        } else {
          return text
        }      }, -2);
      
      $def(self, '$apply_normal_subs', function $$apply_normal_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$('NORMAL_SUBS'))
      });
      
      $def(self, '$apply_header_subs', function $$apply_header_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$('HEADER_SUBS'))
      });
      $alias(self, "apply_title_subs", "apply_subs");
      
      $def(self, '$apply_reftext_subs', function $$apply_reftext_subs(text) {
        var self = this;

        return self.$apply_subs(text, $$('REFTEXT_SUBS'))
      });
      
      $def(self, '$sub_specialchars', function $$sub_specialchars(text) {
        
        if ((($truthy(text['$include?'](">")) || ($truthy(text['$include?']("&")))) || ($truthy(text['$include?']("<"))))) {
          
          return text.$gsub($$('SpecialCharsRx'), $$('SpecialCharsTr'));
        } else {
          return text
        }
      });
      $alias(self, "sub_specialcharacters", "sub_specialchars");
      
      $def(self, '$sub_quotes', function $$sub_quotes(text) {
        var self = this, compat = nil;
        if (self.document == null) self.document = nil;

        
        if ($truthy($$('QuotedTextSniffRx')['$[]']((compat = self.document.$compat_mode()))['$match?'](text))) {
          $send($$('QUOTE_SUBS')['$[]'](compat), 'each', [], function $$2(type, scope, pattern){var self = $$2.$$s == null ? this : $$2.$$s;

            
            if (type == null) type = nil;
            if (scope == null) scope = nil;
            if (pattern == null) pattern = nil;
            return (text = $send(text, 'gsub', [pattern], function $$3(){var self = $$3.$$s == null ? this : $$3.$$s;
              if ($gvars["~"] == null) $gvars["~"] = nil;

              return self.$convert_quoted_text($gvars["~"], type, scope)}, {$$s: self}));}, {$$s: self});
        }        return text;
      });
      
      $def(self, '$sub_attributes', function $$sub_attributes(text, opts) {
        var self = this, doc_attrs = nil, drop = nil, drop_line = nil, drop_line_severity = nil, drop_empty_line = nil, attribute_undefined = nil, attribute_missing = nil, lines = nil;
        if (self.document == null) self.document = nil;

        
        if (opts == null) opts = $hash2([], {});
        doc_attrs = self.document.$attributes();
        drop = (drop_line = (drop_line_severity = (drop_empty_line = (attribute_undefined = (attribute_missing = nil)))));
        text = $send(text, 'gsub', [$$('AttributeReferenceRx')], function $$4(){var $a, $b, self = $$4.$$s == null ? this : $$4.$$s, args = nil, $ret_or_2 = nil, value = nil, $ret_or_3 = nil, key = nil, $ret_or_4 = nil;
          if (self.document == null) self.document = nil;

          if (($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), $$('RS')) || ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), $$('RS'))))) {
            return "{" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))) + "}"
          } else if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))) {
            
            switch ((args = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$split(":", 3)).$shift()) {
              case "set":
                
                $b = $$('Parser').$store_attribute(args['$[]'](0), ($truthy(($ret_or_2 = args['$[]'](1))) ? ($ret_or_2) : ("")), self.document), $a = $to_ary($b), (($a[0] == null ? nil : $a[0])), (value = ($a[1] == null ? nil : $a[1]));
                if (($truthy(value) || ($neqeq((attribute_undefined = ($truthy(($ret_or_2 = attribute_undefined)) ? ($ret_or_2) : (($truthy(($ret_or_3 = doc_attrs['$[]']("attribute-undefined"))) ? ($ret_or_3) : ($$('Compliance').$attribute_undefined()))))), "drop-line")))) {
                  return (drop = (drop_empty_line = $$('DEL')))
                } else {
                  return (drop = (drop_line = $$('CAN')))
                }              case "counter2":
                
                $send(self.document, 'counter', $to_a(args));
                return (drop = (drop_empty_line = $$('DEL')));
              default:
                return $send(self.document, 'counter', $to_a(args))
            }
          } else if ($truthy(doc_attrs['$key?']((key = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)).$downcase())))) {
            return doc_attrs['$[]'](key)
          } else if ($truthy((value = $$('INTRINSIC_ATTRIBUTES')['$[]'](key)))) {
            return value
          } else 
          switch ((attribute_missing = ($truthy(($ret_or_2 = attribute_missing)) ? ($ret_or_2) : (($truthy(($ret_or_3 = ($truthy(($ret_or_4 = opts['$[]']("attribute_missing"))) ? ($ret_or_4) : (doc_attrs['$[]']("attribute-missing"))))) ? ($ret_or_3) : ($$('Compliance').$attribute_missing())))))) {
            case "drop":
              return (drop = (drop_empty_line = $$('DEL')))
            case "drop-line":
              
              if ($eqeq((drop_line_severity = ($truthy(($ret_or_2 = drop_line_severity)) ? ($ret_or_2) : (($truthy(($ret_or_3 = opts['$[]']("drop_line_severity"))) ? ($ret_or_3) : ("info"))))), "info")) {
                $send(self.$logger(), 'info', [], function $$5(){
                  return "dropping line containing reference to missing attribute: " + (key)});
              }              return (drop = (drop_line = $$('CAN')));
            case "warn":
              
              self.$logger().$warn("skipping reference to missing attribute: " + (key));
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0));
            default:
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
          }}, {$$s: self});
        if ($truthy(drop)) {
          if ($truthy(drop_empty_line)) {
            
            lines = text.$squeeze($$('DEL')).$split($$('LF'), -1);
            if ($truthy(drop_line)) {
              return $send(lines, 'reject', [], function $$6(line){var $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

                
                if (line == null) line = nil;
                if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = line['$==']($$('DEL')))) ? ($ret_or_3) : (line['$==']($$('CAN')))))) ? ($ret_or_2) : (line['$start_with?']($$('CAN'))))))) {
                  return $ret_or_1
                } else {
                  
                  return line['$include?']($$('CAN'));
                }}).$join($$('LF')).$delete($$('DEL'))
            } else {
              return $send(lines, 'reject', [], function $$7(line){
                
                if (line == null) line = nil;
                return line['$==']($$('DEL'));}).$join($$('LF')).$delete($$('DEL'))
            }          } else if ($truthy(text['$include?']($$('LF')))) {
            return $send(text.$split($$('LF'), -1), 'reject', [], function $$8(line){var $ret_or_1 = nil, $ret_or_2 = nil;

              
              if (line == null) line = nil;
              if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = line['$==']($$('CAN')))) ? ($ret_or_2) : (line['$start_with?']($$('CAN'))))))) {
                return $ret_or_1
              } else {
                
                return line['$include?']($$('CAN'));
              }}).$join($$('LF'))
          } else {
            return ""
          }
        } else {
          return text
        }      }, -2);
      
      $def(self, '$sub_replacements', function $$sub_replacements(text) {
        var self = this;

        
        if ($truthy($$('ReplaceableTextRx')['$match?'](text))) {
          $send($$('REPLACEMENTS'), 'each', [], function $$9(pattern, replacement, restore){var self = $$9.$$s == null ? this : $$9.$$s;

            
            if (pattern == null) pattern = nil;
            if (replacement == null) replacement = nil;
            if (restore == null) restore = nil;
            return (text = $send(text, 'gsub', [pattern], function $$10(){var self = $$10.$$s == null ? this : $$10.$$s;
              if ($gvars["~"] == null) $gvars["~"] = nil;

              return self.$do_replacement($gvars["~"], replacement, restore)}, {$$s: self}));}, {$$s: self});
        }        return text;
      });
      
      $def(self, '$sub_macros', function $$sub_macros(text) {
        var self = this, found_square_bracket = nil, found_colon = nil, found_macroish = nil, $ret_or_1 = nil, found_macroish_short = nil, doc_attrs = nil, doc = nil, extensions = nil;
        if (self.document == null) self.document = nil;
        if (self.parent == null) self.parent = nil;
        if (self.context == null) self.context = nil;

        
        found_square_bracket = text['$include?']("[");
        found_colon = text['$include?'](":");
        found_macroish = ($truthy(($ret_or_1 = found_square_bracket)) ? (found_colon) : ($ret_or_1));
        found_macroish_short = ($truthy(($ret_or_1 = found_macroish)) ? (text['$include?'](":[")) : ($ret_or_1));
        doc_attrs = (doc = self.document).$attributes();
        if (($truthy((extensions = doc.$extensions())) && ($truthy(extensions['$inline_macros?']())))) {
          $send(extensions.$inline_macros(), 'each', [], function $$11(extension){var self = $$11.$$s == null ? this : $$11.$$s;

            
            if (extension == null) extension = nil;
            return (text = $send(text, 'gsub', [extension.$instance().$regexp()], function $$12(){var $a, $b, self = $$12.$$s == null ? this : $$12.$$s, match = nil, target = nil, content = nil, attributes = nil, default_attrs = nil, ext_config = nil, $ret_or_2 = nil, replacement = nil, inline_subs = nil;
              if ($gvars["~"] == null) $gvars["~"] = nil;

              
              if ($truthy((match = (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)))['$start_with?']($$('RS')))) {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
              }              if ($truthy($gvars["~"].$names()['$empty?']())) {
                $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2))], (target = $a[0]), (content = $a[1]);
              } else {
                $a = [(function() { try {
                  return $gvars["~"]['$[]']("target")
                } catch ($err) {
                  if (Opal.rescue($err, [$$('StandardError')])) {
                    try {
                      return nil
                    } finally { Opal.pop_exception(); }
                  } else { throw $err; }
                }})(), (function() { try {
                  return $gvars["~"]['$[]']("content")
                } catch ($err) {
                  if (Opal.rescue($err, [$$('StandardError')])) {
                    try {
                      return nil
                    } finally { Opal.pop_exception(); }
                  } else { throw $err; }
                }})()], (target = $a[0]), (content = $a[1]);
              }              attributes = ($truthy((default_attrs = (ext_config = extension.$config())['$[]']("default_attrs"))) ? (default_attrs.$merge()) : ($hash2([], {})));
              if ($truthy(content)) {
                
                if ($truthy(content['$empty?']())) {
                  if (!$eqeq(ext_config['$[]']("content_model"), "attributes")) {
                    attributes['$[]=']("text", content);
                  }
                } else {
                  
                  content = self.$normalize_text(content, true, true);
                  if ($eqeq(ext_config['$[]']("content_model"), "attributes")) {
                    self.$parse_attributes(content, ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ext_config['$[]']("positional_attrs"))) ? ($ret_or_2) : (ext_config['$[]']("pos_attrs"))))) ? ($ret_or_1) : ([])), $hash2(["into"], {"into": attributes}));
                  } else {
                    attributes['$[]=']("text", content);
                  }                }                target = ($truthy(($ret_or_1 = target)) ? ($ret_or_1) : ($eqeq(ext_config['$[]']("format"), "short") ? (content) : (target)));
              }              if ($eqeqeq($$('Inline'), (replacement = extension.$process_method()['$[]'](self, target, attributes)))) {
                
                if (($truthy((inline_subs = replacement.$attributes().$delete("subs"))) && ($truthy((inline_subs = self.$expand_subs(inline_subs, "custom inline macro")))))) {
                  replacement['$text='](self.$apply_subs(replacement.$text(), inline_subs));
                }                return replacement.$convert();
              } else if ($truthy(replacement)) {
                
                $send(self.$logger(), 'info', [], function $$13(){
                  return "expected substitution value for custom inline macro to be of type Inline; got " + (replacement.$class()) + ": " + (match)});
                return replacement;
              } else {
                return ""
              }}, {$$s: self}));}, {$$s: self});
        }        if ($truthy(doc_attrs['$key?']("experimental"))) {
          
          if (($truthy(found_macroish_short) && (($truthy(text['$include?']("kbd:")) || ($truthy(text['$include?']("btn:"))))))) {
            text = $send(text, 'gsub', [$$('InlineKbdBtnMacroRx')], function $$14(){var $a, self = $$14.$$s == null ? this : $$14.$$s, keys = nil, delim_idx = nil, delim = nil;

              if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
              } else if ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), "kbd")) {
                
                if ($truthy((keys = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$strip())['$include?']($$('R_SB')))) {
                  keys = keys.$gsub($$('ESC_R_SB'), $$('R_SB'));
                }                if (($truthy($rb_gt(keys.$length(), 1)) && ($truthy((delim_idx = ($truthy((delim_idx = keys.$index(",", 1))) ? ([delim_idx, keys.$index("+", 1)].$compact().$min()) : (keys.$index("+", 1)))))))) {
                  
                  delim = keys.$slice(delim_idx, 1);
                  if ($truthy(keys['$end_with?'](delim))) {
                    
                    keys = $send(keys.$chop().$split(delim, -1), 'map', [], function $$15(key){
                      
                      if (key == null) key = nil;
                      return key.$strip();});
                    keys['$[]='](-1, $rb_plus(keys['$[]'](-1), delim));
                  } else {
                    keys = $send(keys.$split(delim), 'map', [], function $$16(key){
                      
                      if (key == null) key = nil;
                      return key.$strip();});
                  }                } else {
                  keys = [keys];
                }                return $$('Inline').$new(self, "kbd", nil, $hash2(["attributes"], {"attributes": $hash2(["keys"], {"keys": keys})})).$convert();
              } else {
                return $$('Inline').$new(self, "button", self.$normalize_text((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), true, true)).$convert()
              }}, {$$s: self});
          }          if (($truthy(found_macroish) && ($truthy(text['$include?']("menu:"))))) {
            text = $send(text, 'gsub', [$$('InlineMenuMacroRx')], function $$17(){var $a, self = $$17.$$s == null ? this : $$17.$$s, menu = nil, items = nil, delim = nil, submenus = nil, menuitem = nil;

              
              if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
              }              menu = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
              if ($truthy((items = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {
                
                if ($truthy(items['$include?']($$('R_SB')))) {
                  items = items.$gsub($$('ESC_R_SB'), $$('R_SB'));
                }                if ($truthy((delim = ($truthy(items['$include?']("&gt;")) ? ("&gt;") : (($truthy(items['$include?'](",")) ? (",") : (nil))))))) {
                  
                  submenus = $send(items.$split(delim), 'map', [], function $$18(it){
                    
                    if (it == null) it = nil;
                    return it.$strip();});
                  menuitem = submenus.$pop();
                } else {
                  $a = [[], items.$rstrip()], (submenus = $a[0]), (menuitem = $a[1]);
                }              } else {
                $a = [[], nil], (submenus = $a[0]), (menuitem = $a[1]);
              }              return $$('Inline').$new(self, "menu", nil, $hash2(["attributes"], {"attributes": $hash2(["menu", "submenus", "menuitem"], {"menu": menu, "submenus": submenus, "menuitem": menuitem})})).$convert();}, {$$s: self});
          }          if (($truthy(text['$include?']("\"")) && ($truthy(text['$include?']("&gt;"))))) {
            text = $send(text, 'gsub', [$$('InlineMenuRx')], function $$19(){var $a, $b, $c, self = $$19.$$s == null ? this : $$19.$$s, menu = nil, submenus = nil, menuitem = nil;

              
              if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
              }              $b = $send((($c = $gvars['~']) === nil ? nil : $c['$[]'](1)).$split("&gt;"), 'map', [], function $$20(it){
                
                if (it == null) it = nil;
                return it.$strip();}), $a = $to_ary($b), (menu = ($a[0] == null ? nil : $a[0])), (submenus = $slice($a, 1));
              menuitem = submenus.$pop();
              return $$('Inline').$new(self, "menu", nil, $hash2(["attributes"], {"attributes": $hash2(["menu", "submenus", "menuitem"], {"menu": menu, "submenus": submenus, "menuitem": menuitem})})).$convert();}, {$$s: self});
          }        }        if (($truthy(found_macroish) && (($truthy(text['$include?']("image:")) || ($truthy(text['$include?']("icon:"))))))) {
          text = $send(text, 'gsub', [$$('InlineImageMacroRx')], function $$21(){var $a, self = $$21.$$s == null ? this : $$21.$$s, type = nil, posattrs = nil, target = nil, attrs = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
            } else if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']("icon:"))) {
              $a = ["icon", ["size"]], (type = $a[0]), (posattrs = $a[1]);
            } else {
              $a = ["image", ["alt", "width", "height"]], (type = $a[0]), (posattrs = $a[1]);
            }            target = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
            attrs = self.$parse_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), posattrs, $hash2(["unescape_input"], {"unescape_input": true}));
            if (!$eqeq(type, "icon")) {
              
              doc.$register("images", target);
              attrs['$[]=']("imagesdir", doc_attrs['$[]']("imagesdir"));
            }            if ($truthy(($ret_or_1 = attrs['$[]']("alt")))) ; else {
              attrs['$[]=']("alt", ($a = ["default-alt", $$('Helpers').$basename(target, true).$tr("_-", " ")], $send(attrs, '[]=', $a), $a[$a.length - 1]));
            }            return $$('Inline').$new(self, "image", nil, $hash2(["type", "target", "attributes"], {"type": type, "target": target, "attributes": attrs})).$convert();}, {$$s: self});
        }        if ((($truthy(text['$include?']("((")) && ($truthy(text['$include?']("))")))) || (($truthy(found_macroish_short) && ($truthy(text['$include?']("dexterm"))))))) {
          text = $send(text, 'gsub', [$$('InlineIndextermMacroRx')], function $$22(){var $a, $b, self = $$22.$$s == null ? this : $$22.$$s, attrlist = nil, primary = nil, attrs = nil, see_also = nil, term = nil, $ret_or_2 = nil, $ret_or_3 = nil, encl_text = nil, visible = nil, before = nil, after = nil, see = nil, subbed_term = nil, terms = nil;

            
            switch ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) {
              case "indexterm":
                
                if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
                  return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
                }                if ($truthy((attrlist = self.$normalize_text((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), true, true))['$include?']("="))) {
                  if ($truthy((primary = (attrs = $$('AttributeList').$new(attrlist, self).$parse())['$[]'](1)))) {
                    
                    attrs['$[]=']("terms", [primary]);
                    if ($truthy((see_also = attrs['$[]']("see-also")))) {
                      attrs['$[]=']("see-also", ($truthy(see_also['$include?'](",")) ? ($send(see_also.$split(","), 'map', [], function $$23(it){
                        
                        if (it == null) it = nil;
                        return it.$lstrip();})) : ([see_also])));
                    }                  } else {
                    attrs = $hash2(["terms"], {"terms": attrlist});
                  }
                } else {
                  attrs = $hash2(["terms"], {"terms": self.$split_simple_csv(attrlist)});
                }                return $$('Inline').$new(self, "indexterm", nil, $hash2(["attributes"], {"attributes": attrs})).$convert();
              case "indexterm2":
                
                if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
                  return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
                }                if ($truthy((term = self.$normalize_text((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), true, true))['$include?']("="))) {
                  
                  term = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = (attrs = $$('AttributeList').$new(term, self).$parse())['$[]'](1))) ? ($ret_or_3) : ((attrs = nil))))) ? ($ret_or_2) : (term));
                  if (($truthy(attrs) && ($truthy((see_also = attrs['$[]']("see-also")))))) {
                    attrs['$[]=']("see-also", ($truthy(see_also['$include?'](",")) ? ($send(see_also.$split(","), 'map', [], function $$24(it){
                      
                      if (it == null) it = nil;
                      return it.$lstrip();})) : ([see_also])));
                  }                }                return $$('Inline').$new(self, "indexterm", term, $hash2(["attributes", "type"], {"attributes": attrs, "type": "visible"})).$convert();
              default:
                
                encl_text = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
                if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
                  if (($truthy(encl_text['$start_with?']("(")) && ($truthy(encl_text['$end_with?'](")"))))) {
                    
                    encl_text = encl_text.$slice(1, $rb_minus(encl_text.$length(), 2));
                    $a = [true, "(", ")"], (visible = $a[0]), (before = $a[1]), (after = $a[2]);
                  } else {
                    return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
                  }
                } else {
                  
                  visible = true;
                  if ($truthy(encl_text['$start_with?']("("))) {
                    if ($truthy(encl_text['$end_with?'](")"))) {
                      $a = [encl_text.$slice(1, $rb_minus(encl_text.$length(), 2)), false], (encl_text = $a[0]), (visible = $a[1]);
                    } else {
                      $a = [encl_text.$slice(1, encl_text.$length()), "(", ""], (encl_text = $a[0]), (before = $a[1]), (after = $a[2]);
                    }
                  } else if ($truthy(encl_text['$end_with?'](")"))) {
                    $a = [encl_text.$chop(), "", ")"], (encl_text = $a[0]), (before = $a[1]), (after = $a[2]);
                  }                }                if ($truthy(visible)) {
                  
                  if ($truthy((term = self.$normalize_text(encl_text, true))['$include?'](";&"))) {
                    if ($truthy(term['$include?'](" &gt;&gt; "))) {
                      
                      $b = term.$partition(" &gt;&gt; "), $a = $to_ary($b), (term = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (see = ($a[2] == null ? nil : $a[2]));
                      attrs = $hash2(["see"], {"see": see});
                    } else if ($truthy(term['$include?'](" &amp;&gt; "))) {
                      
                      $b = term.$split(" &amp;&gt; "), $a = $to_ary($b), (term = ($a[0] == null ? nil : $a[0])), (see_also = $slice($a, 1));
                      attrs = $hash2(["see-also"], {"see-also": see_also});
                    }
                  }                  subbed_term = $$('Inline').$new(self, "indexterm", term, $hash2(["attributes", "type"], {"attributes": attrs, "type": "visible"})).$convert();
                } else {
                  
                  attrs = $hash2([], {});
                  if ($truthy((terms = self.$normalize_text(encl_text, true))['$include?'](";&"))) {
                    if ($truthy(terms['$include?'](" &gt;&gt; "))) {
                      
                      $b = terms.$partition(" &gt;&gt; "), $a = $to_ary($b), (terms = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (see = ($a[2] == null ? nil : $a[2]));
                      attrs['$[]=']("see", see);
                    } else if ($truthy(terms['$include?'](" &amp;&gt; "))) {
                      
                      $b = terms.$split(" &amp;&gt; "), $a = $to_ary($b), (terms = ($a[0] == null ? nil : $a[0])), (see_also = $slice($a, 1));
                      attrs['$[]=']("see-also", see_also);
                    }
                  }                  attrs['$[]=']("terms", self.$split_simple_csv(terms));
                  subbed_term = $$('Inline').$new(self, "indexterm", nil, $hash2(["attributes"], {"attributes": attrs})).$convert();
                }                if ($truthy(before)) {
                  return "" + (before) + (subbed_term) + (after)
                } else {
                  return subbed_term
                }            }}, {$$s: self});
        }        if (($truthy(found_colon) && ($truthy(text['$include?']("://"))))) {
          text = $send(text, 'gsub', [$$('InlineLinkRx')], function $$25(){var $a, $b, self = $$25.$$s == null ? this : $$25.$$s, target = nil, rs_idx = nil, prefix = nil, suffix = nil, link_text = nil, attrs = nil, link_opts = nil, new_link_text = nil, bare = nil;

            
            if ($truthy((target = $rb_plus((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), ($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))) ? ($ret_or_1) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](5))))))['$start_with?']($$('RS')))) {
              return $rb_plus((($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(0, (rs_idx = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$length())), (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice($rb_plus(rs_idx, 1), (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length()))
            }            $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)), ""], (prefix = $a[0]), (suffix = $a[1]);
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](4)))) {
              
              if ($eqeq(prefix, "link:")) {
                prefix = "";
              }              if ($truthy((link_text = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4)))['$empty?']())) {
                link_text = nil;
              }            } else {
              
              
              switch (prefix) {
                case "link:":
                case "\"":
                case "'":
                  return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
              }              
              switch ((($a = $gvars['~']) === nil ? nil : $a['$[]'](6))) {
                case ";":
                  
                  if (($truthy(prefix['$start_with?']("&lt;")) && ($truthy(target['$end_with?']("&gt;"))))) {
                    
                    prefix = prefix.$slice(4, prefix.$length());
                    target = target.$slice(0, $rb_minus(target.$length(), 4));
                  } else if ($truthy((target = target.$chop())['$end_with?'](")"))) {
                    
                    target = target.$chop();
                    suffix = ");";
                  } else {
                    suffix = ";";
                  }                  if ($truthy(target['$end_with?']("://"))) {
                    return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
                  }                  break;
                case ":":
                  
                  if ($truthy((target = target.$chop())['$end_with?'](")"))) {
                    
                    target = target.$chop();
                    suffix = "):";
                  } else {
                    suffix = ":";
                  }                  if ($truthy(target['$end_with?']("://"))) {
                    return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
                  }                  break;
              }            }            $a = [nil, $hash2(["type"], {"type": "link"})], (attrs = $a[0]), (link_opts = $a[1]);
            if ($truthy(link_text)) {
              
              if ($truthy(link_text['$include?']($$('R_SB')))) {
                new_link_text = (link_text = link_text.$gsub($$('ESC_R_SB'), $$('R_SB')));
              }              if (($not(doc.$compat_mode()) && ($truthy(link_text['$include?']("="))))) {
                
                $b = self.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), (link_text = ($a[0] == null ? nil : $a[0])), (attrs = ($a[1] == null ? nil : $a[1]));
                new_link_text = link_text;
                link_opts['$[]=']("id", attrs['$[]']("id"));
              }              if ($truthy(link_text['$end_with?']("^"))) {
                
                new_link_text = (link_text = link_text.$chop());
                if ($truthy(attrs)) {
                  if ($truthy(($ret_or_1 = attrs['$[]']("window")))) ; else {
                    attrs['$[]=']("window", "_blank");
                  }
                } else {
                  attrs = $hash2(["window"], {"window": "_blank"});
                }              }              if (($truthy(new_link_text) && ($truthy(new_link_text['$empty?']())))) {
                
                link_text = ($truthy(doc_attrs['$key?']("hide-uri-scheme")) ? (target.$sub($$('UriSniffRx'), "")) : (target));
                bare = true;
              }            } else {
              
              link_text = ($truthy(doc_attrs['$key?']("hide-uri-scheme")) ? (target.$sub($$('UriSniffRx'), "")) : (target));
              bare = true;
            }            if ($truthy(bare)) {
              if ($truthy(attrs)) {
                attrs['$[]=']("role", ($truthy(attrs['$key?']("role")) ? ("bare " + (attrs['$[]']("role"))) : ("bare")));
              } else {
                attrs = $hash2(["role"], {"role": "bare"});
              }
            }            doc.$register("links", ($a = ["target", target], $send(link_opts, '[]=', $a), $a[$a.length - 1]));
            if ($truthy(attrs)) {
              link_opts['$[]=']("attributes", attrs);
            }            return "" + (prefix) + ($$('Inline').$new(self, "anchor", link_text, link_opts).$convert()) + (suffix);}, {$$s: self});
        }        if (($truthy(found_macroish) && (($truthy(text['$include?']("link:")) || ($truthy(text['$include?']("ilto:"))))))) {
          text = $send(text, 'gsub', [$$('InlineLinkMacroRx')], function $$26(){var $a, $b, self = $$26.$$s == null ? this : $$26.$$s, mailto = nil, target = nil, mailto_text = nil, attrs = nil, link_opts = nil, link_text = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
            } else if ($truthy((mailto = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))) {
              target = $rb_plus("mailto:", (mailto_text = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))));
            } else {
              target = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
            }            $a = [nil, $hash2(["type"], {"type": "link"})], (attrs = $a[0]), (link_opts = $a[1]);
            if (!$truthy((link_text = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))['$empty?']())) {
              
              if ($truthy(link_text['$include?']($$('R_SB')))) {
                link_text = link_text.$gsub($$('ESC_R_SB'), $$('R_SB'));
              }              if ($truthy(mailto)) {
                if (($not(doc.$compat_mode()) && ($truthy(link_text['$include?'](","))))) {
                  
                  $b = self.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), (link_text = ($a[0] == null ? nil : $a[0])), (attrs = ($a[1] == null ? nil : $a[1]));
                  link_opts['$[]=']("id", attrs['$[]']("id"));
                  if ($truthy(attrs['$key?'](2))) {
                    if ($truthy(attrs['$key?'](3))) {
                      target = "" + (target) + "?subject=" + ($$('Helpers').$encode_uri_component(attrs['$[]'](2))) + "&amp;body=" + ($$('Helpers').$encode_uri_component(attrs['$[]'](3)));
                    } else {
                      target = "" + (target) + "?subject=" + ($$('Helpers').$encode_uri_component(attrs['$[]'](2)));
                    }
                  }                }
              } else if (($not(doc.$compat_mode()) && ($truthy(link_text['$include?']("="))))) {
                
                $b = self.$extract_attributes_from_text(link_text, ""), $a = $to_ary($b), (link_text = ($a[0] == null ? nil : $a[0])), (attrs = ($a[1] == null ? nil : $a[1]));
                link_opts['$[]=']("id", attrs['$[]']("id"));
              }              if ($truthy(link_text['$end_with?']("^"))) {
                
                link_text = link_text.$chop();
                if ($truthy(attrs)) {
                  if ($truthy(($ret_or_1 = attrs['$[]']("window")))) ; else {
                    attrs['$[]=']("window", "_blank");
                  }
                } else {
                  attrs = $hash2(["window"], {"window": "_blank"});
                }              }            }            if ($truthy(link_text['$empty?']())) {
              if ($truthy(mailto)) {
                link_text = mailto_text;
              } else {
                
                if ($truthy(doc_attrs['$key?']("hide-uri-scheme"))) {
                  if ($truthy((link_text = target.$sub($$('UriSniffRx'), ""))['$empty?']())) {
                    link_text = target;
                  }
                } else {
                  link_text = target;
                }                if ($truthy(attrs)) {
                  attrs['$[]=']("role", ($truthy(attrs['$key?']("role")) ? ("bare " + (attrs['$[]']("role"))) : ("bare")));
                } else {
                  attrs = $hash2(["role"], {"role": "bare"});
                }              }
            }            doc.$register("links", ($a = ["target", target], $send(link_opts, '[]=', $a), $a[$a.length - 1]));
            if ($truthy(attrs)) {
              link_opts['$[]=']("attributes", attrs);
            }            return $$('Inline').$new(self, "anchor", link_text, link_opts).$convert();}, {$$s: self});
        }        if ($truthy(text['$include?']("@"))) {
          text = $send(text, 'gsub', [$$('InlineEmailRx')], function $$27(){var $a, self = $$27.$$s == null ? this : $$27.$$s, target = nil, address = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
              return ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), $$('RS')) ? ((($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))))
            }            target = $rb_plus("mailto:", (address = (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))));
            doc.$register("links", target);
            return $$('Inline').$new(self, "anchor", address, $hash2(["type", "target"], {"type": "link", "target": target})).$convert();}, {$$s: self});
        }        if ((($truthy(found_square_bracket) && ($eqeq(self.context, "list_item"))) && ($eqeq(self.parent.$style(), "bibliography")))) {
          text = $send(text, 'sub', [$$('InlineBiblioAnchorRx')], function $$28(){var $a, self = $$28.$$s == null ? this : $$28.$$s;

            return $$('Inline').$new(self, "anchor", (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), $hash2(["type", "id"], {"type": "bibref", "id": (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))})).$convert()}, {$$s: self});
        }        if ((($truthy(found_square_bracket) && ($truthy(text['$include?']("[[")))) || (($truthy(found_macroish) && ($truthy(text['$include?']("or:"))))))) {
          text = $send(text, 'gsub', [$$('InlineAnchorRx')], function $$29(){var $a, self = $$29.$$s == null ? this : $$29.$$s, id = nil, reftext = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
            }            if ($truthy((id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {
              reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
            } else {
              
              id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4));
              if (($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)))) && ($truthy(reftext['$include?']($$('R_SB')))))) {
                reftext = reftext.$gsub($$('ESC_R_SB'), $$('R_SB'));
              }            }            return $$('Inline').$new(self, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id})).$convert();}, {$$s: self});
        }        if ((($truthy(text['$include?']("&")) && ($truthy(text['$include?'](";&l")))) || (($truthy(found_macroish) && ($truthy(text['$include?']("xref:"))))))) {
          text = $send(text, 'gsub', [$$('InlineXrefMacroRx')], function $$30(){var $a, $b, self = $$30.$$s == null ? this : $$30.$$s, attrs = nil, refid = nil, link_text = nil, macro = nil, fragment = nil, hash_idx = nil, fragment_len = nil, path = nil, src2src = nil, target = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
            }            attrs = $hash2([], {});
            if ($truthy((refid = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))) {
              if ($truthy(refid['$include?'](","))) {
                
                $b = refid.$partition(","), $a = $to_ary($b), (refid = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (link_text = ($a[2] == null ? nil : $a[2]));
                if ($truthy((link_text = link_text.$lstrip())['$empty?']())) {
                  link_text = nil;
                }              }
            } else {
              
              macro = true;
              refid = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
              if ($truthy((link_text = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3))))) {
                
                if ($truthy(link_text['$include?']($$('R_SB')))) {
                  link_text = link_text.$gsub($$('ESC_R_SB'), $$('R_SB'));
                }                if (($not(doc.$compat_mode()) && ($truthy(link_text['$include?']("="))))) {
                  $b = self.$extract_attributes_from_text(link_text), $a = $to_ary($b), (link_text = ($a[0] == null ? nil : $a[0])), (attrs = ($a[1] == null ? nil : $a[1]));
                }              }            }            if ($truthy(doc.$compat_mode())) {
              fragment = refid;
            } else if (($truthy((hash_idx = refid.$index("#"))) && ($neqeq(refid['$[]']($rb_minus(hash_idx, 1)), "&")))) {
              if ($truthy($rb_gt(hash_idx, 0))) {
                
                if ($truthy($rb_gt((fragment_len = $rb_minus($rb_minus(refid.$length(), 1), hash_idx)), 0))) {
                  $a = [refid.$slice(0, hash_idx), refid.$slice($rb_plus(hash_idx, 1), fragment_len)], (path = $a[0]), (fragment = $a[1]);
                } else {
                  path = refid.$chop();
                }                if ($truthy(macro)) {
                  if ($truthy(path['$end_with?'](".adoc"))) {
                    src2src = (path = path.$slice(0, $rb_minus(path.$length(), 5)));
                  } else if ($not($$('Helpers')['$extname?'](path))) {
                    src2src = path;
                  }
                } else if ($truthy($send(path, 'end_with?', $to_a($$('ASCIIDOC_EXTENSIONS').$keys())))) {
                  src2src = (path = path.$slice(0, path.$rindex(".")));
                } else {
                  src2src = path;
                }              } else {
                $a = [refid, refid.$slice(1, refid.$length())], (target = $a[0]), (fragment = $a[1]);
              }
            } else if ($truthy(macro)) {
              if ($truthy(refid['$end_with?'](".adoc"))) {
                src2src = (path = refid.$slice(0, $rb_minus(refid.$length(), 5)));
              } else if ($truthy($$('Helpers')['$extname?'](refid))) {
                path = refid;
              } else {
                fragment = refid;
              }
            } else {
              fragment = refid;
            }            if ($truthy(target)) {
              
              refid = fragment;
              if (($truthy(self.$logger()['$info?']()) && ($not(doc.$catalog()['$[]']("refs")['$[]'](refid))))) {
                self.$logger().$info("possible invalid reference: " + (refid));
              }            } else if ($truthy(path)) {
              if (($truthy(src2src) && (($eqeq(doc.$attributes()['$[]']("docname"), path) || ($truthy(doc.$catalog()['$[]']("includes")['$[]'](path))))))) {
                if ($truthy(fragment)) {
                  
                  $a = [fragment, nil, "#" + (fragment)], (refid = $a[0]), (path = $a[1]), (target = $a[2]);
                  if (($truthy(self.$logger()['$info?']()) && ($not(doc.$catalog()['$[]']("refs")['$[]'](refid))))) {
                    self.$logger().$info("possible invalid reference: " + (refid));
                  }                } else {
                  $a = [nil, nil, "#"], (refid = $a[0]), (path = $a[1]), (target = $a[2]);
                }
              } else {
                
                $a = [path, "" + (($truthy(($ret_or_1 = doc.$attributes()['$[]']("relfileprefix"))) ? ($ret_or_1) : (""))) + (path) + (($truthy(src2src) ? (doc.$attributes().$fetch("relfilesuffix", doc.$outfilesuffix())) : ("")))], (refid = $a[0]), (path = $a[1]);
                if ($truthy(fragment)) {
                  $a = ["" + (refid) + "#" + (fragment), "" + (path) + "#" + (fragment)], (refid = $a[0]), (target = $a[1]);
                } else {
                  target = path;
                }              }
            } else if (($truthy(doc.$compat_mode()) || ($not($$('Compliance').$natural_xrefs())))) {
              
              $a = [fragment, "#" + (fragment)], (refid = $a[0]), (target = $a[1]);
              if (($truthy(self.$logger()['$info?']()) && ($not(doc.$catalog()['$[]']("refs")['$[]'](refid))))) {
                self.$logger().$info("possible invalid reference: " + (refid));
              }            } else if ($truthy(doc.$catalog()['$[]']("refs")['$[]'](fragment))) {
              $a = [fragment, "#" + (fragment)], (refid = $a[0]), (target = $a[1]);
            } else if ((($truthy(fragment['$include?'](" ")) || ($neqeq(fragment.$downcase(), fragment))) && ($truthy((refid = doc.$resolve_id(fragment)))))) {
              $a = [refid, "#" + (refid)], (fragment = $a[0]), (target = $a[1]);
            } else {
              
              $a = [fragment, "#" + (fragment)], (refid = $a[0]), (target = $a[1]);
              if ($truthy(self.$logger()['$info?']())) {
                self.$logger().$info("possible invalid reference: " + (refid));
              }            }            attrs['$[]=']("path", path);
            attrs['$[]=']("fragment", fragment);
            attrs['$[]=']("refid", refid);
            return $$('Inline').$new(self, "anchor", link_text, $hash2(["type", "target", "attributes"], {"type": "xref", "target": target, "attributes": attrs})).$convert();}, {$$s: self});
        }        if (($truthy(found_macroish) && ($truthy(text['$include?']("tnote"))))) {
          text = $send(text, 'gsub', [$$('InlineFootnoteMacroRx')], function $$31(){var $a, $b, $c, self = $$31.$$s == null ? this : $$31.$$s, id = nil, content = nil, footnote = nil, index = nil, type = nil, target = nil;

            
            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('RS')))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
            }            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
              if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))) {
                
                $b = (($c = $gvars['~']) === nil ? nil : $c['$[]'](3)).$split(",", 2), $a = $to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (content = ($a[1] == null ? nil : $a[1]));
                if (!$truthy(doc.$compat_mode())) {
                  self.$logger().$warn("found deprecated footnoteref macro: " + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))) + "; use footnote macro with target instead");
                }              } else {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
              }
            } else {
              
              id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
              content = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
            }            if ($truthy(id)) {
              if ($truthy((footnote = $send(doc.$footnotes(), 'find', [], function $$32(candidate){
                
                if (candidate == null) candidate = nil;
                return candidate.$id()['$=='](id);})))) {
                
                $a = [footnote.$index(), footnote.$text()], (index = $a[0]), (content = $a[1]);
                $a = ["xref", id, nil], (type = $a[0]), (target = $a[1]), (id = $a[2]);
              } else if ($truthy(content)) {
                
                content = self.$restore_passthroughs(self.$normalize_text(content, true, true));
                index = doc.$counter("footnote-number");
                doc.$register("footnotes", $$$($$('Document'), 'Footnote').$new(index, id, content));
                $a = ["ref", nil], (type = $a[0]), (target = $a[1]);
              } else {
                
                self.$logger().$warn("invalid footnote reference: " + (id));
                $a = ["xref", id, id, nil], (type = $a[0]), (target = $a[1]), (content = $a[2]), (id = $a[3]);
              }
            } else if ($truthy(content)) {
              
              content = self.$restore_passthroughs(self.$normalize_text(content, true, true));
              index = doc.$counter("footnote-number");
              doc.$register("footnotes", $$$($$('Document'), 'Footnote').$new(index, id, content));
              type = (target = nil);
            } else {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))
            }            return $$('Inline').$new(self, "footnote", content, $hash2(["attributes", "id", "target", "type"], {"attributes": $hash2(["index"], {"index": index}), "id": id, "target": target, "type": type})).$convert();}, {$$s: self});
        }        return text;
      });
      
      $def(self, '$sub_post_replacements', function $$sub_post_replacements(text) {
        var self = this, lines = nil, last = nil;
        if (self.document == null) self.document = nil;
        if (self.attributes == null) self.attributes = nil;

        if (($truthy(self.attributes['$[]']("hardbreaks-option")) || ($truthy(self.document.$attributes()['$[]']("hardbreaks-option"))))) {
          
          lines = text.$split($$('LF'), -1);
          if ($truthy($rb_lt(lines.$size(), 2))) {
            return text
          }          last = lines.$pop();
          return $send(lines, 'map', [], function $$33(line){var self = $$33.$$s == null ? this : $$33.$$s;

            
            if (line == null) line = nil;
            return $$('Inline').$new(self, "break", ($truthy(line['$end_with?']($$('HARD_LINE_BREAK'))) ? (line.$slice(0, $rb_minus(line.$length(), 2))) : (line)), $hash2(["type"], {"type": "line"})).$convert();}, {$$s: self})['$<<'](last).$join($$('LF'));
        } else if (($truthy(text['$include?']($$('PLUS'))) && ($truthy(text['$include?']($$('HARD_LINE_BREAK')))))) {
          return $send(text, 'gsub', [$$('HardLineBreakRx')], function $$34(){var $a, self = $$34.$$s == null ? this : $$34.$$s;

            return $$('Inline').$new(self, "break", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), $hash2(["type"], {"type": "line"})).$convert()}, {$$s: self})
        } else {
          return text
        }
      });
      
      $def(self, '$sub_source', function $$sub_source(source, process_callouts) {
        var self = this;

        if ($truthy(process_callouts)) {
          return self.$sub_callouts(self.$sub_specialchars(source))
        } else {
          
          return self.$sub_specialchars(source);
        }
      });
      
      $def(self, '$sub_callouts', function $$sub_callouts(text) {
        var self = this, callout_rx = nil, autonum = nil;

        
        callout_rx = ($truthy(self['$attr?']("line-comment")) ? ($$('CalloutSourceRxMap')['$[]'](self.$attr("line-comment"))) : ($$('CalloutSourceRx')));
        autonum = 0;
        return $send(text, 'gsub', [callout_rx], function $$35(){var $a, self = $$35.$$s == null ? this : $$35.$$s, $ret_or_1 = nil;
          if (self.document == null) self.document = nil;

          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) {
            return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$sub($$('RS'), "")
          } else {
            return $$('Inline').$new(self, "callout", ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), ".") ? ((autonum = $rb_plus(autonum, 1)).$to_s()) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](4)))), $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": ($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) ? ($ret_or_1) : (($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), "--") ? (["<!--", "-->"]) : (nil))))})})).$convert()
          }}, {$$s: self});
      });
      
      $def(self, '$highlight_source', function $$highlight_source(source, process_callouts) {
        var $a, $b, self = this, syntax_hl = nil, callout_marks = nil, doc_attrs = nil, syntax_hl_name = nil, start_line_number = nil, linenums_mode = nil, $ret_or_1 = nil, highlight_lines = nil, highlighted = nil, source_offset = nil;
        if (self.document == null) self.document = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        if (!($truthy((syntax_hl = self.document.$syntax_highlighter())) && ($truthy(syntax_hl['$highlight?']())))) {
          return self.$sub_source(source, process_callouts)
        }        if ($truthy(process_callouts)) {
          $b = self.$extract_callouts(source), $a = $to_ary($b), (source = ($a[0] == null ? nil : $a[0])), (callout_marks = ($a[1] == null ? nil : $a[1]));
        }        doc_attrs = self.document.$attributes();
        syntax_hl_name = syntax_hl.$name();
        if (($truthy((linenums_mode = ($truthy(self['$attr?']("linenums")) ? (($truthy(($ret_or_1 = doc_attrs['$[]']("" + (syntax_hl_name) + "-linenums-mode"))) ? ($ret_or_1) : ("table")).$to_sym()) : (nil)))) && ($truthy($rb_lt((start_line_number = self.$attr("start", 1).$to_i()), 1))))) {
          start_line_number = 1;
        }        if ($truthy(self['$attr?']("highlight"))) {
          highlight_lines = self.$resolve_lines_to_highlight(source, self.$attr("highlight"), start_line_number);
        }        $b = syntax_hl.$highlight(self, source, self.$attr("language"), $hash2(["callouts", "css_mode", "highlight_lines", "number_lines", "start_line_number", "style"], {"callouts": callout_marks, "css_mode": ($truthy(($ret_or_1 = doc_attrs['$[]']("" + (syntax_hl_name) + "-css"))) ? ($ret_or_1) : ("class")).$to_sym(), "highlight_lines": highlight_lines, "number_lines": linenums_mode, "start_line_number": start_line_number, "style": doc_attrs['$[]']("" + (syntax_hl_name) + "-style")})), $a = $to_ary($b), (highlighted = ($a[0] == null ? nil : $a[0])), (source_offset = ($a[1] == null ? nil : $a[1]));
        if (!$truthy(self.passthroughs['$empty?']())) {
          highlighted = highlighted.$gsub($$('HighlightedPassSlotRx'), "" + ($$('PASS_START')) + "\\1" + ($$('PASS_END')));
        }        if ($truthy(callout_marks['$nil_or_empty?']())) {
          return highlighted
        } else {
          
          return self.$restore_callouts(highlighted, callout_marks, source_offset);
        }      });
      
      $def(self, '$resolve_lines_to_highlight', function $$resolve_lines_to_highlight(source, spec, start) {
        var lines = nil, shift = nil;

        
        if (start == null) start = nil;
        lines = [];
        if ($truthy(spec['$include?'](" "))) {
          spec = spec.$delete(" ");
        }        $send(($truthy(spec['$include?'](",")) ? (spec.$split(",")) : (spec.$split(";"))), 'map', [], function $$36(entry){var $a, $b, negate = nil, delim = nil, from = nil, to = nil, line = nil;

          
          if (entry == null) entry = nil;
          if ($truthy(entry['$start_with?']("!"))) {
            
            entry = entry.$slice(1, entry.$length());
            negate = true;
          }          if ($truthy((delim = ($truthy(entry['$include?']("..")) ? ("..") : (($truthy(entry['$include?']("-")) ? ("-") : (nil))))))) {
            
            $b = entry.$partition(delim), $a = $to_ary($b), (from = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (to = ($a[2] == null ? nil : $a[2]));
            if (($truthy(to['$empty?']()) || ($truthy($rb_lt((to = to.$to_i()), 0))))) {
              to = $rb_plus(source.$count($$('LF')), 1);
            }            if ($truthy(negate)) {
              return (lines = $rb_minus(lines, Opal.Range.$new(from.$to_i(), to, false).$to_a()))
            } else {
              return (lines = lines['$|'](Opal.Range.$new(from.$to_i(), to, false).$to_a()))
            }          } else if ($truthy(negate)) {
            return lines.$delete(entry.$to_i())
          } else if ($not(lines['$include?']((line = entry.$to_i())))) {
            return lines['$<<'](line)
          } else {
            return nil
          }});
        if (!$eqeq((shift = ($truthy(start) ? ($rb_minus(start, 1)) : (0))), 0)) {
          lines = $send(lines, 'map', [], function $$37(it){
            
            if (it == null) it = nil;
            return $rb_minus(it, shift);});
        }        return lines.$sort();
      }, -3);
      
      $def(self, '$extract_passthroughs', function $$extract_passthroughs(text) {
        var $a, $b, self = this, compat_mode = nil, passthrus = nil, pass_inline_char1 = nil, pass_inline_char2 = nil, pass_inline_rx = nil;
        if (self.document == null) self.document = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        compat_mode = self.document.$compat_mode();
        passthrus = self.passthroughs;
        if ((($truthy(text['$include?']("++")) || ($truthy(text['$include?']("$$")))) || ($truthy(text['$include?']("ss:"))))) {
          text = $send(text, 'gsub', [$$('InlinePassMacroRx')], function $$38(){var $a, self = $$38.$$s == null ? this : $$38.$$s, boundary = nil, attrlist = nil, escape_count = nil, preceding = nil, old_behavior = nil, attributes = nil, subs = nil, passthru_key = nil, $ret_or_1 = nil;

            
            if ($truthy((boundary = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4))))) {
              
              if (($truthy(compat_mode) && ($eqeq(boundary, "++")))) {
                return "" + (($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))) ? ("" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + "[" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2))) + "]" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))) : ("" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)))))) + "++" + (self.$extract_passthroughs((($a = $gvars['~']) === nil ? nil : $a['$[]'](5)))) + "++"
              }              if ($truthy((attrlist = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {
                if ($truthy($rb_gt((escape_count = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$length()), 0))) {
                  return "" + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) + "[" + (attrlist) + "]" + ($rb_times($$('RS'), $rb_minus(escape_count, 1))) + (boundary) + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](5))) + (boundary)
                } else if ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), $$('RS'))) {
                  preceding = "[" + (attrlist) + "]";
                } else if ($eqeq(boundary, "++")) {
                  if ($eqeq(attrlist, "x-")) {
                    
                    old_behavior = true;
                    attributes = $hash2([], {});
                  } else if ($truthy(attrlist['$end_with?'](" x-"))) {
                    
                    old_behavior = true;
                    attributes = self.$parse_quoted_text_attributes(attrlist.$slice(0, $rb_minus(attrlist.$length(), 3)));
                  } else {
                    attributes = self.$parse_quoted_text_attributes(attrlist);
                  }
                } else {
                  attributes = self.$parse_quoted_text_attributes(attrlist);
                }
              } else if ($truthy($rb_gt((escape_count = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)).$length()), 0))) {
                return "" + ($rb_times($$('RS'), $rb_minus(escape_count, 1))) + (boundary) + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](5))) + (boundary)
              }              subs = ($eqeq(boundary, "+++") ? ([]) : ($$('BASIC_SUBS')));
              if ($truthy(attributes)) {
                if ($truthy(old_behavior)) {
                  passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "type", "attributes"], {"text": (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)), "subs": $$('NORMAL_SUBS'), "type": "monospaced", "attributes": attributes}));
                } else {
                  passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "type", "attributes"], {"text": (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)), "subs": subs, "type": "unquoted", "attributes": attributes}));
                }
              } else {
                passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": (($a = $gvars['~']) === nil ? nil : $a['$[]'](5)), "subs": subs}));
              }            } else {
              
              if ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](6)), $$('RS'))) {
                return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$slice(1, (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length())
              }              if ($truthy((subs = (($a = $gvars['~']) === nil ? nil : $a['$[]'](7))))) {
                passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": self.$normalize_text((($a = $gvars['~']) === nil ? nil : $a['$[]'](8)), nil, true), "subs": self.$resolve_pass_subs(subs)}));
              } else {
                passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text"], {"text": self.$normalize_text((($a = $gvars['~']) === nil ? nil : $a['$[]'](8)), nil, true)}));
              }            }            return "" + (($truthy(($ret_or_1 = preceding)) ? ($ret_or_1) : (""))) + ($$('PASS_START')) + (passthru_key) + ($$('PASS_END'));}, {$$s: self});
        }        $b = $$('InlinePassRx')['$[]'](compat_mode), $a = $to_ary($b), (pass_inline_char1 = ($a[0] == null ? nil : $a[0])), (pass_inline_char2 = ($a[1] == null ? nil : $a[1])), (pass_inline_rx = ($a[2] == null ? nil : $a[2]));
        if (($truthy(text['$include?'](pass_inline_char1)) || (($truthy(pass_inline_char2) && ($truthy(text['$include?'](pass_inline_char2))))))) {
          text = $send(text, 'gsub', [pass_inline_rx], function $$39(){var $c, self = $$39.$$s == null ? this : $$39.$$s, preceding = nil, attrlist = nil, $ret_or_1 = nil, escaped = nil, quoted_text = nil, format_mark = nil, content = nil, old_behavior = nil, old_behavior_forced = nil, attributes = nil, passthru_key = nil, subs = nil;

            
            preceding = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1));
            attrlist = ($truthy(($ret_or_1 = (($c = $gvars['~']) === nil ? nil : $c['$[]'](4)))) ? ($ret_or_1) : ((($c = $gvars['~']) === nil ? nil : $c['$[]'](3))));
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](5)))) {
              escaped = true;
            }            quoted_text = (($c = $gvars['~']) === nil ? nil : $c['$[]'](6));
            format_mark = (($c = $gvars['~']) === nil ? nil : $c['$[]'](7));
            content = (($c = $gvars['~']) === nil ? nil : $c['$[]'](8));
            if ($truthy(compat_mode)) {
              old_behavior = true;
            } else if (($truthy(attrlist) && (($eqeq(attrlist, "x-") || ($truthy(attrlist['$end_with?'](" x-"))))))) {
              old_behavior = (old_behavior_forced = true);
            }            if ($truthy(attrlist)) {
              if ($truthy(escaped)) {
                return "" + (preceding) + "[" + (attrlist) + "]" + (quoted_text.$slice(1, quoted_text.$length()))
              } else if ($eqeq(preceding, $$('RS'))) {
                
                if (($truthy(old_behavior_forced) && ($eqeq(format_mark, "`")))) {
                  return "" + (preceding) + "[" + (attrlist) + "]" + (quoted_text)
                }                preceding = "[" + (attrlist) + "]";
              } else if ($truthy(old_behavior_forced)) {
                attributes = ($eqeq(attrlist, "x-") ? ($hash2([], {})) : (self.$parse_quoted_text_attributes(attrlist.$slice(0, $rb_minus(attrlist.$length(), 3)))));
              } else {
                attributes = self.$parse_quoted_text_attributes(attrlist);
              }
            } else if ($truthy(escaped)) {
              return "" + (preceding) + (quoted_text.$slice(1, quoted_text.$length()))
            } else if (($truthy(compat_mode) && ($eqeq(preceding, $$('RS'))))) {
              return quoted_text
            }            if ($truthy(compat_mode)) {
              passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": $$('BASIC_SUBS'), "attributes": attributes, "type": "monospaced"}));
            } else if ($truthy(attributes)) {
              if ($truthy(old_behavior)) {
                
                subs = ($eqeq(format_mark, "`") ? ($$('BASIC_SUBS')) : ($$('NORMAL_SUBS')));
                passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": subs, "attributes": attributes, "type": "monospaced"}));
              } else {
                passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "attributes", "type"], {"text": content, "subs": $$('BASIC_SUBS'), "attributes": attributes, "type": "unquoted"}));
              }
            } else {
              passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs"], {"text": content, "subs": $$('BASIC_SUBS')}));
            }            return "" + (preceding) + ($$('PASS_START')) + (passthru_key) + ($$('PASS_END'));}, {$$s: self});
        }        if (($truthy(text['$include?'](":")) && (($truthy(text['$include?']("stem:")) || ($truthy(text['$include?']("math:"))))))) {
          text = $send(text, 'gsub', [$$('InlineStemMacroRx')], function $$40(){var $c, self = $$40.$$s == null ? this : $$40.$$s, type = nil, subs = nil, content = nil, passthru_key = nil;
            if (self.document == null) self.document = nil;

            
            if ($truthy((($c = $gvars['~']) === nil ? nil : $c['$[]'](0))['$start_with?']($$('RS')))) {
              return (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$slice(1, (($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$length())
            }            if ($eqeq((type = (($c = $gvars['~']) === nil ? nil : $c['$[]'](1)).$to_sym()), "stem")) {
              type = $$('STEM_TYPE_ALIASES')['$[]'](self.document.$attributes()['$[]']("stem")).$to_sym();
            }            subs = (($c = $gvars['~']) === nil ? nil : $c['$[]'](2));
            content = self.$normalize_text((($c = $gvars['~']) === nil ? nil : $c['$[]'](3)), nil, true);
            if ((($eqeq(type, "latexmath") && ($truthy(content['$start_with?']("$")))) && ($truthy(content['$end_with?']("$"))))) {
              content = content.$slice(1, $rb_minus(content.$length(), 2));
            }            subs = ($truthy(subs) ? (self.$resolve_pass_subs(subs)) : (($truthy(self.document['$basebackend?']("html")) ? ($$('BASIC_SUBS')) : (nil))));
            passthrus['$[]=']((passthru_key = passthrus.$size()), $hash2(["text", "subs", "type"], {"text": content, "subs": subs, "type": type}));
            return "" + ($$('PASS_START')) + (passthru_key) + ($$('PASS_END'));}, {$$s: self});
        }        return text;
      });
      
      $def(self, '$restore_passthroughs', function $$restore_passthroughs(text) {
        var self = this, passthrus = nil;
        if (self.passthroughs == null) self.passthroughs = nil;

        
        passthrus = self.passthroughs;
        return $send(text, 'gsub', [$$('PassSlotRx')], function $$41(){var $a, self = $$41.$$s == null ? this : $$41.$$s, pass = nil, subbed_text = nil, type = nil, attributes = nil, id = nil;

          if ($truthy((pass = passthrus['$[]']((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$to_i())))) {
            
            subbed_text = self.$apply_subs(pass['$[]']("text"), pass['$[]']("subs"));
            if ($truthy((type = pass['$[]']("type")))) {
              
              if ($truthy((attributes = pass['$[]']("attributes")))) {
                id = attributes['$[]']("id");
              }              subbed_text = $$('Inline').$new(self, "quoted", subbed_text, $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert();
            }            if ($truthy(subbed_text['$include?']($$('PASS_START')))) {
              return self.$restore_passthroughs(subbed_text)
            } else {
              return subbed_text
            }          } else {
            
            self.$logger().$error("unresolved passthrough detected: " + (text));
            return "??pass??";
          }}, {$$s: self});
      });
      
      $def(self, '$resolve_subs', function $$resolve_subs(subs, type, defaults, subject) {
        var self = this, candidates = nil, modifiers_present = nil, resolved = nil, invalid = nil;

        
        if (type == null) type = "block";
        if (defaults == null) defaults = nil;
        if (subject == null) subject = nil;
        if ($truthy(subs['$nil_or_empty?']())) {
          return nil
        }        candidates = nil;
        if ($truthy(subs['$include?'](" "))) {
          subs = subs.$delete(" ");
        }        modifiers_present = $$('SubModifierSniffRx')['$match?'](subs);
        $send(subs.$split(","), 'each', [], function $$42(key){var modifier_operation = nil, first = nil, resolved_keys = nil, resolved_key = nil, candidate = nil, $ret_or_1 = nil;

          
          if (key == null) key = nil;
          modifier_operation = nil;
          if ($truthy(modifiers_present)) {
            if ($eqeq((first = key.$chr()), "+")) {
              
              modifier_operation = "append";
              key = key.$slice(1, key.$length());
            } else if ($eqeq(first, "-")) {
              
              modifier_operation = "remove";
              key = key.$slice(1, key.$length());
            } else if ($truthy(key['$end_with?']("+"))) {
              
              modifier_operation = "prepend";
              key = key.$chop();
            }
          }          key = key.$to_sym();
          if (($eqeq(type, "inline") && (($eqeq(key, "verbatim") || ($eqeq(key, "v")))))) {
            resolved_keys = $$('BASIC_SUBS');
          } else if ($truthy($$('SUB_GROUPS')['$key?'](key))) {
            resolved_keys = $$('SUB_GROUPS')['$[]'](key);
          } else if ((($eqeq(type, "inline") && ($eqeq(key.$length(), 1))) && ($truthy($$('SUB_HINTS')['$key?'](key))))) {
            
            resolved_key = $$('SUB_HINTS')['$[]'](key);
            if ($truthy((candidate = $$('SUB_GROUPS')['$[]'](resolved_key)))) {
              resolved_keys = candidate;
            } else {
              resolved_keys = [resolved_key];
            }          } else {
            resolved_keys = [key];
          }          if ($truthy(modifier_operation)) {
            
            candidates = ($truthy(($ret_or_1 = candidates)) ? ($ret_or_1) : (($truthy(defaults) ? (defaults.$drop(0)) : ([]))));
            
            switch (modifier_operation) {
              case "append":
                return (candidates = $rb_plus(candidates, resolved_keys))
              case "prepend":
                return (candidates = $rb_plus(resolved_keys, candidates))
              case "remove":
                return (candidates = $rb_minus(candidates, resolved_keys))
              default:
                return nil
            }          } else {
            
            candidates = ($truthy(($ret_or_1 = candidates)) ? ($ret_or_1) : ([]));
            return (candidates = $rb_plus(candidates, resolved_keys));
          }});
        if (!$truthy(candidates)) {
          return nil
        }        resolved = candidates['$&']($$('SUB_OPTIONS')['$[]'](type));
        if (!$truthy($rb_minus(candidates, resolved)['$empty?']())) {
          
          invalid = $rb_minus(candidates, resolved);
          self.$logger().$warn("invalid substitution type" + (($truthy($rb_gt(invalid.$size(), 1)) ? ("s") : (""))) + (($truthy(subject) ? (" for ") : (""))) + (subject) + ": " + (invalid.$join(", ")));
        }        return resolved;
      }, -2);
      
      $def(self, '$resolve_block_subs', function $$resolve_block_subs(subs, defaults, subject) {
        var self = this;

        return self.$resolve_subs(subs, "block", defaults, subject)
      });
      
      $def(self, '$resolve_pass_subs', function $$resolve_pass_subs(subs) {
        var self = this;

        return self.$resolve_subs(subs, "inline", nil, "passthrough macro")
      });
      
      $def(self, '$expand_subs', function $$expand_subs(subs, subject) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, expanded_subs = nil;

        
        if (subject == null) subject = nil;
        if ($eqeqeq($$$('Symbol'), ($ret_or_1 = subs))) {
          if ($eqeq(subs, "none")) {
            return nil
          } else if ($truthy(($ret_or_2 = $$('SUB_GROUPS')['$[]'](subs)))) {
            return $ret_or_2
          } else {
            return [subs]
          }
        } else if ($eqeqeq($$$('Array'), $ret_or_1)) {
          
          expanded_subs = [];
          $send(subs, 'each', [], function $$43(key){var sub_group = nil;

            
            if (key == null) key = nil;
            if ($eqeq(key, "none")) {
              return nil
            } else if ($truthy((sub_group = $$('SUB_GROUPS')['$[]'](key)))) {
              return (expanded_subs = $rb_plus(expanded_subs, sub_group))
            } else {
              return expanded_subs['$<<'](key)
            }});
          if ($truthy(expanded_subs['$empty?']())) {
            return nil
          } else {
            return expanded_subs
          }        } else {
          return self.$resolve_subs(subs, "inline", nil, subject)
        }      }, -2);
      
      $def(self, '$commit_subs', function $$commit_subs() {
        var self = this, default_subs = nil, custom_subs = nil, $ret_or_1 = nil, idx = nil, syntax_hl = nil;
        if (self.default_subs == null) self.default_subs = nil;
        if (self.content_model == null) self.content_model = nil;
        if (self.context == null) self.context = nil;
        if (self.subs == null) self.subs = nil;
        if (self.attributes == null) self.attributes = nil;
        if (self.document == null) self.document = nil;
        if (self.style == null) self.style = nil;

        
        if (!$truthy((default_subs = self.default_subs))) {
          
          switch (self.content_model) {
            case "simple":
              default_subs = $$('NORMAL_SUBS');
              break;
            case "verbatim":
              default_subs = ($eqeq(self.context, "verse") ? ($$('NORMAL_SUBS')) : ($$('VERBATIM_SUBS')));
              break;
            case "raw":
              default_subs = ($eqeq(self.context, "stem") ? ($$('BASIC_SUBS')) : ($$('NO_SUBS')));
              break;
            default:
              return self.subs
          }
        }        if ($truthy((custom_subs = self.attributes['$[]']("subs")))) {
          self.subs = ($truthy(($ret_or_1 = self.$resolve_block_subs(custom_subs, default_subs, self.context))) ? ($ret_or_1) : ([]));
        } else {
          self.subs = default_subs.$drop(0);
        }        if ((((($eqeq(self.context, "listing") && ($eqeq(self.style, "source"))) && ($truthy((syntax_hl = self.document.$syntax_highlighter())))) && ($truthy(syntax_hl['$highlight?']()))) && ($truthy((idx = self.subs.$index("specialcharacters")))))) {
          self.subs['$[]='](idx, "highlight");
        }        return nil;
      });
      
      $def(self, '$parse_attributes', function $$parse_attributes(attrlist, posattrs, opts) {
        var self = this, block = nil, into = nil;
        if (self.document == null) self.document = nil;

        
        if (posattrs == null) posattrs = [];
        if (opts == null) opts = $hash2([], {});
        if ($truthy(($truthy(attrlist) ? (attrlist['$empty?']()) : (true)))) {
          return $hash2([], {})
        }        if ($truthy(opts['$[]']("unescape_input"))) {
          attrlist = self.$normalize_text(attrlist, true, true);
        }        if (($truthy(opts['$[]']("sub_input")) && ($truthy(attrlist['$include?']($$('ATTR_REF_HEAD')))))) {
          attrlist = self.document.$sub_attributes(attrlist);
        }        if ($truthy(opts['$[]']("sub_result"))) {
          block = self;
        }        if ($truthy((into = opts['$[]']("into")))) {
          return $$('AttributeList').$new(attrlist, block).$parse_into(into, posattrs)
        } else {
          return $$('AttributeList').$new(attrlist, block).$parse(posattrs)
        }      }, -2);
      self.$private();
      
      $def(self, '$extract_attributes_from_text', function $$extract_attributes_from_text(text, default_text) {
        var self = this, attrlist = nil, resolved_text = nil, attrs = nil;

        
        if (default_text == null) default_text = nil;
        attrlist = ($truthy(text['$include?']($$('LF'))) ? (text.$tr($$('LF'), " ")) : (text));
        if ($truthy((resolved_text = (attrs = $$('AttributeList').$new(attrlist, self).$parse())['$[]'](1)))) {
          if ($eqeq(resolved_text, attrlist)) {
            return [text, attrs.$clear()]
          } else {
            return [resolved_text, attrs]
          }
        } else {
          return [default_text, attrs]
        }      }, -2);
      
      $def(self, '$extract_callouts', function $$extract_callouts(source) {
        var self = this, callout_marks = nil, autonum = nil, lineno = nil, last_lineno = nil, callout_rx = nil;

        
        callout_marks = $hash2([], {});
        autonum = (lineno = 0);
        last_lineno = nil;
        callout_rx = ($truthy(self['$attr?']("line-comment")) ? ($$('CalloutExtractRxMap')['$[]'](self.$attr("line-comment"))) : ($$('CalloutExtractRx')));
        source = $send(source.$split($$('LF'), -1), 'map', [], function $$44(line){
          
          if (line == null) line = nil;
          lineno = $rb_plus(lineno, 1);
          return $send(line, 'gsub', [callout_rx], function $$45(){var $a, $ret_or_1 = nil;

            if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) {
              return (($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$sub($$('RS'), "")
            } else {
              
              ($truthy(($ret_or_1 = callout_marks['$[]'](lineno))) ? ($ret_or_1) : (($a = [lineno, []], $send(callout_marks, '[]=', $a), $a[$a.length - 1])))['$<<']([($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) ? ($ret_or_1) : (($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), "--") ? (["<!--", "-->"]) : (nil)))), ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), ".") ? ((autonum = $rb_plus(autonum, 1)).$to_s()) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](4))))]);
              last_lineno = lineno;
              return "";
            }});}).$join($$('LF'));
        if ($truthy(last_lineno)) {
          if ($eqeq(last_lineno, lineno)) {
            source = "" + (source) + ($$('LF'));
          }
        } else {
          callout_marks = nil;
        }        return [source, callout_marks];
      });
      
      $def(self, '$restore_callouts', function $$restore_callouts(source, callout_marks, source_offset) {
        var self = this, preamble = nil, lineno = nil;

        
        if (source_offset == null) source_offset = nil;
        if ($truthy(source_offset)) {
          
          preamble = source.$slice(0, source_offset);
          source = source.$slice(source_offset, source.$length());
        } else {
          preamble = "";
        }        lineno = 0;
        return $rb_plus(preamble, $send(source.$split($$('LF'), -1), 'map', [], function $$46(line){var $a, $b, self = $$46.$$s == null ? this : $$46.$$s, conums = nil, guard = nil, numeral = nil;
          if (self.document == null) self.document = nil;

          
          if (line == null) line = nil;
          if ($truthy((conums = callout_marks.$delete((lineno = $rb_plus(lineno, 1)))))) {
            if ($eqeq(conums.$size(), 1)) {
              
              $b = conums['$[]'](0), $a = $to_ary($b), (guard = ($a[0] == null ? nil : $a[0])), (numeral = ($a[1] == null ? nil : $a[1]));
              return "" + (line) + ($$('Inline').$new(self, "callout", numeral, $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": guard})})).$convert());
            } else {
              return "" + (line) + ($send(conums, 'map', [], function $$47(guard_it, numeral_it){var self = $$47.$$s == null ? this : $$47.$$s;
                if (self.document == null) self.document = nil;

                
                if (guard_it == null) guard_it = nil;
                if (numeral_it == null) numeral_it = nil;
                return $$('Inline').$new(self, "callout", numeral_it, $hash2(["id", "attributes"], {"id": self.document.$callouts().$read_next_id(), "attributes": $hash2(["guard"], {"guard": guard_it})})).$convert();}, {$$s: self}).$join(" "))
            }
          } else {
            return line
          }}, {$$s: self}).$join($$('LF')));
      }, -3);
      
      $def(self, '$convert_quoted_text', function $$convert_quoted_text(match, type, scope) {
        var self = this, attrs = nil, unescaped_attrs = nil, attrlist = nil, id = nil, attributes = nil;

        
        if ($truthy(match['$[]'](0)['$start_with?']($$('RS')))) {
          if (($eqeq(scope, "constrained") && ($truthy((attrs = match['$[]'](2)))))) {
            unescaped_attrs = "[" + (attrs) + "]";
          } else {
            return match['$[]'](0).$slice(1, match['$[]'](0).$length())
          }
        }        if ($eqeq(scope, "constrained")) {
          if ($truthy(unescaped_attrs)) {
            return "" + (unescaped_attrs) + ($$('Inline').$new(self, "quoted", match['$[]'](3), $hash2(["type"], {"type": type})).$convert())
          } else {
            
            if ($truthy((attrlist = match['$[]'](2)))) {
              
              id = (attributes = self.$parse_quoted_text_attributes(attrlist))['$[]']("id");
              if ($eqeq(type, "mark")) {
                type = "unquoted";
              }            }            return "" + (match['$[]'](1)) + ($$('Inline').$new(self, "quoted", match['$[]'](3), $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert());
          }
        } else {
          
          if ($truthy((attrlist = match['$[]'](1)))) {
            
            id = (attributes = self.$parse_quoted_text_attributes(attrlist))['$[]']("id");
            if ($eqeq(type, "mark")) {
              type = "unquoted";
            }          }          return $$('Inline').$new(self, "quoted", match['$[]'](2), $hash2(["type", "id", "attributes"], {"type": type, "id": id, "attributes": attributes})).$convert();
        }      });
      
      $def(self, '$do_replacement', function $$do_replacement(m, replacement, restore) {
        var captured = nil;

        if ($truthy((captured = m['$[]'](0))['$include?']($$('RS')))) {
          return captured.$sub($$('RS'), "")
        } else 
        switch (restore) {
          case "none":
            return replacement
          case "bounding":
            return $rb_plus($rb_plus(m['$[]'](1), replacement), m['$[]'](2))
          default:
            return $rb_plus(m['$[]'](1), replacement)
        }
      });
      
      $def(self, '$parse_quoted_text_attributes', function $$parse_quoted_text_attributes(str) {
        var $a, $b, self = this, before = nil, after = nil, attrs = nil, id = nil, roles = nil;

        
        if ($truthy(str['$include?']($$('ATTR_REF_HEAD')))) {
          str = self.$sub_attributes(str);
        }        if ($truthy(str['$include?'](","))) {
          str = str.$slice(0, str.$index(","));
        }        if ($truthy((str = str.$strip())['$empty?']())) {
          return $hash2([], {})
        } else if (($truthy(str['$start_with?'](".", "#")) && ($truthy($$('Compliance').$shorthand_property_syntax())))) {
          
          $b = str.$partition("#"), $a = $to_ary($b), (before = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (after = ($a[2] == null ? nil : $a[2]));
          attrs = $hash2([], {});
          if ($truthy(after['$empty?']())) {
            if ($truthy($rb_gt(before.$length(), 1))) {
              attrs['$[]=']("role", before.$tr(".", " ").$lstrip());
            }
          } else {
            
            $b = after.$partition("."), $a = $to_ary($b), (id = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (roles = ($a[2] == null ? nil : $a[2]));
            if (!$truthy(id['$empty?']())) {
              attrs['$[]=']("id", id);
            }            if ($truthy(roles['$empty?']())) {
              if ($truthy($rb_gt(before.$length(), 1))) {
                attrs['$[]=']("role", before.$tr(".", " ").$lstrip());
              }
            } else if ($truthy($rb_gt(before.$length(), 1))) {
              attrs['$[]=']("role", $rb_plus($rb_plus(before, "."), roles).$tr(".", " ").$lstrip());
            } else {
              attrs['$[]=']("role", roles.$tr(".", " "));
            }          }          return attrs;
        } else {
          return $hash2(["role"], {"role": str})
        }      });
      
      $def(self, '$normalize_text', function $$normalize_text(text, normalize_whitespace, unescape_closing_square_brackets) {
        
        
        if (normalize_whitespace == null) normalize_whitespace = nil;
        if (unescape_closing_square_brackets == null) unescape_closing_square_brackets = nil;
        if (!$truthy(text['$empty?']())) {
          
          if ($truthy(normalize_whitespace)) {
            text = text.$strip().$tr($$('LF'), " ");
          }          if (($truthy(unescape_closing_square_brackets) && ($truthy(text['$include?']($$('R_SB')))))) {
            text = text.$gsub($$('ESC_R_SB'), $$('R_SB'));
          }        }        return text;
      }, -2);
      return $def(self, '$split_simple_csv', function $$split_simple_csv(str) {
        var values = nil, accum = nil, quote_open = nil;

        if ($truthy(str['$empty?']())) {
          return []
        } else if ($truthy(str['$include?']("\""))) {
          
          values = [];
          accum = "";
          quote_open = nil;
          $send(str, 'each_char', [], function $$48(c){
            
            if (c == null) c = nil;
            
            switch (c) {
              case ",":
                if ($truthy(quote_open)) {
                  return (accum = $rb_plus(accum, c))
                } else {
                  
                  values['$<<'](accum.$strip());
                  return (accum = "");
                }
              case "\"":
                return (quote_open = quote_open['$!']())
              default:
                return (accum = $rb_plus(accum, c))
            }});
          return values['$<<'](accum.$strip());
        } else {
          return $send(str.$split(","), 'map', [], function $$49(it){
            
            if (it == null) it = nil;
            return it.$strip();})
        }
      });
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/version"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $nesting = []; Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return $const_set($nesting[0], 'VERSION', "2.0.20")
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/abstract_node"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $truthy = Opal.truthy, $def = Opal.def, $send = Opal.send, $rb_minus = Opal.rb_minus, $eqeqeq = Opal.eqeqeq, $rb_lt = Opal.rb_lt, $not = Opal.not, $to_ary = Opal.to_ary, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,attr_accessor,==,document,to_s,[],merge,raise,converter,attributes,key?,[]=,delete,tap,new,each_key,end_with?,<<,slice,-,length,update,split,include?,===,join,empty?,apply_reftext_subs,attr?,attr,extname?,image_uri,<,safe,normalize_web_path,uriish?,encode_spaces_in_uri,generate_data_uri_from_uri,generate_data_uri,extname,normalize_system_path,readable?,strict_encode64,binread,warn,logger,require_library,!,open_uri,content_type,read,base_dir,root?,path_resolver,system_path,web_path,!=,prepare_source_string,fetch,read_asset');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AbstractNode');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.document = $proto.attributes = $proto.parent = nil;
      
      self.$include($$('Logging'));
      self.$include($$('Substitutors'));
      self.$attr_reader("attributes");
      self.$attr_reader("context");
      self.$attr_reader("document");
      self.$attr_accessor("id");
      self.$attr_reader("node_name");
      self.$attr_reader("parent");
      
      $def(self, '$initialize', function $$initialize(parent, context, opts) {
        var self = this, attrs = nil;

        
        if (opts == null) opts = $hash2([], {});
        if ($eqeq(context, "document")) {
          self.document = self;
        } else if ($truthy(parent)) {
          self.document = (self.parent = parent).$document();
        }        self.node_name = (self.context = context).$to_s();
        self.attributes = ($truthy((attrs = opts['$[]']("attributes"))) ? (attrs.$merge()) : ($hash2([], {})));
        return (self.passthroughs = []);
      }, -3);
      
      $def(self, '$block?', function $AbstractNode_block$ques$1() {
        var self = this;

        return self.$raise($$$('NotImplementedError'))
      });
      
      $def(self, '$inline?', function $AbstractNode_inline$ques$2() {
        var self = this;

        return self.$raise($$$('NotImplementedError'))
      });
      
      $def(self, '$converter', function $$converter() {
        var self = this;

        return self.document.$converter()
      });
      
      $def(self, '$parent=', function $AbstractNode_parent$eq$3(parent) {
        var $a, self = this;

        return $a = [parent, parent.$document()], (self.parent = $a[0]), (self.document = $a[1]), $a
      });
      
      $def(self, '$attr', function $$attr(name, default_value, fallback_name) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil;

        
        if (default_value == null) default_value = nil;
        if (fallback_name == null) fallback_name = nil;
        if ($truthy(($ret_or_1 = self.attributes['$[]'](name.$to_s())))) {
          return $ret_or_1
        } else {
          
          if ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = ($truthy(($ret_or_4 = fallback_name)) ? (self.parent) : ($ret_or_4)))) ? (self.document.$attributes()['$[]'](($eqeq(fallback_name, true) ? (name) : (fallback_name)).$to_s())) : ($ret_or_3))))) {
            return $ret_or_2
          } else {
            return default_value
          }        }      }, -2);
      
      $def(self, '$attr?', function $AbstractNode_attr$ques$4(name, expected_value, fallback_name) {
        var self = this, $ret_or_1 = nil;

        
        if (expected_value == null) expected_value = nil;
        if (fallback_name == null) fallback_name = nil;
        if ($truthy(expected_value)) {
          return expected_value['$=='](($truthy(($ret_or_1 = self.attributes['$[]'](name.$to_s()))) ? ($ret_or_1) : ((($truthy(fallback_name) && ($truthy(self.parent))) ? (self.document.$attributes()['$[]'](($eqeq(fallback_name, true) ? (name) : (fallback_name)).$to_s())) : (nil)))))
        } else if ($truthy(($ret_or_1 = self.attributes['$key?'](name.$to_s())))) {
          return $ret_or_1
        } else {
          
          if (($truthy(fallback_name) && ($truthy(self.parent)))) {
            
            return self.document.$attributes()['$key?'](($eqeq(fallback_name, true) ? (name) : (fallback_name)).$to_s());
          } else {
            return false
          }        }      }, -2);
      
      $def(self, '$set_attr', function $$set_attr(name, value, overwrite) {
        var self = this;

        
        if (value == null) value = "";
        if (overwrite == null) overwrite = true;
        if (($eqeq(overwrite, false) && ($truthy(self.attributes['$key?'](name))))) {
          return false
        } else {
          
          self.attributes['$[]='](name, value);
          return true;
        }      }, -2);
      
      $def(self, '$remove_attr', function $$remove_attr(name) {
        var self = this;

        return self.attributes.$delete(name)
      });
      
      $def(self, '$option?', function $AbstractNode_option$ques$5(name) {
        var self = this;

        if ($truthy(self.attributes['$[]']("" + (name) + "-option"))) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$set_option', function $$set_option(name) {
        var self = this;

        
        self.attributes['$[]=']("" + (name) + "-option", "");
        return nil;
      });
      
      $def(self, '$enabled_options', function $$enabled_options() {
        var self = this;

        return $send($$$('Set').$new(), 'tap', [], function $$6(accum){var self = $$6.$$s == null ? this : $$6.$$s;
          if (self.attributes == null) self.attributes = nil;

          
          if (accum == null) accum = nil;
          return $send(self.attributes, 'each_key', [], function $$7(k){
            
            if (k == null) k = nil;
            if ($truthy(k.$to_s()['$end_with?']("-option"))) {
              return accum['$<<'](k.$slice(0, $rb_minus(k.$length(), 7)))
            } else {
              return nil
            }});}, {$$s: self})
      });
      
      $def(self, '$update_attributes', function $$update_attributes(new_attributes) {
        var self = this;

        return self.attributes.$update(new_attributes)
      });
      
      $def(self, '$role', function $$role() {
        var self = this;

        return self.attributes['$[]']("role")
      });
      
      $def(self, '$roles', function $$roles() {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          return val.$split()
        } else {
          return []
        }
      });
      
      $def(self, '$role?', function $AbstractNode_role$ques$8(expected_value) {
        var self = this;

        
        if (expected_value == null) expected_value = nil;
        if ($truthy(expected_value)) {
          return expected_value['$=='](self.attributes['$[]']("role"))
        } else {
          
          return self.attributes['$key?']("role");
        }      }, -1);
      
      $def(self, '$has_role?', function $AbstractNode_has_role$ques$9(name) {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          
          return (((" ") + (val)) + " ")['$include?'](" " + (name) + " ");
        } else {
          return false
        }
      });
      
      $def(self, '$role=', function $AbstractNode_role$eq$10(names) {
        var $a, self = this;

        return ($a = ["role", ($eqeqeq($$$('Array'), names) ? (names.$join(" ")) : (names))], $send(self.attributes, '[]=', $a), $a[$a.length - 1])
      });
      
      $def(self, '$add_role', function $$add_role(name) {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("role")))) {
          if ($truthy((((" ") + (val)) + " ")['$include?'](" " + (name) + " "))) {
            return false
          } else {
            
            self.attributes['$[]=']("role", "" + (val) + " " + (name));
            return true;
          }
        } else {
          
          self.attributes['$[]=']("role", name);
          return true;
        }
      });
      
      $def(self, '$remove_role', function $$remove_role(name) {
        var self = this, val = nil;

        if (($truthy((val = self.attributes['$[]']("role"))) && ($truthy((val = val.$split()).$delete(name))))) {
          
          if ($truthy(val['$empty?']())) {
            self.attributes.$delete("role");
          } else {
            self.attributes['$[]=']("role", val.$join(" "));
          }          return true;
        } else {
          return false
        }
      });
      
      $def(self, '$reftext', function $$reftext() {
        var self = this, val = nil;

        if ($truthy((val = self.attributes['$[]']("reftext")))) {
          
          return self.$apply_reftext_subs(val);
        } else {
          return nil
        }
      });
      
      $def(self, '$reftext?', function $AbstractNode_reftext$ques$11() {
        var self = this;

        return self.attributes['$key?']("reftext")
      });
      
      $def(self, '$icon_uri', function $$icon_uri(name) {
        var self = this, icon = nil;

        
        if ($truthy(self['$attr?']("icon"))) {
          
          icon = self.$attr("icon");
          if (!$truthy($$('Helpers')['$extname?'](icon))) {
            icon = "" + (icon) + "." + (self.document.$attr("icontype", "png"));
          }        } else {
          icon = "" + (name) + "." + (self.document.$attr("icontype", "png"));
        }        return self.$image_uri(icon, "iconsdir");
      });
      
      $def(self, '$image_uri', function $$image_uri(target_image, asset_dir_key) {
        var self = this, doc = nil, images_base = nil;

        
        if (asset_dir_key == null) asset_dir_key = "imagesdir";
        if (($truthy($rb_lt((doc = self.document).$safe(), $$$($$('SafeMode'), 'SECURE'))) && ($truthy(doc['$attr?']("data-uri"))))) {
          if ((($truthy($$('Helpers')['$uriish?'](target_image)) && ($truthy((target_image = $$('Helpers').$encode_spaces_in_uri(target_image))))) || (((($truthy(asset_dir_key) && ($truthy((images_base = doc.$attr(asset_dir_key))))) && ($truthy($$('Helpers')['$uriish?'](images_base)))) && ($truthy((target_image = self.$normalize_web_path(target_image, images_base, false)))))))) {
            if ($truthy(doc['$attr?']("allow-uri-read"))) {
              
              return self.$generate_data_uri_from_uri(target_image, doc['$attr?']("cache-uri"));
            } else {
              return target_image
            }
          } else {
            return self.$generate_data_uri(target_image, asset_dir_key)
          }
        } else {
          return self.$normalize_web_path(target_image, ($truthy(asset_dir_key) ? (doc.$attr(asset_dir_key)) : (nil)))
        }      }, -2);
      
      $def(self, '$media_uri', function $$media_uri(target, asset_dir_key) {
        var self = this;

        
        if (asset_dir_key == null) asset_dir_key = "imagesdir";
        return self.$normalize_web_path(target, ($truthy(asset_dir_key) ? (self.document.$attr(asset_dir_key)) : (nil)));
      }, -2);
      
      $def(self, '$generate_data_uri', function $$generate_data_uri(target_image, asset_dir_key) {
        var self = this, ext = nil, mimetype = nil, image_path = nil;

        
        if (asset_dir_key == null) asset_dir_key = nil;
        if ($truthy((ext = $$('Helpers').$extname(target_image, nil)))) {
          mimetype = ($eqeq(ext, ".svg") ? ("image/svg+xml") : ("image/" + (ext.$slice(1, ext.$length()))));
        } else {
          mimetype = "application/octet-stream";
        }        if ($truthy(asset_dir_key)) {
          image_path = self.$normalize_system_path(target_image, self.document.$attr(asset_dir_key), nil, $hash2(["target_name"], {"target_name": "image"}));
        } else {
          image_path = self.$normalize_system_path(target_image);
        }        if ($truthy($$$('File')['$readable?'](image_path))) {
          return "data:" + (mimetype) + ";base64," + ($$$('Base64').$strict_encode64($$$('File').$binread(image_path)))
        } else {
          
          self.$logger().$warn("image to embed not found or not readable: " + (image_path));
          return "data:" + (mimetype) + ";base64,";
        }      }, -2);
      
      $def(self, '$generate_data_uri_from_uri', function $$generate_data_uri_from_uri(image_uri, cache_uri) {
        var $a, $b, self = this, mimetype = nil, bindata = nil;

        
        if (cache_uri == null) cache_uri = false;
        if ($truthy(cache_uri)) {
          $$('Helpers').$require_library("open-uri/cached", "open-uri-cached");
        } else if ($not($$('RUBY_ENGINE_OPAL'))) {
          $$$('OpenURI');
        }        
        try {
          
          $b = $send($$$('OpenURI'), 'open_uri', [image_uri, $$('URI_READ_MODE')], function $$12(f){
            
            if (f == null) f = nil;
            return [f.$content_type(), f.$read()];}), $a = $to_ary($b), (mimetype = ($a[0] == null ? nil : $a[0])), (bindata = ($a[1] == null ? nil : $a[1])), $b;
          return "data:" + (mimetype) + ";base64," + ($$$('Base64').$strict_encode64(bindata));
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              
              self.$logger().$warn("could not retrieve image data from URI: " + (image_uri));
              return image_uri;
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }      }, -2);
      
      $def(self, '$normalize_asset_path', function $$normalize_asset_path(asset_ref, asset_name, autocorrect) {
        var self = this;

        
        if (asset_name == null) asset_name = "path";
        if (autocorrect == null) autocorrect = true;
        return self.$normalize_system_path(asset_ref, self.document.$base_dir(), nil, $hash2(["target_name", "recover"], {"target_name": asset_name, "recover": autocorrect}));
      }, -2);
      
      $def(self, '$normalize_system_path', function $$normalize_system_path(target, start, jail, opts) {
        var self = this, doc = nil, $ret_or_1 = nil;

        
        if (start == null) start = nil;
        if (jail == null) jail = nil;
        if (opts == null) opts = $hash2([], {});
        if ($truthy($rb_lt((doc = self.document).$safe(), $$$($$('SafeMode'), 'SAFE')))) {
          if ($truthy(start)) {
            if (!$truthy(doc.$path_resolver()['$root?'](start))) {
              start = $$$('File').$join(doc.$base_dir(), start);
            }
          } else {
            start = doc.$base_dir();
          }
        } else {
          
          start = ($truthy(($ret_or_1 = start)) ? ($ret_or_1) : (doc.$base_dir()));
          jail = ($truthy(($ret_or_1 = jail)) ? ($ret_or_1) : (doc.$base_dir()));
        }        return doc.$path_resolver().$system_path(target, start, jail, opts);
      }, -2);
      
      $def(self, '$normalize_web_path', function $$normalize_web_path(target, start, preserve_uri_target) {
        var self = this;

        
        if (start == null) start = nil;
        if (preserve_uri_target == null) preserve_uri_target = true;
        if (($truthy(preserve_uri_target) && ($truthy($$('Helpers')['$uriish?'](target))))) {
          return $$('Helpers').$encode_spaces_in_uri(target)
        } else {
          return self.document.$path_resolver().$web_path(target, start)
        }      }, -2);
      
      $def(self, '$read_asset', function $$read_asset(path, opts) {
        var self = this, $ret_or_1 = nil;

        
        if (opts == null) opts = $hash2([], {});
        if (!$eqeqeq($$$('Hash'), opts)) {
          opts = $hash2(["warn_on_failure"], {"warn_on_failure": opts['$!='](false)});
        }        if ($truthy($$$('File')['$readable?'](path))) {
          if ($truthy(opts['$[]']("normalize"))) {
            
            return $$('Helpers').$prepare_source_string($$$('File').$read(path, $hash2(["mode"], {"mode": $$('FILE_READ_MODE')}))).$join($$('LF'));
          } else {
            
            return $$$('File').$read(path, $hash2(["mode"], {"mode": $$('FILE_READ_MODE')}));
          }
        } else if ($truthy(opts['$[]']("warn_on_failure"))) {
          
          self.$logger().$warn("" + (($truthy(($ret_or_1 = self.$attr("docfile"))) ? ($ret_or_1) : ("<stdin>"))) + ": " + (($truthy(($ret_or_1 = opts['$[]']("label"))) ? ($ret_or_1) : ("file"))) + " does not exist or cannot be read: " + (path));
          return nil;
        } else {
          return nil
        }      }, -2);
      
      $def(self, '$read_contents', function $$read_contents(target, opts) {
        var self = this, doc = nil, start = nil, contents = nil, $ret_or_1 = nil;

        
        if (opts == null) opts = $hash2([], {});
        doc = self.document;
        if (($truthy($$('Helpers')['$uriish?'](target)) || ((($truthy((start = opts['$[]']("start"))) && ($truthy($$('Helpers')['$uriish?'](start)))) && ($truthy((target = doc.$path_resolver().$web_path(target, start)))))))) {
          if ($truthy(doc['$attr?']("allow-uri-read"))) {
            
            if ($truthy(doc['$attr?']("cache-uri"))) {
              $$('Helpers').$require_library("open-uri/cached", "open-uri-cached");
            }            
            try {
              if ($truthy(opts['$[]']("normalize"))) {
                contents = $$('Helpers').$prepare_source_string($send($$$('OpenURI'), 'open_uri', [target, $$('URI_READ_MODE')], function $$13(f){
                  
                  if (f == null) f = nil;
                  return f.$read();})).$join($$('LF'));
              } else {
                contents = $send($$$('OpenURI'), 'open_uri', [target, $$('URI_READ_MODE')], function $$14(f){
                  
                  if (f == null) f = nil;
                  return f.$read();});
              }
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  if ($truthy(opts.$fetch("warn_on_failure", true))) {
                    self.$logger().$warn("could not retrieve contents of " + (($truthy(($ret_or_1 = opts['$[]']("label"))) ? ($ret_or_1) : ("asset"))) + " at URI: " + (target));
                  }
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }          } else if ($truthy(opts.$fetch("warn_on_failure", true))) {
            self.$logger().$warn("cannot retrieve contents of " + (($truthy(($ret_or_1 = opts['$[]']("label"))) ? ($ret_or_1) : ("asset"))) + " at URI: " + (target) + " (allow-uri-read attribute not enabled)");
          }
        } else {
          
          target = self.$normalize_system_path(target, opts['$[]']("start"), nil, $hash2(["target_name"], {"target_name": ($truthy(($ret_or_1 = opts['$[]']("label"))) ? ($ret_or_1) : ("asset"))}));
          contents = self.$read_asset(target, $hash2(["normalize", "warn_on_failure", "label"], {"normalize": opts['$[]']("normalize"), "warn_on_failure": opts.$fetch("warn_on_failure", true), "label": opts['$[]']("label")}));
        }        if ((($truthy(contents) && ($truthy(opts['$[]']("warn_if_empty")))) && ($truthy(contents['$empty?']())))) {
          self.$logger().$warn("contents of " + (($truthy(($ret_or_1 = opts['$[]']("label"))) ? ($ret_or_1) : ("asset"))) + " is empty: " + (target));
        }        return contents;
      }, -2);
      return $def(self, '$is_uri?', function $AbstractNode_is_uri$ques$15(str) {
        
        return $$('Helpers')['$uriish?'](str)
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/abstract_block"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $return_val = Opal.return_val, $truthy = Opal.truthy, $alias = Opal.alias, $send = Opal.send, $rb_plus = Opal.rb_plus, $not = Opal.not, $neqeq = Opal.neqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,attr_writer,attr_accessor,==,===,level,file,lineno,playback_attributes,convert,converter,join,map,to_s,parent,parent=,<<,empty?,Integer,find_by_internal,to_proc,find_by,context,[],items,+,find_index,include?,next_adjacent_block,blocks,select,sub_specialchars,match?,sub_replacements,title,apply_title_subs,delete,!,reftext,nil_or_empty?,sub_placeholder,sub_quotes,compat_mode,attributes,chomp,increment_and_store_counter,index=,numbered,sectname,numeral=,counter,caption=,numeral,int_to_roman,each,assign_numeral,reindex_sections,protected,has_role?,raise,header?,!=,flatten,head,rows,merge,body,foot,style,inner_document');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AbstractBlock');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.source_location = $proto.document = $proto.attributes = $proto.blocks = $proto.numeral = $proto.context = $proto.parent = $proto.caption = $proto.style = $proto.converted_title = $proto.title = $proto.subs = $proto.next_section_index = $proto.next_section_ordinal = $proto.id = $proto.header = nil;
      
      self.$attr_reader("blocks");
      self.$attr_writer("caption");
      self.$attr_accessor("content_model");
      self.$attr_accessor("level");
      self.$attr_accessor("numeral");
      self.$attr_accessor("source_location");
      self.$attr_accessor("style");
      self.$attr_reader("subs");
      
      $def(self, '$initialize', function $$initialize(parent, context, opts) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (opts == null) opts = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, context, opts], $yield);
        self.content_model = "compound";
        self.blocks = [];
        self.subs = [];
        self.id = (self.title = (self.caption = (self.numeral = (self.style = (self.default_subs = (self.source_location = nil))))));
        if (($eqeq(context, "document") || ($eqeq(context, "section")))) {
          
          self.level = (self.next_section_index = 0);
          return (self.next_section_ordinal = 1);
        } else if ($eqeqeq($$('AbstractBlock'), parent)) {
          return (self.level = parent.$level())
        } else {
          return (self.level = nil)
        }      }, -3);
      
      $def(self, '$block?', $return_val(true));
      
      $def(self, '$inline?', $return_val(false));
      
      $def(self, '$file', function $$file() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_location))) {
          return self.source_location.$file()
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$lineno', function $$lineno() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_location))) {
          return self.source_location.$lineno()
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$convert', function $$convert() {
        var self = this;

        
        self.document.$playback_attributes(self.attributes);
        return self.$converter().$convert(self);
      });
      $alias(self, "render", "convert");
      
      $def(self, '$content', function $$content() {
        var self = this;

        return $send(self.blocks, 'map', [], function $$1(b){
          
          if (b == null) b = nil;
          return b.$convert();}).$join($$('LF'))
      });
      
      $def(self, '$context=', function $AbstractBlock_context$eq$2(context) {
        var self = this;

        return (self.node_name = (self.context = context).$to_s())
      });
      
      $def(self, '$<<', function $AbstractBlock_$lt$lt$3(block) {
        var self = this;

        
        if (!$eqeq(block.$parent(), self)) {
          block['$parent='](self);
        }        self.blocks['$<<'](block);
        return self;
      });
      $alias(self, "append", "<<");
      
      $def(self, '$blocks?', function $AbstractBlock_blocks$ques$4() {
        var self = this;

        if ($truthy(self.blocks['$empty?']())) {
          return false
        } else {
          return true
        }
      });
      
      $def(self, '$sections?', $return_val(false));
      
      $def(self, '$number', function $$number() {
        var self = this;

        try {
          
          return self.$Integer(self.numeral);
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              return self.numeral
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }
      });
      
      $def(self, '$number=', function $AbstractBlock_number$eq$5(val) {
        var self = this;

        return (self.numeral = val.$to_s())
      });
      
      $def(self, '$find_by', function $$find_by(selector) {
        var block = $$find_by.$$p || nil, self = this, result = nil;

        $$find_by.$$p = null;
        if (selector == null) selector = $hash2([], {});
        try {
          return $send(self, 'find_by_internal', [selector, (result = [])], block.$to_proc())
        } catch ($err) {
          if (Opal.rescue($err, [$$$('StopIteration')])) {
            try {
              return result
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }      }, -1);
      $alias(self, "query", "find_by");
      
      $def(self, '$next_adjacent_block', function $$next_adjacent_block() {
        var self = this, p = nil, sib = nil;

        if ($eqeq(self.context, "document")) {
          return nil
        } else if (($eqeq((p = self.parent).$context(), "dlist") && ($eqeq(self.context, "list_item")))) {
          if ($truthy((sib = p.$items()['$[]']($rb_plus($send(p.$items(), 'find_index', [], function $$6(terms, desc){var self = $$6.$$s == null ? this : $$6.$$s, $ret_or_1 = nil;

            
            if (terms == null) terms = nil;
            if (desc == null) desc = nil;
            if ($truthy(($ret_or_1 = terms['$include?'](self)))) {
              return $ret_or_1
            } else {
              return desc['$=='](self)
            }}, {$$s: self}), 1))))) {
            return sib
          } else {
            return p.$next_adjacent_block()
          }
        } else if ($truthy((sib = p.$blocks()['$[]']($rb_plus(p.$blocks().$find_index(self), 1))))) {
          return sib
        } else {
          return p.$next_adjacent_block()
        }
      });
      
      $def(self, '$sections', function $$sections() {
        var self = this;

        return $send(self.blocks, 'select', [], function $$7(block){
          
          if (block == null) block = nil;
          return block.$context()['$==']("section");})
      });
      
      $def(self, '$alt', function $$alt() {
        var self = this, text = nil;

        if ($truthy((text = self.attributes['$[]']("alt")))) {
          if ($eqeq(text, self.attributes['$[]']("default-alt"))) {
            return self.$sub_specialchars(text)
          } else {
            
            text = self.$sub_specialchars(text);
            if ($truthy($$('ReplaceableTextRx')['$match?'](text))) {
              
              return self.$sub_replacements(text);
            } else {
              return text
            }          }
        } else {
          return ""
        }
      });
      
      $def(self, '$caption', function $$caption() {
        var self = this;

        if ($eqeq(self.context, "admonition")) {
          return self.attributes['$[]']("textlabel")
        } else {
          return self.caption
        }
      });
      
      $def(self, '$captioned_title', function $$captioned_title() {
        var self = this;

        return "" + (self.caption) + (self.$title())
      });
      
      $def(self, '$list_marker_keyword', function $$list_marker_keyword(list_type) {
        var self = this, $ret_or_1 = nil;

        
        if (list_type == null) list_type = nil;
        return $$('ORDERED_LIST_KEYWORDS')['$[]'](($truthy(($ret_or_1 = list_type)) ? ($ret_or_1) : (self.style)));
      }, -1);
      
      $def(self, '$title', function $$title() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        return (self.converted_title = ($truthy(($ret_or_1 = self.converted_title)) ? ($ret_or_1) : ($truthy(($ret_or_2 = self.title)) ? (self.$apply_title_subs(self.title)) : ($ret_or_2))))
      });
      
      $def(self, '$title?', function $AbstractBlock_title$ques$8() {
        var self = this;

        if ($truthy(self.title)) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$title=', function $AbstractBlock_title$eq$9(val) {
        var self = this;

        
        self.converted_title = nil;
        return (self.title = val);
      });
      
      $def(self, '$sub?', function $AbstractBlock_sub$ques$10(name) {
        var self = this;

        return self.subs['$include?'](name)
      });
      
      $def(self, '$remove_sub', function $$remove_sub(sub) {
        var self = this;

        
        self.subs.$delete(sub);
        return nil;
      });
      
      $def(self, '$xreftext', function $$xreftext(xrefstyle) {
        var self = this, val = nil, quoted_title = nil, prefix = nil, caption_attr_name = nil;

        
        if (xrefstyle == null) xrefstyle = nil;
        if (($truthy((val = self.$reftext())) && ($not(val['$empty?']())))) {
          return val
        } else if ((($truthy(xrefstyle) && ($truthy(self.title))) && ($not(self.caption['$nil_or_empty?']())))) {
          
          switch (xrefstyle) {
            case "full":
              
              quoted_title = self.$sub_placeholder(self.$sub_quotes(($truthy(self.document.$compat_mode()) ? ("``%s''") : ("\"`%s`\""))), self.$title());
              if ((($truthy(self.numeral) && ($truthy((caption_attr_name = $$('CAPTION_ATTRIBUTE_NAMES')['$[]'](self.context))))) && ($truthy((prefix = self.document.$attributes()['$[]'](caption_attr_name)))))) {
                return "" + (prefix) + " " + (self.numeral) + ", " + (quoted_title)
              } else {
                return "" + (self.caption.$chomp(". ")) + ", " + (quoted_title)
              }            case "short":
              if ((($truthy(self.numeral) && ($truthy((caption_attr_name = $$('CAPTION_ATTRIBUTE_NAMES')['$[]'](self.context))))) && ($truthy((prefix = self.document.$attributes()['$[]'](caption_attr_name)))))) {
                return "" + (prefix) + " " + (self.numeral)
              } else {
                return self.caption.$chomp(". ")
              }
            default:
              return self.$title()
          }
        } else {
          return self.$title()
        }      }, -1);
      
      $def(self, '$assign_caption', function $$assign_caption(value, caption_context) {
        var self = this, $ret_or_1 = nil, prefix = nil, attr_name = nil;

        
        if (caption_context == null) caption_context = self.context;
        if ((($truthy(self.caption) || ($not(self.title))) || ($truthy((self.caption = ($truthy(($ret_or_1 = value)) ? ($ret_or_1) : (self.document.$attributes()['$[]']("caption")))))))) {
          return nil
        } else if (($truthy((attr_name = $$('CAPTION_ATTRIBUTE_NAMES')['$[]'](caption_context))) && ($truthy((prefix = self.document.$attributes()['$[]'](attr_name)))))) {
          
          self.caption = "" + (prefix) + " " + ((self.numeral = self.document.$increment_and_store_counter("" + (caption_context) + "-number", self))) + ". ";
          return nil;
        } else {
          return nil
        }      }, -2);
      
      $def(self, '$assign_numeral', function $$assign_numeral(section) {
        var $a, self = this, like = nil, sectname = nil, caption = nil;

        
        self.next_section_index = $rb_plus(($a = [self.next_section_index], $send(section, 'index=', $a), $a[$a.length - 1]), 1);
        if ($truthy((like = section.$numbered()))) {
          if ($eqeq((sectname = section.$sectname()), "appendix")) {
            
            section['$numeral='](self.document.$counter("appendix-number", "A"));
            section['$caption='](($truthy((caption = self.document.$attributes()['$[]']("appendix-caption"))) ? ("" + (caption) + " " + (section.$numeral()) + ": ") : ("" + (section.$numeral()) + ". ")));
          } else if (($eqeq(sectname, "chapter") || ($eqeq(like, "chapter")))) {
            section['$numeral='](self.document.$counter("chapter-number", 1).$to_s());
          } else {
            
            section['$numeral='](($eqeq(sectname, "part") ? ($$('Helpers').$int_to_roman(self.next_section_ordinal)) : (self.next_section_ordinal.$to_s())));
            self.next_section_ordinal = $rb_plus(self.next_section_ordinal, 1);
          }
        }        return nil;
      });
      
      $def(self, '$reindex_sections', function $$reindex_sections() {
        var self = this;

        
        self.next_section_index = 0;
        self.next_section_ordinal = 1;
        return $send(self.blocks, 'each', [], function $$11(block){var self = $$11.$$s == null ? this : $$11.$$s;

          
          if (block == null) block = nil;
          if ($eqeq(block.$context(), "section")) {
            
            self.$assign_numeral(block);
            return block.$reindex_sections();
          } else {
            return nil
          }}, {$$s: self});
      });
      self.$protected();
      return $def(self, '$find_by_internal', function $$find_by_internal(selector, result) {
        var block = $$find_by_internal.$$p || nil, self = this, id_selector = nil, role_selector = nil, style_selector = nil, any_context = nil, context_selector = nil, verdict = nil;

        $$find_by_internal.$$p = null;
        if (selector == null) selector = $hash2([], {});
        if (result == null) result = [];
        if ((((($truthy((any_context = ($truthy((context_selector = selector['$[]']("context"))) ? (nil) : (true)))) || ($eqeq(context_selector, self.context))) && (($not((style_selector = selector['$[]']("style"))) || ($eqeq(style_selector, self.style))))) && (($not((role_selector = selector['$[]']("role"))) || ($truthy(self['$has_role?'](role_selector)))))) && (($not((id_selector = selector['$[]']("id"))) || ($eqeq(id_selector, self.id)))))) {
          if ((block !== nil)) {
            if ($truthy((verdict = Opal.yield1(block, self)))) {
              
              switch (verdict) {
                case "prune":
                  
                  result['$<<'](self);
                  if ($truthy(id_selector)) {
                    self.$raise($$$('StopIteration'));
                  }                  return result;
                case "reject":
                  
                  if ($truthy(id_selector)) {
                    self.$raise($$$('StopIteration'));
                  }                  return result;
                case "stop":
                  self.$raise($$$('StopIteration'));
                  break;
                default:
                  
                  result['$<<'](self);
                  if ($truthy(id_selector)) {
                    self.$raise($$$('StopIteration'));
                  }              }
            } else if ($truthy(id_selector)) {
              self.$raise($$$('StopIteration'));
            }
          } else {
            
            result['$<<'](self);
            if ($truthy(id_selector)) {
              self.$raise($$$('StopIteration'));
            }          }
        }        
        switch (self.context) {
          case "document":
            if (!$eqeq(context_selector, "document")) {
              
              if (($truthy(self['$header?']()) && (($truthy(any_context) || ($eqeq(context_selector, "section")))))) {
                $send(self.header, 'find_by_internal', [selector, result], block.$to_proc());
              }              $send(self.blocks, 'each', [], function $$12(b){
                
                if (b == null) b = nil;
                if (($eqeq(context_selector, "section") && ($neqeq(b.$context(), "section")))) {
                  return nil
                }                return $send(b, 'find_by_internal', [selector, result], block.$to_proc());});
            }
            break;
          case "dlist":
            if (($truthy(any_context) || ($neqeq(context_selector, "section")))) {
              $send(self.blocks.$flatten(), 'each', [], function $$13(b){
                
                if (b == null) b = nil;
                if ($truthy(b)) {
                  return $send(b, 'find_by_internal', [selector, result], block.$to_proc())
                } else {
                  return nil
                }});
            }
            break;
          case "table":
            if ($truthy(selector['$[]']("traverse_documents"))) {
              
              $send(self.$rows().$head(), 'each', [], function $$14(r){
                
                if (r == null) r = nil;
                return $send(r, 'each', [], function $$15(c){
                  
                  if (c == null) c = nil;
                  return $send(c, 'find_by_internal', [selector, result], block.$to_proc());});});
              if ($eqeq(context_selector, "inner_document")) {
                selector = selector.$merge($hash2(["context"], {"context": "document"}));
              }              $send($rb_plus(self.$rows().$body(), self.$rows().$foot()), 'each', [], function $$16(r){
                
                if (r == null) r = nil;
                return $send(r, 'each', [], function $$17(c){
                  
                  if (c == null) c = nil;
                  $send(c, 'find_by_internal', [selector, result], block.$to_proc());
                  if ($eqeq(c.$style(), "asciidoc")) {
                    return $send(c.$inner_document(), 'find_by_internal', [selector, result], block.$to_proc())
                  } else {
                    return nil
                  }});});
            } else {
              $send($rb_plus($rb_plus(self.$rows().$head(), self.$rows().$body()), self.$rows().$foot()), 'each', [], function $$18(r){
                
                if (r == null) r = nil;
                return $send(r, 'each', [], function $$19(c){
                  
                  if (c == null) c = nil;
                  return $send(c, 'find_by_internal', [selector, result], block.$to_proc());});});
            }
            break;
          default:
            $send(self.blocks, 'each', [], function $$20(b){
              
              if (b == null) b = nil;
              if (($eqeq(context_selector, "section") && ($neqeq(b.$context(), "section")))) {
                return nil
              }              return $send(b, 'find_by_internal', [selector, result], block.$to_proc());});
        }        return result;
      }, -1);
    })($nesting[0], $$('AbstractNode'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/attribute_list"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash = Opal.hash, $regexp = Opal.regexp, $hash2 = Opal.hash2, $def = Opal.def, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $send = Opal.send, $defs = Opal.defs, $eqeqeq = Opal.eqeqeq, $eqeq = Opal.eqeq, $rb_times = Opal.rb_times, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,[],update,parse,parse_attribute,eos?,skip_delimiter,+,rekey,each_with_index,[]=,private,skip_blank,===,peek,parse_attribute_value,get_byte,start_with?,scan_name,end_with?,rstrip,string,==,unscan,scan_to_delimiter,*,include?,delete,each,split,empty?,apply_subs,scan_to_quote,gsub,skip,scan');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'AttributeList');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.attributes = $proto.scanner = $proto.delimiter = $proto.block = $proto.delimiter_skip_pattern = $proto.delimiter_boundary_pattern = nil;
      
      $const_set($nesting[0], 'APOS', "'");
      $const_set($nesting[0], 'BACKSLASH', "\\");
      $const_set($nesting[0], 'QUOT', "\"");
      $const_set($nesting[0], 'BoundaryRx', $hash($$('QUOT'), /.*?[^\\](?=")/, $$('APOS'), /.*?[^\\](?=')/, ",", /.*?(?=[ \t]*(,|$))/));
      $const_set($nesting[0], 'EscapedQuotes', $hash($$('QUOT'), "\\\"", $$('APOS'), "\\'"));
      $const_set($nesting[0], 'NameRx', $regexp([$$('CG_WORD'), "[", $$('CC_WORD'), "\\-.]*"]));
      $const_set($nesting[0], 'BlankRx', /[ \t]+/);
      $const_set($nesting[0], 'SkipRx', $hash2([","], {",": /[ \t]*(,|$)/}));
      
      $def(self, '$initialize', function $$initialize(source, block, delimiter) {
        var self = this;

        
        if (block == null) block = nil;
        if (delimiter == null) delimiter = ",";
        self.scanner = $$$('StringScanner').$new(source);
        self.block = block;
        self.delimiter = delimiter;
        self.delimiter_skip_pattern = $$('SkipRx')['$[]'](delimiter);
        self.delimiter_boundary_pattern = $$('BoundaryRx')['$[]'](delimiter);
        return (self.attributes = nil);
      }, -2);
      
      $def(self, '$parse_into', function $$parse_into(attributes, positional_attrs) {
        var self = this;

        
        if (positional_attrs == null) positional_attrs = [];
        return attributes.$update(self.$parse(positional_attrs));
      }, -2);
      
      $def(self, '$parse', function $$parse(positional_attrs) {
        var self = this, index = nil;

        
        if (positional_attrs == null) positional_attrs = [];
        if ($truthy(self.attributes)) {
          return self.attributes
        }        self.attributes = $hash2([], {});
        index = 0;
        while ($truthy(self.$parse_attribute(index, positional_attrs))) {
        
          if ($truthy(self.scanner['$eos?']())) {
            break
          }          self.$skip_delimiter();
          index = $rb_plus(index, 1);
        }        return self.attributes;
      }, -1);
      
      $def(self, '$rekey', function $$rekey(positional_attrs) {
        var self = this;

        return $$('AttributeList').$rekey(self.attributes, positional_attrs)
      });
      $defs(self, '$rekey', function $$rekey(attributes, positional_attrs) {
        
        
        $send(positional_attrs, 'each_with_index', [], function $$1(key, index){var $a, val = nil;

          
          if (key == null) key = nil;
          if (index == null) index = nil;
          if (($truthy(key) && ($truthy((val = attributes['$[]']($rb_plus(index, 1))))))) {
            return ($a = [key, val], $send(attributes, '[]=', $a), $a[$a.length - 1])
          } else {
            return nil
          }});
        return attributes;
      });
      self.$private();
      
      $def(self, '$parse_attribute', function $$parse_attribute(index, positional_attrs) {
        var self = this, continue$ = nil, $ret_or_1 = nil, name = nil, single_quoted = nil, skipped = nil, $ret_or_2 = nil, $ret_or_3 = nil, c = nil, value = nil, positional_attr_name = nil;

        
        continue$ = true;
        self.$skip_blank();
        if ($eqeqeq($$('QUOT'), ($ret_or_1 = self.scanner.$peek(1)))) {
          name = self.$parse_attribute_value(self.scanner.$get_byte());
        } else if ($eqeqeq($$('APOS'), $ret_or_1)) {
          
          name = self.$parse_attribute_value(self.scanner.$get_byte());
          if (!$truthy(name['$start_with?']($$('APOS')))) {
            single_quoted = true;
          }        } else {
          
          skipped = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = (name = self.$scan_name()))) ? (self.$skip_blank()) : ($ret_or_3)))) ? ($ret_or_2) : (0));
          if ($truthy(self.scanner['$eos?']())) {
            
            if (!($truthy(name) || ($truthy(self.scanner.$string().$rstrip()['$end_with?'](self.delimiter))))) {
              return nil
            }            continue$ = nil;
          } else if ($eqeq((c = self.scanner.$get_byte()), self.delimiter)) {
            self.scanner.$unscan();
          } else if ($truthy(name)) {
            if ($eqeq(c, "=")) {
              
              self.$skip_blank();
              if ($eqeqeq($$('QUOT'), ($ret_or_2 = (c = self.scanner.$get_byte())))) {
                value = self.$parse_attribute_value(c);
              } else if ($eqeqeq($$('APOS'), $ret_or_2)) {
                
                value = self.$parse_attribute_value(c);
                if (!$truthy(value['$start_with?']($$('APOS')))) {
                  single_quoted = true;
                }              } else if ($eqeqeq(self.delimiter, $ret_or_2)) {
                
                value = "";
                self.scanner.$unscan();
              } else if ($eqeqeq(nil, $ret_or_2)) {
                value = "";
              } else {
                
                value = "" + (c) + (self.$scan_to_delimiter());
                if ($eqeq(value, "None")) {
                  return true
                }              }            } else {
              name = "" + (name) + ($rb_times(" ", skipped)) + (c) + (self.$scan_to_delimiter());
            }
          } else {
            name = "" + (c) + (self.$scan_to_delimiter());
          }        }        if ($truthy(value)) {
          
          switch (name) {
            case "options":
            case "opts":
              if ($truthy(value['$include?'](","))) {
                
                if ($truthy(value['$include?'](" "))) {
                  value = value.$delete(" ");
                }                $send(value.$split(","), 'each', [], function $$2(opt){var $a, self = $$2.$$s == null ? this : $$2.$$s;
                  if (self.attributes == null) self.attributes = nil;

                  
                  if (opt == null) opt = nil;
                  if ($truthy(opt['$empty?']())) {
                    return nil
                  } else {
                    return ($a = ["" + (opt) + "-option", ""], $send(self.attributes, '[]=', $a), $a[$a.length - 1])
                  }}, {$$s: self});
              } else if (!$truthy(value['$empty?']())) {
                self.attributes['$[]=']("" + (value) + "-option", "");
              }
              break;
            default:
              if (($truthy(single_quoted) && ($truthy(self.block)))) {
                
                switch (name) {
                  case "title":
                  case "reftext":
                    self.attributes['$[]='](name, value);
                    break;
                  default:
                    self.attributes['$[]='](name, self.block.$apply_subs(value));
                }
              } else {
                self.attributes['$[]='](name, value);
              }
          }
        } else {
          
          if (($truthy(single_quoted) && ($truthy(self.block)))) {
            name = self.block.$apply_subs(name);
          }          if (($truthy((positional_attr_name = positional_attrs['$[]'](index))) && ($truthy(name)))) {
            self.attributes['$[]='](positional_attr_name, name);
          }          self.attributes['$[]=']($rb_plus(index, 1), name);
        }        return continue$;
      });
      
      $def(self, '$parse_attribute_value', function $$parse_attribute_value(quote) {
        var self = this, value = nil;

        if ($eqeq(self.scanner.$peek(1), quote)) {
          
          self.scanner.$get_byte();
          return "";
        } else if ($truthy((value = self.$scan_to_quote(quote)))) {
          
          self.scanner.$get_byte();
          if ($truthy(value['$include?']($$('BACKSLASH')))) {
            
            return value.$gsub($$('EscapedQuotes')['$[]'](quote), quote);
          } else {
            return value
          }        } else {
          return "" + (quote) + (self.$scan_to_delimiter())
        }
      });
      
      $def(self, '$skip_blank', function $$skip_blank() {
        var self = this;

        return self.scanner.$skip($$('BlankRx'))
      });
      
      $def(self, '$skip_delimiter', function $$skip_delimiter() {
        var self = this;

        return self.scanner.$skip(self.delimiter_skip_pattern)
      });
      
      $def(self, '$scan_name', function $$scan_name() {
        var self = this;

        return self.scanner.$scan($$('NameRx'))
      });
      
      $def(self, '$scan_to_delimiter', function $$scan_to_delimiter() {
        var self = this;

        return self.scanner.$scan(self.delimiter_boundary_pattern)
      });
      return $def(self, '$scan_to_quote', function $$scan_to_quote(quote) {
        var self = this;

        return self.scanner.$scan($$('BoundaryRx')['$[]'](quote))
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/block"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $alias = Opal.alias, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $def = Opal.def, $rb_lt = Opal.rb_lt, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('default=,context,attr_accessor,[],key?,===,drop,delete,[]=,to_s,commit_subs,nil_or_empty?,prepare_source_string,apply_subs,join,<,size,empty?,rstrip,shift,pop,==,warn,logger,class,object_id,inspect');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Block');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.attributes = $proto.content_model = $proto.lines = $proto.subs = $proto.blocks = $proto.context = $proto.style = nil;
      
      $const_set($nesting[0], 'DEFAULT_CONTENT_MODEL', $hash2(["audio", "image", "listing", "literal", "stem", "open", "page_break", "pass", "thematic_break", "video"], {"audio": "empty", "image": "empty", "listing": "verbatim", "literal": "verbatim", "stem": "raw", "open": "compound", "page_break": "empty", "pass": "raw", "thematic_break": "empty", "video": "empty"}))['$default=']("simple");
      $alias(self, "blockname", "context");
      self.$attr_accessor("lines");
      
      $def(self, '$initialize', function $$initialize(parent, context, opts) {
        var $yield = $$initialize.$$p || nil, self = this, $ret_or_1 = nil, subs = nil, raw_source = nil;

        $$initialize.$$p = null;
        
        if (opts == null) opts = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, context, opts], $yield);
        self.content_model = ($truthy(($ret_or_1 = opts['$[]']("content_model"))) ? ($ret_or_1) : ($$('DEFAULT_CONTENT_MODEL')['$[]'](context)));
        if ($truthy(opts['$key?']("subs"))) {
          if ($truthy((subs = opts['$[]']("subs")))) {
            
            if ($eqeqeq("default", ($ret_or_1 = subs))) {
              self.default_subs = opts['$[]']("default_subs");
            } else if ($eqeqeq($$$('Array'), $ret_or_1)) {
              
              self.default_subs = subs.$drop(0);
              self.attributes.$delete("subs");
            } else {
              
              self.default_subs = nil;
              self.attributes['$[]=']("subs", subs.$to_s());
            }            self.$commit_subs();
          } else {
            
            self.default_subs = [];
            self.attributes.$delete("subs");
          }
        } else {
          self.default_subs = nil;
        }        if ($truthy((raw_source = opts['$[]']("source"))['$nil_or_empty?']())) {
          return (self.lines = [])
        } else if ($eqeqeq($$$('String'), raw_source)) {
          return (self.lines = $$('Helpers').$prepare_source_string(raw_source))
        } else {
          return (self.lines = raw_source.$drop(0))
        }      }, -3);
      
      $def(self, '$content', function $$content() {
        var $yield = $$content.$$p || nil, self = this, result = nil, $ret_or_2 = nil, first = nil, last = nil;

        $$content.$$p = null;
        
        switch (self.content_model) {
          case "compound":
            return $send2(self, $find_super(self, 'content', $$content, false, true), 'content', [], $yield)
          case "simple":
            return self.$apply_subs(self.lines.$join($$('LF')), self.subs)
          case "verbatim":
          case "raw":
            
            result = self.$apply_subs(self.lines, self.subs);
            if ($truthy($rb_lt(result.$size(), 2))) {
              if ($truthy(($ret_or_2 = result['$[]'](0)))) {
                return $ret_or_2
              } else {
                return ""
              }
            } else {
              
              while ($truthy(($truthy(($ret_or_2 = (first = result['$[]'](0)))) ? (first.$rstrip()['$empty?']()) : ($ret_or_2)))) {
              result.$shift();
              }              while ($truthy(($truthy(($ret_or_2 = (last = result['$[]'](-1)))) ? (last.$rstrip()['$empty?']()) : ($ret_or_2)))) {
              result.$pop();
              }              return result.$join($$('LF'));
            }          default:
            
            if (!$eqeq(self.content_model, "empty")) {
              self.$logger().$warn("unknown content model '" + (self.content_model) + "' for block: " + (self));
            }            return nil;
        }
      });
      
      $def(self, '$source', function $$source() {
        var self = this;

        return self.lines.$join($$('LF'))
      });
      return $def(self, '$to_s', function $$to_s() {
        var self = this, content_summary = nil;

        
        content_summary = ($eqeq(self.content_model, "compound") ? ("blocks: " + (self.blocks.$size())) : ("lines: " + (self.lines.$size())));
        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {context: " + (self.context.$inspect()) + ", content_model: " + (self.content_model.$inspect()) + ", style: " + (self.style.$inspect()) + ", " + (content_summary) + "}>";
      });
    })($nesting[0], $$('AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/callouts"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $hash2 = Opal.hash2, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $rb_le = Opal.rb_le, $rb_minus = Opal.rb_minus, $send = Opal.send, $eqeq = Opal.eqeq, $rb_lt = Opal.rb_lt, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('next_list,<<,current_list,to_i,generate_next_callout_id,+,<=,size,[],-,chop,join,map,==,<,private,generate_callout_id');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Callouts');

      var $proto = self.$$prototype;

      $proto.co_index = $proto.lists = $proto.list_index = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.lists = [];
        self.list_index = 0;
        return self.$next_list();
      });
      
      $def(self, '$register', function $$register(li_ordinal) {
        var self = this, id = nil;

        
        self.$current_list()['$<<']($hash2(["ordinal", "id"], {"ordinal": li_ordinal.$to_i(), "id": (id = self.$generate_next_callout_id())}));
        self.co_index = $rb_plus(self.co_index, 1);
        return id;
      });
      
      $def(self, '$read_next_id', function $$read_next_id() {
        var self = this, id = nil, list = nil;

        
        id = nil;
        list = self.$current_list();
        if ($truthy($rb_le(self.co_index, list.$size()))) {
          id = list['$[]']($rb_minus(self.co_index, 1))['$[]']("id");
        }        self.co_index = $rb_plus(self.co_index, 1);
        return id;
      });
      
      $def(self, '$callout_ids', function $$callout_ids(li_ordinal) {
        var self = this;

        return $send(self.$current_list(), 'map', [], function $$1(it){
          
          if (it == null) it = nil;
          if ($eqeq(it['$[]']("ordinal"), li_ordinal)) {
            return "" + (it['$[]']("id")) + " "
          } else {
            return ""
          }}).$join().$chop()
      });
      
      $def(self, '$current_list', function $$current_list() {
        var self = this;

        return self.lists['$[]']($rb_minus(self.list_index, 1))
      });
      
      $def(self, '$next_list', function $$next_list() {
        var self = this;

        
        self.list_index = $rb_plus(self.list_index, 1);
        if ($truthy($rb_lt(self.lists.$size(), self.list_index))) {
          self.lists['$<<']([]);
        }        self.co_index = 1;
        return nil;
      });
      
      $def(self, '$rewind', function $$rewind() {
        var self = this;

        
        self.list_index = 1;
        self.co_index = 1;
        return nil;
      });
      self.$private();
      
      $def(self, '$generate_next_callout_id', function $$generate_next_callout_id() {
        var self = this;

        return self.$generate_callout_id(self.list_index, self.co_index)
      });
      return $def(self, '$generate_callout_id', function $$generate_callout_id(list_index, co_index) {
        
        return "CO" + (list_index) + "-" + (co_index)
      });
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/converter/composite"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $send = Opal.send, $truthy = Opal.truthy, $def = Opal.def, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,each,respond_to?,composed,init_backend_traits,backend_traits,new,[]=,find_converter,convert,converter_for,node_name,[],handles?,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'CompositeConverter');

      var $proto = self.$$prototype;

      $proto.converter_cache = $proto.converters = nil;
      
      self.$attr_reader("converters");
      
      $def(self, '$initialize', function $$initialize(backend, $a, $b) {
        var $post_args, $kwargs, converters, backend_traits_source, self = this;

        
        $post_args = $slice(arguments, 1);
        $kwargs = $extract_kwargs($post_args);
        $kwargs = $ensure_kwargs($kwargs);
        converters = $post_args;
        
        backend_traits_source = $kwargs.$$smap["backend_traits_source"];if (backend_traits_source == null) backend_traits_source = nil;
        self.backend = backend;
        $send((self.converters = converters), 'each', [], function $$1(converter){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (converter == null) converter = nil;
          if ($truthy(converter['$respond_to?']("composed"))) {
            return converter.$composed(self)
          } else {
            return nil
          }}, {$$s: self});
        if ($truthy(backend_traits_source)) {
          self.$init_backend_traits(backend_traits_source.$backend_traits());
        }        return (self.converter_cache = $send($$$('Hash'), 'new', [], function $$2(hash, key){var $c, self = $$2.$$s == null ? this : $$2.$$s;

          
          if (hash == null) hash = nil;
          if (key == null) key = nil;
          return ($c = [key, self.$find_converter(key)], $send(hash, '[]=', $c), $c[$c.length - 1]);}, {$$s: self}));
      }, -2);
      
      $def(self, '$convert', function $$convert(node, transform, opts) {
        var self = this, $ret_or_1 = nil;

        
        if (transform == null) transform = nil;
        if (opts == null) opts = nil;
        return self.$converter_for((transform = ($truthy(($ret_or_1 = transform)) ? ($ret_or_1) : (node.$node_name())))).$convert(node, transform, opts);
      }, -2);
      
      $def(self, '$converter_for', function $$converter_for(transform) {
        var self = this;

        return self.converter_cache['$[]'](transform)
      });
      return $def(self, '$find_converter', function $$find_converter(transform) {try { var $t_return = $thrower('return'); 
        var self = this;

        
        $send(self.converters, 'each', [], function $$3(candidate){
          
          if (candidate == null) candidate = nil;
          if ($truthy(candidate['$handles?'](transform))) {
            $t_return.$throw(candidate);
          } else {
            return nil
          };}, {$$ret: $t_return});
        return self.$raise("Could not find a converter to handle transform: " + (transform));} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      });
    })($$('Converter'), $$$($$('Converter'), 'Base'))
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/converter"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $hash2 = Opal.hash2, $def = Opal.def, $return_val = Opal.return_val, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $defs = Opal.defs, $send = Opal.send, $alias = Opal.alias, $slice = Opal.slice, $to_a = Opal.to_a, $extract_kwargs = Opal.extract_kwargs, $ensure_kwargs = Opal.ensure_kwargs, $eqeqeq = Opal.eqeqeq, $Class = Opal.Class, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $class_variable_get = Opal.class_variable_get, $rb_plus = Opal.rb_plus, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('autoload,attr_reader,raise,class,[],sub,slice,length,==,[]=,backend_traits,derive_backend_traits,register,map,to_s,new,create,default,each,default=,registry,for,===,supports_templates?,merge,private,include,delete,clear,send,extend,private_class_method,node_name,+,name,receiver,warn,logger,respond_to?,content');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Converter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$autoload("CompositeConverter", "" + ("asciidoctor") + "/converter/composite");
      self.$attr_reader("backend");
      
      $def(self, '$initialize', function $$initialize(backend, opts) {
        var self = this;

        
        if (opts == null) opts = $hash2([], {});
        return (self.backend = backend);
      }, -2);
      
      $def(self, '$convert', function $$convert(node, transform, opts) {
        var self = this;
        if (self.backend == null) self.backend = nil;
        return self.$raise($$$('NotImplementedError'), "" + (self.$class()) + " (backend: " + (self.backend) + ") must implement the #" + ("convert") + " method");
      }, -2);
      
      $def(self, '$handles?', $return_val(true));
      $defs(self, '$derive_backend_traits', function $$derive_backend_traits(backend, basebackend) {
        var outfilesuffix = nil, $ret_or_1 = nil, filetype = nil;

        
        if (basebackend == null) basebackend = nil;
        if (!$truthy(backend)) {
          return $hash2([], {})
        }        if ($truthy((outfilesuffix = $$('DEFAULT_EXTENSIONS')['$[]']((basebackend = ($truthy(($ret_or_1 = basebackend)) ? ($ret_or_1) : (backend.$sub($$('TrailingDigitsRx'), "")))))))) {
          filetype = outfilesuffix.$slice(1, outfilesuffix.$length());
        } else {
          outfilesuffix = "." + ((filetype = basebackend));
        }        if ($eqeq(filetype, "html")) {
          return $hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix"], {"basebackend": basebackend, "filetype": filetype, "htmlsyntax": "html", "outfilesuffix": outfilesuffix})
        } else {
          return $hash2(["basebackend", "filetype", "outfilesuffix"], {"basebackend": basebackend, "filetype": filetype, "outfilesuffix": outfilesuffix})
        }      }, -2);
      (function($base, $parent_nesting) {
        var self = $module($base, 'BackendTraits');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$basebackend', function $$basebackend(value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            
            return ($a = ["basebackend", value], $send(self.$backend_traits(value), '[]=', $a), $a[$a.length - 1]);
          } else {
            return self.$backend_traits()['$[]']("basebackend")
          }        }, -1);
        
        $def(self, '$filetype', function $$filetype(value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            
            return ($a = ["filetype", value], $send(self.$backend_traits(), '[]=', $a), $a[$a.length - 1]);
          } else {
            return self.$backend_traits()['$[]']("filetype")
          }        }, -1);
        
        $def(self, '$htmlsyntax', function $$htmlsyntax(value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            
            return ($a = ["htmlsyntax", value], $send(self.$backend_traits(), '[]=', $a), $a[$a.length - 1]);
          } else {
            return self.$backend_traits()['$[]']("htmlsyntax")
          }        }, -1);
        
        $def(self, '$outfilesuffix', function $$outfilesuffix(value) {
          var $a, self = this;

          
          if (value == null) value = nil;
          if ($truthy(value)) {
            
            return ($a = ["outfilesuffix", value], $send(self.$backend_traits(), '[]=', $a), $a[$a.length - 1]);
          } else {
            return self.$backend_traits()['$[]']("outfilesuffix")
          }        }, -1);
        
        $def(self, '$supports_templates', function $$supports_templates(value) {
          var $a, self = this;

          
          if (value == null) value = true;
          return ($a = ["supports_templates", value], $send(self.$backend_traits(), '[]=', $a), $a[$a.length - 1]);
        }, -1);
        
        $def(self, '$supports_templates?', function $BackendTraits_supports_templates$ques$1() {
          var self = this;

          return self.$backend_traits()['$[]']("supports_templates")
        });
        
        $def(self, '$init_backend_traits', function $$init_backend_traits(value) {
          var self = this, $ret_or_1 = nil;

          
          if (value == null) value = nil;
          return (self.backend_traits = ($truthy(($ret_or_1 = value)) ? ($ret_or_1) : ($hash2([], {}))));
        }, -1);
        
        $def(self, '$backend_traits', function $$backend_traits(basebackend) {
          var self = this, $ret_or_1 = nil;
          if (self.backend_traits == null) self.backend_traits = nil;
          if (self.backend == null) self.backend = nil;

          
          if (basebackend == null) basebackend = nil;
          return (self.backend_traits = ($truthy(($ret_or_1 = self.backend_traits)) ? ($ret_or_1) : ($$('Converter').$derive_backend_traits(self.backend, basebackend))));
        }, -1);
        $alias(self, "backend_info", "backend_traits");
        return $defs(self, '$derive_backend_traits', function $$derive_backend_traits(backend, basebackend) {
          
          
          if (basebackend == null) basebackend = nil;
          return $$('Converter').$derive_backend_traits(backend, basebackend);
        }, -2);
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Config');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$register_for', function $$register_for($a) {
          var $post_args, backends, self = this;

          
          $post_args = $slice(arguments);
          backends = $post_args;
          return $send($$('Converter'), 'register', [self].concat($to_a($send(backends, 'map', [], function $$2(backend){
            
            if (backend == null) backend = nil;
            return backend.$to_s();}))));
        }, -1)
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        $defs(self, '$new', function $Factory_new$3($a, $b) {
          var $post_args, $kwargs, converters, proxy_default;

          
          $post_args = $slice(arguments);
          $kwargs = $extract_kwargs($post_args);
          $kwargs = $ensure_kwargs($kwargs);
          
          if ($post_args.length > 0) converters = $post_args.shift();if (converters == null) converters = nil;
          
          proxy_default = $kwargs.$$smap["proxy_default"];if (proxy_default == null) proxy_default = true;
          if ($truthy(proxy_default)) {
            
            return $$('DefaultFactoryProxy').$new(converters);
          } else {
            
            return $$('CustomFactory').$new(converters);
          }        }, -1);
        $defs(self, '$default', function $Factory_default$4($a) {

          
          $slice(arguments);
          return $$('Converter');
        }, -1);
        $defs(self, '$create', function $$create(backend, opts) {
          var self = this;

          
          if (opts == null) opts = $hash2([], {});
          return self.$default().$create(backend, opts);
        }, -2);
        
        $def(self, '$register', function $$register(converter, $a) {
          var $post_args, backends, self = this;

          
          $post_args = $slice(arguments, 1);
          backends = $post_args;
          return $send(backends, 'each', [], function $$5(backend){var $b, self = $$5.$$s == null ? this : $$5.$$s;

            
            if (backend == null) backend = nil;
            if ($eqeq(backend, "*")) {
              
              return ($b = [converter], $send(self.$registry(), 'default=', $b), $b[$b.length - 1]);
            } else {
              
              return ($b = [backend, converter], $send(self.$registry(), '[]=', $b), $b[$b.length - 1]);
            }}, {$$s: self});
        }, -2);
        
        $def(self, '$for', function $Factory_for$6(backend) {
          var self = this;

          return self.$registry()['$[]'](backend)
        });
        
        $def(self, '$create', function $$create(backend, opts) {
          var self = this, converter = nil, template_dirs = nil, delegate_backend = nil;

          
          if (opts == null) opts = $hash2([], {});
          if ($truthy((converter = self.$for(backend)))) {
            
            if ($eqeqeq($Class, converter)) {
              converter = converter.$new(backend, opts);
            }            if ((($truthy((template_dirs = opts['$[]']("template_dirs"))) && ($eqeqeq($$('BackendTraits'), converter))) && ($truthy(converter['$supports_templates?']())))) {
              return $$('CompositeConverter').$new(backend, $$('TemplateConverter').$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], {"backend_traits_source": converter}))
            } else {
              return converter
            }          } else if ($truthy((template_dirs = opts['$[]']("template_dirs")))) {
            if (($truthy((delegate_backend = opts['$[]']("delegate_backend"))) && ($truthy((converter = self.$for(delegate_backend)))))) {
              
              if ($eqeqeq($Class, converter)) {
                converter = converter.$new(delegate_backend, opts);
              }              return $$('CompositeConverter').$new(backend, $$('TemplateConverter').$new(backend, template_dirs, opts), converter, $hash2(["backend_traits_source"], {"backend_traits_source": converter}));
            } else {
              return $$('TemplateConverter').$new(backend, template_dirs, opts)
            }
          } else {
            return nil
          }        }, -2);
        
        $def(self, '$converters', function $$converters() {
          var self = this;

          return self.$registry().$merge()
        });
        self.$private();
        return $def(self, '$registry', function $$registry() {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('Factory')) + " subclass " + (self.$class()) + " must implement the #" + ("registry") + " method")
        });
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CustomFactory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('Factory'));
        
        $def(self, '$initialize', function $$initialize(seed_registry) {
          var self = this;

          
          if (seed_registry == null) seed_registry = nil;
          if ($truthy(seed_registry)) {
            
            seed_registry['$default='](seed_registry.$delete("*"));
            return (self.registry = seed_registry);
          } else {
            return (self.registry = $hash2([], {}))
          }        }, -1);
        
        $def(self, '$unregister_all', function $$unregister_all() {
          var $a, self = this;

          return ($a = [nil], $send(self.$registry().$clear(), 'default=', $a), $a[$a.length - 1])
        });
        self.$private();
        return self.$attr_reader("registry");
      })($nesting[0], null, $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DefaultFactory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('Factory'));
        self.$private();
        $class_variable_set($nesting[0], '@@registry', $hash2([], {}));
        
        $def(self, '$registry', function $$registry() {
          
          return $class_variable_get($nesting[0], '@@registry', false)
        });
        return nil;
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DefaultFactoryProxy');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DefaultFactory'));
        return nil;
      })($nesting[0], $$('CustomFactory'), $nesting);
      $defs(self, '$included', function $$included(into) {
        
        
        into.$send("include", $$('BackendTraits'));
        return into.$extend($$('Config'));
      });
      self.$private_class_method("included");
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.backend = nil;
        
        self.$include($$('Logging'));
        self.$include($$('Converter'));
        
        $def(self, '$convert', function $$convert(node, transform, opts) {
          var self = this, ex = nil;
          if ($gvars["!"] == null) $gvars["!"] = nil;

          
          if (transform == null) transform = node.$node_name();
          if (opts == null) opts = nil;
          try {
            if ($truthy(opts)) {
              
              return self.$send($rb_plus("convert_", transform), node, opts);
            } else {
              
              return self.$send($rb_plus("convert_", transform), node);
            }
          } catch ($err) {
            if (Opal.rescue($err, [$$('StandardError')])) {
              try {
                
                if (!(($eqeqeq($$$('NoMethodError'), (ex = $gvars["!"])) && ($eqeq(ex.$receiver(), self))) && ($eqeq(ex.$name().$to_s(), transform)))) {
                  self.$raise();
                };
                self.$logger().$warn("missing convert handler for " + (ex.$name()) + " node in " + (self.backend) + " backend (" + (self.$class()) + ")");
                return nil;
              } finally { Opal.pop_exception(); }
            } else { throw $err; }
          }        }, -2);
        
        $def(self, '$handles?', function $Base_handles$ques$7(transform) {
          var self = this;

          return self['$respond_to?']("convert_" + (transform))
        });
        
        $def(self, '$content_only', function $$content_only(node) {
          
          return node.$content()
        });
        return $def(self, '$skip', $return_val(nil));
      })($nesting[0], null, $nesting);
      return self.$extend($$('DefaultFactory'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/document"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $alias = Opal.alias, $truthy = Opal.truthy, $def = Opal.def, $hash2 = Opal.hash2, $not = Opal.not, $to_ary = Opal.to_ary, $return_ivar = Opal.return_ivar, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_minus = Opal.rb_minus, $eqeq = Opal.eqeq, $eqeqeq = Opal.eqeqeq, $hash = Opal.hash, $rb_ge = Opal.rb_ge, $rb_plus = Opal.rb_plus, $neqeq = Opal.neqeq, $thrower = Opal.thrower, $rb_gt = Opal.rb_gt, $rb_lt = Opal.rb_lt, $gvars = Opal.gvars, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('new,target,attr_reader,nil?,<<,[],[]=,main,include?,strip,squeeze,gsub,!,empty?,rpartition,attr_accessor,catalog,delete,base_dir,options,merge,instance_variable_get,attributes,safe,compat_mode,outfilesuffix,sourcemap,path_resolver,converter,extensions,syntax_highlighter,each,end_with?,start_with?,slice,-,length,chop,==,downcase,===,extname,value_for_name,key?,freeze,attribute_undefined,attribute_missing,update,&,keys,name_for_value,expand_path,pwd,to_s,>=,+,abs,to_i,delete_if,update_doctype_attributes,cursor,parse,restore_attributes,update_backend_attributes,fetch,fill_datetime_attributes,activate,groups,create,to_proc,preprocessors?,preprocessors,process_method,tree_processors?,tree_processors,!=,counter,nil_or_empty?,attribute_locked?,nextval,value,save_to,increment_and_store_counter,register,tap,xreftext,>,source,source_lines,doctitle,sectname=,title=,first_section,title,reftext,<,find,context,header?,assign_numeral,clear_playback_attributes,save_attributes,name,negate,rewind,replace,apply_attribute_value_subs,delete?,start,doctype,content_model,warn,logger,content,convert,postprocessors?,postprocessors,record,write,respond_to?,chomp,class,write_alternate_pages,map,split,resolve_docinfo_subs,normalize_system_path,read_asset,apply_subs,docinfo_processors?,join,concat,compact,docinfo_processors,object_id,inspect,size,private,=~,resolve_pass_subs,apply_header_subs,limit_bytesize,bytesize,valid_encoding?,byteslice,resolve_subs,utc,at,Integer,now,index,strftime,year,utc_offset,partition,create_converter,basebackend,filetype,htmlsyntax,derive_backend_traits,raise');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Document');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.attributes = $proto.safe = $proto.sourcemap = $proto.reader = $proto.base_dir = $proto.parsed = $proto.parent_document = $proto.extensions = $proto.options = $proto.counters = $proto.catalog = $proto.reftexts = $proto.next_section_index = $proto.header = $proto.blocks = $proto.header_attributes = $proto.attributes_modified = $proto.backend = $proto.attribute_overrides = $proto.timings = $proto.converter = $proto.outfilesuffix = $proto.docinfo_processor_extensions = $proto.document = $proto.max_attribute_value_size = $proto.id = $proto.doctype = nil;
      
      $const_set($nesting[0], 'ImageReference', $send($$$('Struct'), 'new', ["target", "imagesdir"], function $Document$1(){var self = $Document$1.$$s == null ? this : $Document$1.$$s;

        return $alias(self, "to_s", "target")}, {$$s: self}));
      $const_set($nesting[0], 'Footnote', $$$('Struct').$new("index", "id", "text"));
      (function($base, $super) {
        var self = $klass($base, $super, 'AttributeEntry');

        
        
        self.$attr_reader("name", "value", "negate");
        
        $def(self, '$initialize', function $$initialize(name, value, negate) {
          var self = this;

          
          if (negate == null) negate = nil;
          self.name = name;
          self.value = value;
          return (self.negate = ($truthy(negate['$nil?']()) ? (value['$nil?']()) : (negate)));
        }, -3);
        return $def(self, '$save_to', function $$save_to(block_attributes) {
          var $a, self = this, $ret_or_1 = nil;

          
          ($truthy(($ret_or_1 = block_attributes['$[]']("attribute_entries"))) ? ($ret_or_1) : (($a = ["attribute_entries", []], $send(block_attributes, '[]=', $a), $a[$a.length - 1])))['$<<'](self);
          return self;
        });
      })($nesting[0], null);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Title');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.subtitle = nil;
        
        self.$attr_reader("main");
        $alias(self, "title", "main");
        self.$attr_reader("subtitle");
        self.$attr_reader("combined");
        
        $def(self, '$initialize', function $$initialize(val, opts) {
          var $a, $b, self = this, sep = nil, $ret_or_1 = nil;

          
          if (opts == null) opts = $hash2([], {});
          if (($truthy((self.sanitized = opts['$[]']("sanitize"))) && ($truthy(val['$include?']("<"))))) {
            val = val.$gsub($$('XmlSanitizeRx'), "").$squeeze(" ").$strip();
          }          if (($truthy((sep = ($truthy(($ret_or_1 = opts['$[]']("separator"))) ? ($ret_or_1) : (":")))['$empty?']()) || ($not(val['$include?']((sep = "" + (sep) + " ")))))) {
            
            self.main = val;
            self.subtitle = nil;
          } else {
            $b = val.$rpartition(sep), $a = $to_ary($b), (self.main = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (self.subtitle = ($a[2] == null ? nil : $a[2]));
          }          return (self.combined = val);
        }, -2);
        
        $def(self, '$sanitized?', $return_ivar("sanitized"));
        
        $def(self, '$subtitle?', function $Title_subtitle$ques$2() {
          var self = this;

          if ($truthy(self.subtitle)) {
            return true
          } else {
            return false
          }
        });
        return $def(self, '$to_s', $return_ivar("combined"));
      })($nesting[0], null, $nesting);
      $const_set($nesting[0], 'Author', $$$('Struct').$new("name", "firstname", "middlename", "lastname", "initials", "email"));
      self.$attr_reader("safe");
      self.$attr_reader("compat_mode");
      self.$attr_reader("backend");
      self.$attr_reader("doctype");
      self.$attr_accessor("sourcemap");
      self.$attr_reader("catalog");
      $alias(self, "references", "catalog");
      self.$attr_reader("counters");
      self.$attr_reader("header");
      self.$attr_reader("base_dir");
      self.$attr_reader("options");
      self.$attr_reader("outfilesuffix");
      self.$attr_reader("parent_document");
      self.$attr_reader("reader");
      self.$attr_reader("path_resolver");
      self.$attr_reader("converter");
      self.$attr_reader("syntax_highlighter");
      self.$attr_reader("extensions");
      
      $def(self, '$initialize', function $$initialize(data, options) {
        var $b, $c, $d, $e; $$initialize.$$p || nil; var self = this, parent_doc = nil, $ret_or_1 = nil, attr_overrides = nil, parent_doctype = nil, initialize_extensions = nil, to_file = nil, safe_mode = nil, input_mtime = nil, standalone = nil, attrs = nil, safe_mode_name = nil, base_dir_val = nil, backend_val = nil, doctype_val = nil, size = nil, initial_backend = nil, ext_registry = nil, ext_block = nil;

        $$initialize.$$p = null;
        
        if (data == null) data = nil;
        if (options == null) options = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [self, "document"], null);
        if ($truthy((parent_doc = options.$delete("parent")))) {
          
          self.parent_document = parent_doc;
          if ($truthy(($ret_or_1 = options['$[]']("base_dir")))) ; else {
            options['$[]=']("base_dir", parent_doc.$base_dir());
          }          if ($truthy(parent_doc.$options()['$[]']("catalog_assets"))) {
            options['$[]=']("catalog_assets", true);
          }          if ($truthy(parent_doc.$options()['$[]']("to_dir"))) {
            options['$[]=']("to_dir", parent_doc.$options()['$[]']("to_dir"));
          }          self.catalog = parent_doc.$catalog().$merge($hash2(["footnotes"], {"footnotes": []}));
          self.attribute_overrides = (attr_overrides = parent_doc.$instance_variable_get("@attribute_overrides").$merge(parent_doc.$attributes()));
          attr_overrides.$delete("compat-mode");
          parent_doctype = attr_overrides.$delete("doctype");
          attr_overrides.$delete("notitle");
          attr_overrides.$delete("showtitle");
          attr_overrides.$delete("toc");
          self.attributes['$[]=']("toc-placement", ($truthy(($ret_or_1 = attr_overrides.$delete("toc-placement"))) ? ($ret_or_1) : ("auto")));
          attr_overrides.$delete("toc-position");
          self.safe = parent_doc.$safe();
          if ($truthy((self.compat_mode = parent_doc.$compat_mode()))) {
            self.attributes['$[]=']("compat-mode", "");
          }          self.outfilesuffix = parent_doc.$outfilesuffix();
          self.sourcemap = parent_doc.$sourcemap();
          self.timings = nil;
          self.path_resolver = parent_doc.$path_resolver();
          self.converter = parent_doc.$converter();
          initialize_extensions = nil;
          self.extensions = parent_doc.$extensions();
          self.syntax_highlighter = parent_doc.$syntax_highlighter();
        } else {
          
          self.parent_document = nil;
          self.catalog = $hash2(["ids", "refs", "footnotes", "links", "images", "callouts", "includes"], {"ids": $hash2([], {}), "refs": $hash2([], {}), "footnotes": [], "links": [], "images": [], "callouts": $$('Callouts').$new(), "includes": $hash2([], {})});
          self.attribute_overrides = (attr_overrides = $hash2([], {}));
          $send(($truthy(($ret_or_1 = options['$[]']("attributes"))) ? ($ret_or_1) : ($hash2([], {}))), 'each', [], function $$3(key, val){var $a;

            
            if (key == null) key = nil;
            if (val == null) val = nil;
            if ($truthy(key['$end_with?']("@"))) {
              if ($truthy(key['$start_with?']("!"))) {
                $a = [key.$slice(1, $rb_minus(key.$length(), 2)), false], (key = $a[0]), (val = $a[1]);
              } else if ($truthy(key['$end_with?']("!@"))) {
                $a = [key.$slice(0, $rb_minus(key.$length(), 2)), false], (key = $a[0]), (val = $a[1]);
              } else {
                $a = [key.$chop(), "" + (val) + "@"], (key = $a[0]), (val = $a[1]);
              }
            } else if ($truthy(key['$start_with?']("!"))) {
              $a = [key.$slice(1, key.$length()), ($eqeq(val, "@") ? (false) : (nil))], (key = $a[0]), (val = $a[1]);
            } else if ($truthy(key['$end_with?']("!"))) {
              $a = [key.$chop(), ($eqeq(val, "@") ? (false) : (nil))], (key = $a[0]), (val = $a[1]);
            }            return ($a = [key.$downcase(), val], $send(attr_overrides, '[]=', $a), $a[$a.length - 1]);});
          if ($eqeqeq($$$('String'), (to_file = options['$[]']("to_file")))) {
            attr_overrides['$[]=']("outfilesuffix", $$('Helpers').$extname(to_file));
          }          if ($not((safe_mode = options['$[]']("safe")))) {
            self.safe = $$$($$('SafeMode'), 'SECURE');
          } else if ($eqeqeq($$$('Integer'), safe_mode)) {
            self.safe = safe_mode;
          } else {
            self.safe = (function() { try {
              
              return $$('SafeMode').$value_for_name(safe_mode);
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  return $$$($$('SafeMode'), 'SECURE')
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }})();
          }          input_mtime = options.$delete("input_mtime");
          self.compat_mode = attr_overrides['$key?']("compat-mode");
          self.sourcemap = options['$[]']("sourcemap");
          self.timings = options.$delete("timings");
          self.path_resolver = $$('PathResolver').$new();
          initialize_extensions = (($truthy((($b = $$$('::', 'Asciidoctor', 'skip_raise')) && ($$$($b, 'Extensions', 'skip_raise')) ? 'constant' : nil)) || ($truthy(options['$key?']("extensions")))) ? ($$$($$$('Asciidoctor'), 'Extensions')) : (nil));
          self.extensions = nil;
          if (($truthy(options['$key?']("header_footer")) && ($not(options['$key?']("standalone"))))) {
            options['$[]=']("standalone", options['$[]']("header_footer"));
          }        }        self.parsed = (self.reftexts = (self.header = (self.header_attributes = nil)));
        self.counters = $hash2([], {});
        self.attributes_modified = $$$('Set').$new();
        self.docinfo_processor_extensions = $hash2([], {});
        standalone = options['$[]']("standalone");
        (self.options = options).$freeze();
        attrs = self.attributes;
        if (!$truthy(parent_doc)) {
          
          attrs['$[]=']("attribute-undefined", $$('Compliance').$attribute_undefined());
          attrs['$[]=']("attribute-missing", $$('Compliance').$attribute_missing());
          attrs.$update($$('DEFAULT_ATTRIBUTES'));
        }        if ($truthy(standalone)) {
          
          attr_overrides['$[]=']("embedded", nil);
          attrs['$[]=']("copycss", "");
          attrs['$[]=']("iconfont-remote", "");
          attrs['$[]=']("stylesheet", "");
          attrs['$[]=']("webfonts", "");
        } else {
          
          attr_overrides['$[]=']("embedded", "");
          if (($truthy(attr_overrides['$key?']("showtitle")) && ($eqeq(attr_overrides.$keys()['$&'](["notitle", "showtitle"])['$[]'](-1), "showtitle")))) {
            attr_overrides['$[]=']("notitle", $hash(nil, "", false, "@", "@", false)['$[]'](attr_overrides['$[]']("showtitle")));
          } else if ($truthy(attr_overrides['$key?']("notitle"))) {
            attr_overrides['$[]=']("showtitle", $hash(nil, "", false, "@", "@", false)['$[]'](attr_overrides['$[]']("notitle")));
          } else {
            attrs['$[]=']("notitle", "");
          }        }        attr_overrides['$[]=']("asciidoctor", "");
        attr_overrides['$[]=']("asciidoctor-version", $$$($$$('Asciidoctor'), 'VERSION'));
        attr_overrides['$[]=']("safe-mode-name", (safe_mode_name = $$('SafeMode').$name_for_value(self.safe)));
        attr_overrides['$[]=']("safe-mode-" + (safe_mode_name), "");
        attr_overrides['$[]=']("safe-mode-level", self.safe);
        if ($truthy(($ret_or_1 = attr_overrides['$[]']("max-include-depth")))) ; else {
          attr_overrides['$[]=']("max-include-depth", 64);
        }        if ($truthy(($ret_or_1 = attr_overrides['$[]']("allow-uri-read")))) ; else {
          attr_overrides['$[]=']("allow-uri-read", nil);
        }        if ($truthy(attr_overrides['$key?']("numbered"))) {
          attr_overrides['$[]=']("sectnums", attr_overrides.$delete("numbered"));
        }        if ($truthy(attr_overrides['$key?']("hardbreaks"))) {
          attr_overrides['$[]=']("hardbreaks-option", attr_overrides.$delete("hardbreaks"));
        }        if ($truthy((base_dir_val = options['$[]']("base_dir")))) {
          self.base_dir = ($c = ["docdir", $$$('File').$expand_path(base_dir_val)], $send(attr_overrides, '[]=', $c), $c[$c.length - 1]);
        } else if ($truthy(attr_overrides['$[]']("docdir"))) {
          self.base_dir = attr_overrides['$[]']("docdir");
        } else {
          self.base_dir = ($c = ["docdir", $$$('Dir').$pwd()], $send(attr_overrides, '[]=', $c), $c[$c.length - 1]);
        }        if ($truthy((backend_val = options['$[]']("backend")))) {
          attr_overrides['$[]=']("backend", backend_val.$to_s());
        }        if ($truthy((doctype_val = options['$[]']("doctype")))) {
          attr_overrides['$[]=']("doctype", doctype_val.$to_s());
        }        if ($truthy($rb_ge(self.safe, $$$($$('SafeMode'), 'SERVER')))) {
          
          if ($truthy(($ret_or_1 = attr_overrides['$[]']("copycss")))) ; else {
            attr_overrides['$[]=']("copycss", nil);
          }          if ($truthy(($ret_or_1 = attr_overrides['$[]']("source-highlighter")))) ; else {
            attr_overrides['$[]=']("source-highlighter", nil);
          }          if ($truthy(($ret_or_1 = attr_overrides['$[]']("backend")))) ; else {
            attr_overrides['$[]=']("backend", $$('DEFAULT_BACKEND'));
          }          if (($not(parent_doc) && ($truthy(attr_overrides['$key?']("docfile"))))) {
            attr_overrides['$[]=']("docfile", attr_overrides['$[]']("docfile")['$[]'](Opal.Range.$new($rb_plus(attr_overrides['$[]']("docdir").$length(), 1), -1, false)));
          }          attr_overrides['$[]=']("docdir", "");
          if ($truthy(($ret_or_1 = attr_overrides['$[]']("user-home")))) ; else {
            attr_overrides['$[]=']("user-home", ".");
          }          if ($truthy($rb_ge(self.safe, $$$($$('SafeMode'), 'SECURE')))) {
            
            if (!$truthy(attr_overrides['$key?']("max-attribute-value-size"))) {
              attr_overrides['$[]=']("max-attribute-value-size", 4096);
            }            if (!$truthy(attr_overrides['$key?']("linkcss"))) {
              attr_overrides['$[]=']("linkcss", "");
            }            if ($truthy(($ret_or_1 = attr_overrides['$[]']("icons")))) ; else {
              attr_overrides['$[]=']("icons", nil);
            }          }        } else if ($truthy(($ret_or_1 = attr_overrides['$[]']("user-home")))) ; else {
          attr_overrides['$[]=']("user-home", $$('USER_HOME'));
        }        self.max_attribute_value_size = ($truthy((size = ($truthy(($ret_or_1 = attr_overrides['$[]']("max-attribute-value-size"))) ? ($ret_or_1) : (($c = ["max-attribute-value-size", nil], $send(attr_overrides, '[]=', $c), $c[$c.length - 1]))))) ? (size.$to_i().$abs()) : (nil));
        $send(attr_overrides, 'delete_if', [], function $$4(key, val){var $d, verdict = nil;

          
          if (key == null) key = nil;
          if (val == null) val = nil;
          if ($truthy(val)) {
            
            if (($eqeqeq($$$('String'), val) && ($truthy(val['$end_with?']("@"))))) {
              $d = [val.$chop(), true], (val = $d[0]), (verdict = $d[1]);
            }            attrs['$[]='](key, val);
          } else {
            
            attrs.$delete(key);
            verdict = val['$=='](false);
          }          return verdict;});
        if ($truthy(parent_doc)) {
          
          self.backend = attrs['$[]']("backend");
          if (!$eqeq((self.doctype = ($c = ["doctype", parent_doctype], $send(attrs, '[]=', $c), $c[$c.length - 1])), $$('DEFAULT_DOCTYPE'))) {
            self.$update_doctype_attributes($$('DEFAULT_DOCTYPE'));
          }          self.reader = $$('Reader').$new(data, options['$[]']("cursor"));
          if ($truthy(self.sourcemap)) {
            self.source_location = self.reader.$cursor();
          }          $$('Parser').$parse(self.reader, self);
          self.$restore_attributes();
          return (self.parsed = true);
        } else {
          
          self.backend = nil;
          if ($eqeq((initial_backend = ($truthy(($ret_or_1 = attrs['$[]']("backend"))) ? ($ret_or_1) : ($$('DEFAULT_BACKEND')))), "manpage")) {
            self.doctype = ($c = ["doctype", ($d = ["doctype", "manpage"], $send(attr_overrides, '[]=', $d), $d[$d.length - 1])], $send(attrs, '[]=', $c), $c[$c.length - 1]);
          } else {
            self.doctype = ($truthy(($ret_or_1 = attrs['$[]']("doctype"))) ? ($ret_or_1) : (($c = ["doctype", $$('DEFAULT_DOCTYPE')], $send(attrs, '[]=', $c), $c[$c.length - 1])));
          }          self.$update_backend_attributes(initial_backend, true);
          if ($truthy(($ret_or_1 = attrs['$[]']("stylesdir")))) ; else {
            attrs['$[]=']("stylesdir", ".");
          }          if ($truthy(($ret_or_1 = attrs['$[]']("iconsdir")))) ; else {
            attrs['$[]=']("iconsdir", "" + (attrs.$fetch("imagesdir", "./images")) + "/icons");
          }          self.$fill_datetime_attributes(attrs, input_mtime);
          if ($truthy(initialize_extensions)) {
            if ($truthy((ext_registry = options['$[]']("extension_registry")))) {
              if (($eqeqeq($$$($$('Extensions'), 'Registry'), ext_registry) || (($truthy((($e = $$$('::', 'AsciidoctorJ', 'skip_raise')) && ($d = $$$($e, 'Extensions', 'skip_raise')) && ($c = $$$($d, 'ExtensionRegistry', 'skip_raise')) ? 'constant' : nil)) && ($eqeqeq($$$($$$($$$('AsciidoctorJ'), 'Extensions'), 'ExtensionRegistry'), ext_registry)))))) {
                self.extensions = ext_registry.$activate(self);
              }
            } else if ($truthy((ext_block = options['$[]']("extensions"))['$nil?']())) {
              if (!$truthy($$('Extensions').$groups()['$empty?']())) {
                self.extensions = $$$($$('Extensions'), 'Registry').$new().$activate(self);
              }
            } else if ($eqeqeq($$$('Proc'), ext_block)) {
              self.extensions = $send($$('Extensions'), 'create', [], ext_block.$to_proc()).$activate(self);
            }
          }          self.reader = $$('PreprocessorReader').$new(self, data, $$$($$('Reader'), 'Cursor').$new(attrs['$[]']("docfile"), self.base_dir), $hash2(["normalize"], {"normalize": true}));
          if ($truthy(self.sourcemap)) {
            return (self.source_location = self.reader.$cursor())
          } else {
            return nil
          }        }      }, -1);
      
      $def(self, '$parse', function $$parse(data) {
        var self = this, doc = nil, exts = nil;

        
        if (data == null) data = nil;
        if ($truthy(self.parsed)) {
          return self
        } else {
          
          doc = self;
          if ($truthy(data)) {
            
            self.reader = $$('PreprocessorReader').$new(doc, data, $$$($$('Reader'), 'Cursor').$new(self.attributes['$[]']("docfile"), self.base_dir), $hash2(["normalize"], {"normalize": true}));
            if ($truthy(self.sourcemap)) {
              self.source_location = self.reader.$cursor();
            }          }          if (($truthy((exts = ($truthy(self.parent_document) ? (nil) : (self.extensions)))) && ($truthy(exts['$preprocessors?']())))) {
            $send(exts.$preprocessors(), 'each', [], function $$5(ext){var self = $$5.$$s == null ? this : $$5.$$s, $ret_or_1 = nil;
              if (self.reader == null) self.reader = nil;

              
              if (ext == null) ext = nil;
              return (self.reader = ($truthy(($ret_or_1 = ext.$process_method()['$[]'](doc, self.reader))) ? ($ret_or_1) : (self.reader)));}, {$$s: self});
          }          $$('Parser').$parse(self.reader, doc, $hash2(["header_only"], {"header_only": self.options['$[]']("parse_header_only")}));
          self.$restore_attributes();
          if (($truthy(exts) && ($truthy(exts['$tree_processors?']())))) {
            $send(exts.$tree_processors(), 'each', [], function $$6(ext){var result = nil;

              
              if (ext == null) ext = nil;
              if ((($truthy((result = ext.$process_method()['$[]'](doc))) && ($eqeqeq($$('Document'), result))) && ($neqeq(result, doc)))) {
                return (doc = result)
              } else {
                return nil
              }});
          }          self.parsed = true;
          return doc;
        }      }, -1);
      
      $def(self, '$parsed?', $return_ivar("parsed"));
      
      $def(self, '$counter', function $$counter(name, seed) {
        var $a, self = this, curr_val = nil, locked = nil, next_val = nil;

        
        if (seed == null) seed = nil;
        if ($truthy(self.parent_document)) {
          return self.parent_document.$counter(name, seed)
        }        if ((($truthy((locked = self['$attribute_locked?'](name))) && ($truthy((curr_val = self.counters['$[]'](name))))) || ($not((curr_val = self.attributes['$[]'](name))['$nil_or_empty?']())))) {
          next_val = ($a = [name, $$('Helpers').$nextval(curr_val)], $send(self.counters, '[]=', $a), $a[$a.length - 1]);
        } else if ($truthy(seed)) {
          next_val = ($a = [name, ($eqeq(seed, seed.$to_i().$to_s()) ? (seed.$to_i()) : (seed))], $send(self.counters, '[]=', $a), $a[$a.length - 1]);
        } else {
          next_val = ($a = [name, 1], $send(self.counters, '[]=', $a), $a[$a.length - 1]);
        }        if (!$truthy(locked)) {
          self.attributes['$[]='](name, next_val);
        }        return next_val;
      }, -2);
      
      $def(self, '$increment_and_store_counter', function $$increment_and_store_counter(counter_name, block) {
        var self = this;

        return $$('AttributeEntry').$new(counter_name, self.$counter(counter_name)).$save_to(block.$attributes()).$value()
      });
      $alias(self, "counter_increment", "increment_and_store_counter");
      
      $def(self, '$register', function $$register(type, value) {
        var self = this, id = nil, $logical_op_recvr_tmp_1 = nil, ref = nil;

        
        switch (type) {
          case "ids":
            return self.$register("refs", [(id = value['$[]'](0)), $$('Inline').$new(self, "anchor", value['$[]'](1), $hash2(["type", "id"], {"type": "ref", "id": id}))])
          case "refs":
            
            
            $logical_op_recvr_tmp_1 = self.catalog['$[]']("refs");
            if ($truthy(($logical_op_recvr_tmp_1['$[]'](value['$[]'](0))))) ; else {
              $logical_op_recvr_tmp_1['$[]='](value['$[]'](0), (ref = value['$[]'](1)));
            }            return ref;
          case "footnotes":
            return self.catalog['$[]'](type)['$<<'](value)
          default:
            if ($truthy(self.options['$[]']("catalog_assets"))) {
              return self.catalog['$[]'](type)['$<<'](($eqeq(type, "images") ? ($$('ImageReference').$new(value, self.attributes['$[]']("imagesdir"))) : (value)))
            } else {
              return nil
            }
        }
      });
      
      $def(self, '$resolve_id', function $$resolve_id(text) {
        var self = this, resolved_id = nil, accum = nil;

        if ($truthy(self.reftexts)) {
          return self.reftexts['$[]'](text)
        } else if ($truthy(self.parsed)) {
          return $send((self.reftexts = $hash2([], {})), 'tap', [], function $$7(accum){var self = $$7.$$s == null ? this : $$7.$$s;
            if (self.catalog == null) self.catalog = nil;

            
            if (accum == null) accum = nil;
            return $send(self.catalog['$[]']("refs"), 'each', [], function $$8(id, ref){var $a, $ret_or_1 = nil;

              
              if (id == null) id = nil;
              if (ref == null) ref = nil;
              if ($truthy(($ret_or_1 = accum['$[]'](ref.$xreftext())))) {
                return $ret_or_1
              } else {
                return ($a = [ref.$xreftext(), id], $send(accum, '[]=', $a), $a[$a.length - 1])
              }});}, {$$s: self})['$[]'](text)
        } else {
          
          resolved_id = nil;
          self.reftexts = (accum = $hash2([], {}));
          (function(){try { var $t_break = $thrower('break'); return $send(self.catalog['$[]']("refs"), 'each', [], function $$9(id, ref){var $a, xreftext = nil, $ret_or_1 = nil;

            
            if (id == null) id = nil;
            if (ref == null) ref = nil;
            if ($eqeq((xreftext = ref.$xreftext()), text)) {
              
              resolved_id = id;
              $t_break.$throw();
            };
            if ($truthy(($ret_or_1 = accum['$[]'](xreftext)))) {
              return $ret_or_1
            } else {
              return ($a = [xreftext, id], $send(accum, '[]=', $a), $a[$a.length - 1])
            };})} catch($e) {
            if ($e === $t_break) return $e.$v;
            throw $e;
          }})();
          self.reftexts = nil;
          return resolved_id;
        }
      });
      
      $def(self, '$sections?', function $Document_sections$ques$10() {
        var self = this;

        return $rb_gt(self.next_section_index, 0)
      });
      
      $def(self, '$footnotes?', function $Document_footnotes$ques$11() {
        var self = this;

        if ($truthy(self.catalog['$[]']("footnotes")['$empty?']())) {
          return false
        } else {
          return true
        }
      });
      
      $def(self, '$footnotes', function $$footnotes() {
        var self = this;

        return self.catalog['$[]']("footnotes")
      });
      
      $def(self, '$callouts', function $$callouts() {
        var self = this;

        return self.catalog['$[]']("callouts")
      });
      
      $def(self, '$nested?', function $Document_nested$ques$12() {
        var self = this;

        if ($truthy(self.parent_document)) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$embedded?', function $Document_embedded$ques$13() {
        var self = this;

        return self.attributes['$key?']("embedded")
      });
      
      $def(self, '$extensions?', function $Document_extensions$ques$14() {
        var self = this;

        if ($truthy(self.extensions)) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$source', function $$source() {
        var self = this;

        if ($truthy(self.reader)) {
          return self.reader.$source()
        } else {
          return nil
        }
      });
      
      $def(self, '$source_lines', function $$source_lines() {
        var self = this;

        if ($truthy(self.reader)) {
          return self.reader.$source_lines()
        } else {
          return nil
        }
      });
      
      $def(self, '$basebackend?', function $Document_basebackend$ques$15(base) {
        var self = this;

        return self.attributes['$[]']("basebackend")['$=='](base)
      });
      
      $def(self, '$title', function $$title() {
        var self = this;

        return self.$doctitle()
      });
      
      $def(self, '$title=', function $Document_title$eq$16(title) {
        var $a, self = this, sect = nil;

        
        if (!$truthy((sect = self.header))) {
          (sect = (self.header = $$('Section').$new(self, 0)))['$sectname=']("header");
        }        return ($a = [title], $send(sect, 'title=', $a), $a[$a.length - 1]);
      });
      
      $def(self, '$doctitle', function $$doctitle(opts) {
        var self = this, val = nil, sect = nil, $ret_or_1 = nil, separator = nil;

        
        if (opts == null) opts = $hash2([], {});
        if (!$truthy((val = self.attributes['$[]']("title")))) {
          if ($truthy((sect = self.$first_section()))) {
            val = sect.$title();
          } else if ($not(($truthy(($ret_or_1 = opts['$[]']("use_fallback"))) ? ((val = self.attributes['$[]']("untitled-label"))) : ($ret_or_1)))) {
            return nil
          }
        }        if ($truthy((separator = opts['$[]']("partition")))) {
          return $$('Title').$new(val, opts.$merge($hash2(["separator"], {"separator": ($eqeq(separator, true) ? (self.attributes['$[]']("title-separator")) : (separator))})))
        } else if (($truthy(opts['$[]']("sanitize")) && ($truthy(val['$include?']("<"))))) {
          return val.$gsub($$('XmlSanitizeRx'), "").$squeeze(" ").$strip()
        } else {
          return val
        }      }, -1);
      $alias(self, "name", "doctitle");
      
      $def(self, '$xreftext', function $$xreftext(xrefstyle) {
        var self = this, val = nil;
        if (($truthy((val = self.$reftext())) && ($not(val['$empty?']())))) {
          return val
        } else {
          return self.$title()
        }      }, -1);
      
      $def(self, '$author', function $$author() {
        var self = this;

        return self.attributes['$[]']("author")
      });
      
      $def(self, '$authors', function $$authors() {
        var self = this, attrs = nil, authors = nil, num_authors = nil, $ret_or_1 = nil, idx = nil;

        if ($truthy((attrs = self.attributes)['$key?']("author"))) {
          
          authors = [$$('Author').$new(attrs['$[]']("author"), attrs['$[]']("firstname"), attrs['$[]']("middlename"), attrs['$[]']("lastname"), attrs['$[]']("authorinitials"), attrs['$[]']("email"))];
          if ($truthy($rb_gt((num_authors = ($truthy(($ret_or_1 = attrs['$[]']("authorcount"))) ? ($ret_or_1) : (0))), 1))) {
            
            idx = 1;
            while ($truthy($rb_lt(idx, num_authors))) {
            
              idx = $rb_plus(idx, 1);
              authors['$<<']($$('Author').$new(attrs['$[]']("author_" + (idx)), attrs['$[]']("firstname_" + (idx)), attrs['$[]']("middlename_" + (idx)), attrs['$[]']("lastname_" + (idx)), attrs['$[]']("authorinitials_" + (idx)), attrs['$[]']("email_" + (idx))));
            }          }          return authors;
        } else {
          return []
        }
      });
      
      $def(self, '$revdate', function $$revdate() {
        var self = this;

        return self.attributes['$[]']("revdate")
      });
      
      $def(self, '$notitle', function $$notitle() {
        var self = this;

        return self.attributes['$key?']("notitle")
      });
      
      $def(self, '$noheader', function $$noheader() {
        var self = this;

        return self.attributes['$key?']("noheader")
      });
      
      $def(self, '$nofooter', function $$nofooter() {
        var self = this;

        return self.attributes['$key?']("nofooter")
      });
      
      $def(self, '$first_section', function $$first_section() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.header))) {
          return $ret_or_1
        } else {
          return $send(self.blocks, 'find', [], function $$17(e){
            
            if (e == null) e = nil;
            return e.$context()['$==']("section");})
        }
      });
      
      $def(self, '$header?', function $Document_header$ques$18() {
        var self = this;

        if ($truthy(self.header)) {
          return true
        } else {
          return false
        }
      });
      $alias(self, "has_header?", "header?");
      
      $def(self, '$<<', function $Document_$lt$lt$19(block) {
        var $yield = $Document_$lt$lt$19.$$p || nil, self = this;

        $Document_$lt$lt$19.$$p = null;
        
        if ($eqeq(block.$context(), "section")) {
          self.$assign_numeral(block);
        }        return $send2(self, $find_super(self, '<<', $Document_$lt$lt$19, false, true), '<<', [block], $yield);
      });
      
      $def(self, '$finalize_header', function $$finalize_header(unrooted_attributes, header_valid) {
        var self = this;

        
        if (header_valid == null) header_valid = true;
        self.$clear_playback_attributes(unrooted_attributes);
        self.$save_attributes();
        if (!$truthy(header_valid)) {
          unrooted_attributes['$[]=']("invalid-header", true);
        }        return unrooted_attributes;
      }, -2);
      
      $def(self, '$playback_attributes', function $$playback_attributes(block_attributes) {
        var self = this;

        if ($truthy(block_attributes['$key?']("attribute_entries"))) {
          return $send(block_attributes['$[]']("attribute_entries"), 'each', [], function $$20(entry){var self = $$20.$$s == null ? this : $$20.$$s, name = nil;
            if (self.attributes == null) self.attributes = nil;

            
            if (entry == null) entry = nil;
            name = entry.$name();
            if ($truthy(entry.$negate())) {
              
              self.attributes.$delete(name);
              if ($eqeq(name, "compat-mode")) {
                return (self.compat_mode = false)
              } else {
                return nil
              }            } else {
              
              self.attributes['$[]='](name, entry.$value());
              if ($eqeq(name, "compat-mode")) {
                return (self.compat_mode = true)
              } else {
                return nil
              }            }}, {$$s: self})
        } else {
          return nil
        }
      });
      
      $def(self, '$restore_attributes', function $$restore_attributes() {
        var self = this;

        
        if (!$truthy(self.parent_document)) {
          self.catalog['$[]']("callouts").$rewind();
        }        return self.attributes.$replace(self.header_attributes);
      });
      
      $def(self, '$set_attribute', function $$set_attribute(name, value) {
        var self = this, $ret_or_2 = nil;

        
        if (value == null) value = "";
        if ($truthy(self['$attribute_locked?'](name))) {
          return nil
        } else {
          
          if (!$truthy(value['$empty?']())) {
            value = self.$apply_attribute_value_subs(value);
          }          if ($truthy(self.header_attributes)) {
            self.attributes['$[]='](name, value);
          } else {
            
            
            switch (name) {
              case "backend":
                self.$update_backend_attributes(value, ($truthy(($ret_or_2 = self.attributes_modified['$delete?']("htmlsyntax"))) ? (value['$=='](self.backend)) : ($ret_or_2)));
                break;
              case "doctype":
                self.$update_doctype_attributes(value);
                break;
              default:
                self.attributes['$[]='](name, value);
            }            self.attributes_modified['$<<'](name);
          }          return value;
        }      }, -2);
      
      $def(self, '$delete_attribute', function $$delete_attribute(name) {
        var self = this;

        if ($truthy(self['$attribute_locked?'](name))) {
          return false
        } else {
          
          self.attributes.$delete(name);
          self.attributes_modified['$<<'](name);
          return true;
        }
      });
      
      $def(self, '$attribute_locked?', function $Document_attribute_locked$ques$21(name) {
        var self = this;

        return self.attribute_overrides['$key?'](name)
      });
      
      $def(self, '$set_header_attribute', function $$set_header_attribute(name, value, overwrite) {
        var self = this, attrs = nil, $ret_or_1 = nil;

        
        if (value == null) value = "";
        if (overwrite == null) overwrite = true;
        attrs = ($truthy(($ret_or_1 = self.header_attributes)) ? ($ret_or_1) : (self.attributes));
        if (($eqeq(overwrite, false) && ($truthy(attrs['$key?'](name))))) {
          return false
        } else {
          
          attrs['$[]='](name, value);
          return true;
        }      }, -2);
      
      $def(self, '$convert', function $$convert(opts) {
        var $a, self = this, block = nil, $ret_or_1 = nil, output = nil, transform = nil, exts = nil;

        
        if (opts == null) opts = $hash2([], {});
        if ($truthy(self.timings)) {
          self.timings.$start("convert");
        }        if (!$truthy(self.parsed)) {
          self.$parse();
        }        if (!($truthy($rb_ge(self.safe, $$$($$('SafeMode'), 'SERVER'))) || ($truthy(opts['$empty?']())))) {
          
          if (!$truthy(($a = ["outfile", opts['$[]']("outfile")], $send(self.attributes, '[]=', $a), $a[$a.length - 1]))) {
            self.attributes.$delete("outfile");
          }          if (!$truthy(($a = ["outdir", opts['$[]']("outdir")], $send(self.attributes, '[]=', $a), $a[$a.length - 1]))) {
            self.attributes.$delete("outdir");
          }        }        if ($eqeq(self.$doctype(), "inline")) {
          if ($truthy((block = ($truthy(($ret_or_1 = self.blocks['$[]'](0))) ? ($ret_or_1) : (self.header))))) {
            if (($eqeq(block.$content_model(), "compound") || ($eqeq(block.$content_model(), "empty")))) {
              self.$logger().$warn("no inline candidate; use the inline doctype to convert a single paragragh, verbatim, or raw block");
            } else {
              output = block.$content();
            }
          }
        } else {
          
          if ($truthy(opts['$key?']("standalone"))) {
            transform = ($truthy(opts['$[]']("standalone")) ? ("document") : ("embedded"));
          } else if ($truthy(opts['$key?']("header_footer"))) {
            transform = ($truthy(opts['$[]']("header_footer")) ? ("document") : ("embedded"));
          } else {
            transform = ($truthy(self.options['$[]']("standalone")) ? ("document") : ("embedded"));
          }          output = self.converter.$convert(self, transform);
        }        if (!$truthy(self.parent_document)) {
          if (($truthy((exts = self.extensions)) && ($truthy(exts['$postprocessors?']())))) {
            $send(exts.$postprocessors(), 'each', [], function $$22(ext){var self = $$22.$$s == null ? this : $$22.$$s;

              
              if (ext == null) ext = nil;
              return (output = ext.$process_method()['$[]'](self, output));}, {$$s: self});
          }
        }        if ($truthy(self.timings)) {
          self.timings.$record("convert");
        }        return output;
      }, -1);
      $alias(self, "render", "convert");
      
      $def(self, '$write', function $$write(output, target) {
        var self = this;

        
        if ($truthy(self.timings)) {
          self.timings.$start("write");
        }        if ($eqeqeq($$('Writer'), self.converter)) {
          self.converter.$write(output, target);
        } else {
          
          if ($truthy(target['$respond_to?']("write"))) {
            if (!$truthy(output['$nil_or_empty?']())) {
              
              target.$write(output.$chomp());
              target.$write($$('LF'));
            }
          } else {
            $$$('File').$write(target, output, $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
          }          if ((($eqeq(self.backend, "manpage") && ($eqeqeq($$$('String'), target))) && ($truthy(self.converter.$class()['$respond_to?']("write_alternate_pages"))))) {
            self.converter.$class().$write_alternate_pages(self.attributes['$[]']("mannames"), self.attributes['$[]']("manvolnum"), target);
          }        }        if ($truthy(self.timings)) {
          self.timings.$record("write");
        }        return nil;
      });
      
      $def(self, '$content', function $$content() {
        var $yield = $$content.$$p || nil, self = this;

        $$content.$$p = null;
        
        self.attributes.$delete("title");
        return $send2(self, $find_super(self, 'content', $$content, false, true), 'content', [], $yield);
      });
      
      $def(self, '$docinfo', function $$docinfo(location, suffix) {
        var $a, self = this, qualifier = nil, $ret_or_1 = nil, docinfo = nil, content = nil, docinfo_file = nil, docinfo_dir = nil, docinfo_subs = nil, docinfo_path = nil, shared_docinfo = nil, private_docinfo = nil;

        
        if (location == null) location = "head";
        if (suffix == null) suffix = nil;
        if ($truthy($rb_lt(self.$safe(), $$$($$('SafeMode'), 'SECURE')))) {
          
          if (!$eqeq(location, "head")) {
            qualifier = "-" + (location);
          }          suffix = ($truthy(($ret_or_1 = suffix)) ? ($ret_or_1) : (self.outfilesuffix));
          if ($truthy((docinfo = self.attributes['$[]']("docinfo"))['$nil_or_empty?']())) {
            if ($truthy(self.attributes['$key?']("docinfo2"))) {
              docinfo = ["private", "shared"];
            } else if ($truthy(self.attributes['$key?']("docinfo1"))) {
              docinfo = ["shared"];
            } else {
              docinfo = ($truthy(docinfo) ? (["private"]) : (nil));
            }
          } else {
            docinfo = $send(docinfo.$split(","), 'map', [], function $$23(it){
              
              if (it == null) it = nil;
              return it.$strip();});
          }          if ($truthy(docinfo)) {
            
            content = [];
            $a = ["docinfo" + (qualifier) + (suffix), self.attributes['$[]']("docinfodir"), self.$resolve_docinfo_subs()], (docinfo_file = $a[0]), (docinfo_dir = $a[1]), (docinfo_subs = $a[2]);
            if (!$truthy(docinfo['$&'](["shared", "shared-" + (location)])['$empty?']())) {
              
              docinfo_path = self.$normalize_system_path(docinfo_file, docinfo_dir);
              if ($truthy((shared_docinfo = self.$read_asset(docinfo_path, $hash2(["normalize"], {"normalize": true}))))) {
                content['$<<'](self.$apply_subs(shared_docinfo, docinfo_subs));
              }            }            if (!($truthy(self.attributes['$[]']("docname")['$nil_or_empty?']()) || ($truthy(docinfo['$&'](["private", "private-" + (location)])['$empty?']())))) {
              
              docinfo_path = self.$normalize_system_path("" + (self.attributes['$[]']("docname")) + "-" + (docinfo_file), docinfo_dir);
              if ($truthy((private_docinfo = self.$read_asset(docinfo_path, $hash2(["normalize"], {"normalize": true}))))) {
                content['$<<'](self.$apply_subs(private_docinfo, docinfo_subs));
              }            }          }        }        if (($truthy(self.extensions) && ($truthy(self['$docinfo_processors?'](location))))) {
          return ($truthy(($ret_or_1 = content)) ? ($ret_or_1) : ([])).$concat($send(self.docinfo_processor_extensions['$[]'](location), 'map', [], function $$24(ext){var self = $$24.$$s == null ? this : $$24.$$s;

            
            if (ext == null) ext = nil;
            return ext.$process_method()['$[]'](self);}, {$$s: self}).$compact()).$join($$('LF'))
        } else if ($truthy(content)) {
          return content.$join($$('LF'))
        } else {
          return ""
        }      }, -1);
      
      $def(self, '$docinfo_processors?', function $Document_docinfo_processors$ques$25(location) {
        var $a, self = this;

        
        if (location == null) location = "head";
        if ($truthy(self.docinfo_processor_extensions['$key?'](location))) {
          return self.docinfo_processor_extensions['$[]'](location)['$!='](false)
        } else if (($truthy(self.extensions) && ($truthy(self.document.$extensions()['$docinfo_processors?'](location))))) {
          return ($a = [location, self.document.$extensions().$docinfo_processors(location)], $send(self.docinfo_processor_extensions, '[]=', $a), $a[$a.length - 1])['$!']()['$!']()
        } else {
          return ($a = [location, false], $send(self.docinfo_processor_extensions, '[]=', $a), $a[$a.length - 1])
        }      }, -1);
      
      $def(self, '$to_s', function $$to_s() {
        var self = this, $ret_or_1 = nil;

        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {doctype: " + (self.$doctype().$inspect()) + ", doctitle: " + (($truthy(($ret_or_1 = self.header)) ? (self.header.$title()) : ($ret_or_1)).$inspect()) + ", blocks: " + (self.blocks.$size()) + "}>"
      });
      self.$private();
      
      $def(self, '$apply_attribute_value_subs', function $$apply_attribute_value_subs(value) {
        var $a, self = this;

        
        if ($truthy($$('AttributeEntryPassMacroRx')['$=~'](value))) {
          
          value = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
          if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
            value = self.$apply_subs(value, self.$resolve_pass_subs((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))));
          }        } else {
          value = self.$apply_header_subs(value);
        }        if ($truthy(self.max_attribute_value_size)) {
          
          return self.$limit_bytesize(value, self.max_attribute_value_size);
        } else {
          return value
        }      });
      
      $def(self, '$limit_bytesize', function $$limit_bytesize(str, max) {
        
        
        if ($truthy($rb_gt(str.$bytesize(), max))) {
          while (!($truthy((str = str.$byteslice(0, max))['$valid_encoding?']()))) {
          max = $rb_minus(max, 1);
          }
        }        return str;
      });
      
      $def(self, '$resolve_docinfo_subs', function $$resolve_docinfo_subs() {
        var self = this;

        if ($truthy(self.attributes['$key?']("docinfosubs"))) {
          
          return self.$resolve_subs(self.attributes['$[]']("docinfosubs"), "block", nil, "docinfo");
        } else {
          return ["attributes"]
        }
      });
      
      $def(self, '$create_converter', function $$create_converter(backend, delegate_backend) {
        var self = this, converter_opts = nil, template_dirs = nil, $ret_or_1 = nil, opts = nil, converter = nil;

        
        converter_opts = $hash2(["document", "htmlsyntax"], {"document": self, "htmlsyntax": self.attributes['$[]']("htmlsyntax")});
        if ($truthy((template_dirs = ($truthy(($ret_or_1 = (opts = self.options)['$[]']("template_dirs"))) ? ($ret_or_1) : (opts['$[]']("template_dir")))))) {
          
          converter_opts['$[]=']("template_dirs", [].concat($to_a(template_dirs)));
          converter_opts['$[]=']("template_cache", opts.$fetch("template_cache", true));
          converter_opts['$[]=']("template_engine", opts['$[]']("template_engine"));
          converter_opts['$[]=']("template_engine_options", opts['$[]']("template_engine_options"));
          converter_opts['$[]=']("eruby", opts['$[]']("eruby"));
          converter_opts['$[]=']("safe", self.safe);
          if ($truthy(delegate_backend)) {
            converter_opts['$[]=']("delegate_backend", delegate_backend);
          }        }        if ($truthy((converter = opts['$[]']("converter")))) {
          return $$$($$('Converter'), 'CustomFactory').$new($hash(backend, converter)).$create(backend, converter_opts)
        } else {
          return opts.$fetch("converter_factory", $$('Converter')).$create(backend, converter_opts)
        }      });
      
      $def(self, '$clear_playback_attributes', function $$clear_playback_attributes(attributes) {
        
        return attributes.$delete("attribute_entries")
      });
      
      $def(self, '$save_attributes', function $$save_attributes() {
        var self = this, doctitle_val = nil, attrs = nil, $ret_or_1 = nil, toc_val = nil, toc_position_val = nil, toc_placement_val = nil, default_toc_position = nil, default_toc_class = nil, position = nil, icons_val = nil, basebackend = nil, syntax_hl_name = nil, syntax_hl_factory = nil, syntax_hls = nil;

        
        if (!($truthy((attrs = self.attributes)['$key?']("doctitle")) || ($not((doctitle_val = self.$doctitle()))))) {
          attrs['$[]=']("doctitle", doctitle_val);
        }        self.id = ($truthy(($ret_or_1 = self.id)) ? ($ret_or_1) : (attrs['$[]']("css-signature")));
        if ($truthy((toc_val = ($truthy(attrs.$delete("toc2")) ? ("left") : (attrs['$[]']("toc")))))) {
          
          toc_position_val = (($truthy((toc_placement_val = attrs.$fetch("toc-placement", "macro"))) && ($neqeq(toc_placement_val, "auto"))) ? (toc_placement_val) : (attrs['$[]']("toc-position")));
          if (!($truthy(toc_val['$empty?']()) && ($truthy(toc_position_val['$nil_or_empty?']())))) {
            
            default_toc_position = "left";
            default_toc_class = "toc2";
            position = ($truthy(toc_position_val['$nil_or_empty?']()) ? (($truthy(toc_val['$empty?']()) ? (default_toc_position) : (toc_val))) : (toc_position_val));
            attrs['$[]=']("toc", "");
            attrs['$[]=']("toc-placement", "auto");
            
            switch (position) {
              case "left":
              case "<":
              case "&lt;":
                attrs['$[]=']("toc-position", "left");
                break;
              case "right":
              case ">":
              case "&gt;":
                attrs['$[]=']("toc-position", "right");
                break;
              case "top":
              case "^":
                attrs['$[]=']("toc-position", "top");
                break;
              case "bottom":
              case "v":
                attrs['$[]=']("toc-position", "bottom");
                break;
              case "preamble":
              case "macro":
                
                attrs['$[]=']("toc-position", "content");
                attrs['$[]=']("toc-placement", position);
                default_toc_class = nil;
                break;
              default:
                
                attrs.$delete("toc-position");
                default_toc_class = nil;
            }            if ($truthy(default_toc_class)) {
              if ($truthy(($ret_or_1 = attrs['$[]']("toc-class")))) ; else {
                attrs['$[]=']("toc-class", default_toc_class);
              }
            }          }        }        if (($truthy((icons_val = attrs['$[]']("icons"))) && ($not(attrs['$key?']("icontype"))))) {
          
          switch (icons_val) {
            case "":
            case "font":
              
              break;
            default:
              
              attrs['$[]=']("icons", "");
              if (!$eqeq(icons_val, "image")) {
                attrs['$[]=']("icontype", icons_val);
              }          }
        }        if (($truthy((self.compat_mode = attrs['$key?']("compat-mode"))) && ($truthy(attrs['$key?']("language"))))) {
          attrs['$[]=']("source-language", attrs['$[]']("language"));
        }        if (!$truthy(self.parent_document)) {
          
          if ($eqeq((basebackend = attrs['$[]']("basebackend")), "html")) {
            if (($truthy((syntax_hl_name = attrs['$[]']("source-highlighter"))) && ($not(attrs['$[]']("" + (syntax_hl_name) + "-unavailable"))))) {
              if ($truthy((syntax_hl_factory = self.options['$[]']("syntax_highlighter_factory")))) {
                self.syntax_highlighter = syntax_hl_factory.$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}));
              } else if ($truthy((syntax_hls = self.options['$[]']("syntax_highlighters")))) {
                self.syntax_highlighter = $$$($$('SyntaxHighlighter'), 'DefaultFactoryProxy').$new(syntax_hls).$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}));
              } else {
                self.syntax_highlighter = $$('SyntaxHighlighter').$create(syntax_hl_name, self.backend, $hash2(["document"], {"document": self}));
              }
            }
          } else if ($eqeq(basebackend, "docbook")) {
            
            if (!($truthy(self['$attribute_locked?']("toc")) || ($truthy(self.attributes_modified['$include?']("toc"))))) {
              attrs['$[]=']("toc", "");
            }            if (!($truthy(self['$attribute_locked?']("sectnums")) || ($truthy(self.attributes_modified['$include?']("sectnums"))))) {
              attrs['$[]=']("sectnums", "");
            }          }          self.outfilesuffix = attrs['$[]']("outfilesuffix");
          $send($$('FLEXIBLE_ATTRIBUTES'), 'each', [], function $$26(name){var self = $$26.$$s == null ? this : $$26.$$s;
            if (self.attribute_overrides == null) self.attribute_overrides = nil;

            
            if (name == null) name = nil;
            if (($truthy(self.attribute_overrides['$key?'](name)) && ($truthy(self.attribute_overrides['$[]'](name))))) {
              return self.attribute_overrides.$delete(name)
            } else {
              return nil
            }}, {$$s: self});
        }        return (self.header_attributes = attrs.$merge());
      });
      
      $def(self, '$fill_datetime_attributes', function $$fill_datetime_attributes(attrs, input_mtime) {
        var $a, self = this, now = nil, source_date_epoch = nil, localdate = nil, $ret_or_1 = nil, localtime = nil, $ret_or_2 = nil, docdate = nil, doctime = nil;

        
        now = ($truthy($$$('ENV')['$key?']("SOURCE_DATE_EPOCH")) ? ((source_date_epoch = $$$('Time').$at(self.$Integer($$$('ENV')['$[]']("SOURCE_DATE_EPOCH"))).$utc())) : ($$$('Time').$now()));
        if ($truthy((localdate = attrs['$[]']("localdate")))) {
          if ($truthy(($ret_or_1 = attrs['$[]']("localyear")))) ; else {
            attrs['$[]=']("localyear", ($eqeq(localdate.$index("-"), 4) ? (localdate.$slice(0, 4)) : (nil)));
          }
        } else {
          
          localdate = ($a = ["localdate", now.$strftime("%F")], $send(attrs, '[]=', $a), $a[$a.length - 1]);
          if ($truthy(($ret_or_1 = attrs['$[]']("localyear")))) ; else {
            attrs['$[]=']("localyear", now.$year().$to_s());
          }        }        localtime = ($truthy(($ret_or_1 = attrs['$[]']("localtime"))) ? ($ret_or_1) : (($a = ["localtime", now.$strftime("%T " + (($eqeq(now.$utc_offset(), 0) ? ("UTC") : ("%z"))))], $send(attrs, '[]=', $a), $a[$a.length - 1])));
        if ($truthy(($ret_or_1 = attrs['$[]']("localdatetime")))) ; else {
          attrs['$[]=']("localdatetime", "" + (localdate) + " " + (localtime));
        }        input_mtime = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = source_date_epoch)) ? ($ret_or_2) : (input_mtime)))) ? ($ret_or_1) : (now));
        if ($truthy((docdate = attrs['$[]']("docdate")))) {
          if ($truthy(($ret_or_1 = attrs['$[]']("docyear")))) ; else {
            attrs['$[]=']("docyear", ($eqeq(docdate.$index("-"), 4) ? (docdate.$slice(0, 4)) : (nil)));
          }
        } else {
          
          docdate = ($a = ["docdate", input_mtime.$strftime("%F")], $send(attrs, '[]=', $a), $a[$a.length - 1]);
          if ($truthy(($ret_or_1 = attrs['$[]']("docyear")))) ; else {
            attrs['$[]=']("docyear", input_mtime.$year().$to_s());
          }        }        doctime = ($truthy(($ret_or_1 = attrs['$[]']("doctime"))) ? ($ret_or_1) : (($a = ["doctime", input_mtime.$strftime("%T " + (($eqeq(input_mtime.$utc_offset(), 0) ? ("UTC") : ("%z"))))], $send(attrs, '[]=', $a), $a[$a.length - 1])));
        if ($truthy(($ret_or_1 = attrs['$[]']("docdatetime")))) ; else {
          attrs['$[]=']("docdatetime", "" + (docdate) + " " + (doctime));
        }        return nil;
      });
      
      $def(self, '$update_backend_attributes', function $$update_backend_attributes(new_backend, init) {
        var $a, $b, self = this, current_backend = nil, current_basebackend = nil, attrs = nil, current_doctype = nil, actual_backend = nil, $ret_or_1 = nil, delegate_backend = nil, converter = nil, new_basebackend = nil, new_filetype = nil, htmlsyntax = nil, backend_traits = nil, current_filetype = nil, page_width = nil;

        
        if (init == null) init = nil;
        if (($truthy(init) || ($neqeq(new_backend, self.backend)))) {
          
          current_backend = self.backend;
          current_basebackend = (attrs = self.attributes)['$[]']("basebackend");
          current_doctype = self.doctype;
          if ($truthy(new_backend['$include?'](":"))) {
            $b = new_backend.$partition(":"), $a = $to_ary($b), (actual_backend = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (new_backend = ($a[2] == null ? nil : $a[2]));
          }          if ($truthy(new_backend['$start_with?']("xhtml"))) {
            
            attrs['$[]=']("htmlsyntax", "xml");
            new_backend = new_backend.$slice(1, new_backend.$length());
          } else if ($truthy(new_backend['$start_with?']("html"))) {
            if ($truthy(($ret_or_1 = attrs['$[]']("htmlsyntax")))) ; else {
              attrs['$[]=']("htmlsyntax", "html");
            }
          }          new_backend = ($truthy(($ret_or_1 = $$('BACKEND_ALIASES')['$[]'](new_backend))) ? ($ret_or_1) : (new_backend));
          if ($truthy(actual_backend)) {
            $a = [actual_backend, new_backend], (new_backend = $a[0]), (delegate_backend = $a[1]);
          }          if ($truthy(current_doctype)) {
            
            if ($truthy(current_backend)) {
              
              attrs.$delete("backend-" + (current_backend));
              attrs.$delete("backend-" + (current_backend) + "-doctype-" + (current_doctype));
            }            attrs['$[]=']("backend-" + (new_backend) + "-doctype-" + (current_doctype), "");
            attrs['$[]=']("doctype-" + (current_doctype), "");
          } else if ($truthy(current_backend)) {
            attrs.$delete("backend-" + (current_backend));
          }          attrs['$[]=']("backend-" + (new_backend), "");
          self.backend = ($a = ["backend", new_backend], $send(attrs, '[]=', $a), $a[$a.length - 1]);
          if ($eqeqeq($$$($$('Converter'), 'BackendTraits'), (converter = self.$create_converter(new_backend, delegate_backend)))) {
            
            new_basebackend = converter.$basebackend();
            new_filetype = converter.$filetype();
            if ($truthy((htmlsyntax = converter.$htmlsyntax()))) {
              attrs['$[]=']("htmlsyntax", htmlsyntax);
            }            if ($truthy(init)) {
              if ($truthy(($ret_or_1 = attrs['$[]']("outfilesuffix")))) ; else {
                attrs['$[]=']("outfilesuffix", converter.$outfilesuffix());
              }
            } else if (!$truthy(self['$attribute_locked?']("outfilesuffix"))) {
              attrs['$[]=']("outfilesuffix", converter.$outfilesuffix());
            }          } else if ($truthy(converter)) {
            
            backend_traits = $$('Converter').$derive_backend_traits(new_backend);
            new_basebackend = backend_traits['$[]']("basebackend");
            new_filetype = backend_traits['$[]']("filetype");
            if ($truthy(init)) {
              if ($truthy(($ret_or_1 = attrs['$[]']("outfilesuffix")))) ; else {
                attrs['$[]=']("outfilesuffix", backend_traits['$[]']("outfilesuffix"));
              }
            } else if (!$truthy(self['$attribute_locked?']("outfilesuffix"))) {
              attrs['$[]=']("outfilesuffix", backend_traits['$[]']("outfilesuffix"));
            }          } else {
            self.$raise($$$('NotImplementedError'), "asciidoctor: FAILED: missing converter for backend '" + (new_backend) + "'. Processing aborted.");
          }          self.converter = converter;
          if ($truthy((current_filetype = attrs['$[]']("filetype")))) {
            attrs.$delete("filetype-" + (current_filetype));
          }          attrs['$[]=']("filetype", new_filetype);
          attrs['$[]=']("filetype-" + (new_filetype), "");
          if ($truthy((page_width = $$('DEFAULT_PAGE_WIDTHS')['$[]'](new_basebackend)))) {
            attrs['$[]=']("pagewidth", page_width);
          } else {
            attrs.$delete("pagewidth");
          }          if ($neqeq(new_basebackend, current_basebackend)) {
            
            if ($truthy(current_doctype)) {
              
              if ($truthy(current_basebackend)) {
                
                attrs.$delete("basebackend-" + (current_basebackend));
                attrs.$delete("basebackend-" + (current_basebackend) + "-doctype-" + (current_doctype));
              }              attrs['$[]=']("basebackend-" + (new_basebackend) + "-doctype-" + (current_doctype), "");
            } else if ($truthy(current_basebackend)) {
              attrs.$delete("basebackend-" + (current_basebackend));
            }            attrs['$[]=']("basebackend-" + (new_basebackend), "");
            attrs['$[]=']("basebackend", new_basebackend);
          }          return new_backend;
        } else {
          return nil
        }      }, -2);
      return $def(self, '$update_doctype_attributes', function $$update_doctype_attributes(new_doctype) {
        var $a, self = this, attrs = nil, current_backend = nil, current_basebackend = nil, current_doctype = nil;

        if (($truthy(new_doctype) && ($neqeq(new_doctype, self.doctype)))) {
          
          $a = [self.backend, (attrs = self.attributes)['$[]']("basebackend"), self.doctype], (current_backend = $a[0]), (current_basebackend = $a[1]), (current_doctype = $a[2]);
          if ($truthy(current_doctype)) {
            
            attrs.$delete("doctype-" + (current_doctype));
            if ($truthy(current_backend)) {
              
              attrs.$delete("backend-" + (current_backend) + "-doctype-" + (current_doctype));
              attrs['$[]=']("backend-" + (current_backend) + "-doctype-" + (new_doctype), "");
            }            if ($truthy(current_basebackend)) {
              
              attrs.$delete("basebackend-" + (current_basebackend) + "-doctype-" + (current_doctype));
              attrs['$[]=']("basebackend-" + (current_basebackend) + "-doctype-" + (new_doctype), "");
            }          } else {
            
            if ($truthy(current_backend)) {
              attrs['$[]=']("backend-" + (current_backend) + "-doctype-" + (new_doctype), "");
            }            if ($truthy(current_basebackend)) {
              attrs['$[]=']("basebackend-" + (current_basebackend) + "-doctype-" + (new_doctype), "");
            }          }          attrs['$[]=']("doctype-" + (new_doctype), "");
          return (self.doctype = ($a = ["doctype", new_doctype], $send(attrs, '[]=', $a), $a[$a.length - 1]));
        } else {
          return nil
        }
      });
    })($nesting[0], $$('AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/inline"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $return_val = Opal.return_val, $alias = Opal.alias, $truthy = Opal.truthy, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_accessor,attr_reader,[],convert,converter,attr,==,apply_reftext_subs,reftext');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Inline');

      var $proto = self.$$prototype;

      $proto.text = $proto.type = nil;
      
      self.$attr_accessor("text");
      self.$attr_reader("type");
      self.$attr_accessor("target");
      
      $def(self, '$initialize', function $$initialize(parent, context, text, opts) {
        $$initialize.$$p || nil; var self = this;

        $$initialize.$$p = null;
        
        if (text == null) text = nil;
        if (opts == null) opts = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, context, opts], null);
        self.node_name = "inline_" + (context);
        self.text = text;
        self.id = opts['$[]']("id");
        self.type = opts['$[]']("type");
        return (self.target = opts['$[]']("target"));
      }, -3);
      
      $def(self, '$block?', $return_val(false));
      
      $def(self, '$inline?', $return_val(true));
      
      $def(self, '$convert', function $$convert() {
        var self = this;

        return self.$converter().$convert(self)
      });
      $alias(self, "render", "convert");
      
      $def(self, '$alt', function $$alt() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.$attr("alt")))) {
          return $ret_or_1
        } else {
          return ""
        }
      });
      
      $def(self, '$reftext?', function $Inline_reftext$ques$1() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = self.text))) {
          
          if ($truthy(($ret_or_2 = self.type['$==']("ref")))) {
            return $ret_or_2
          } else {
            return self.type['$==']("bibref")
          }        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$reftext', function $$reftext() {
        var self = this, val = nil;

        if ($truthy((val = self.text))) {
          
          return self.$apply_reftext_subs(val);
        } else {
          return nil
        }
      });
      return $def(self, '$xreftext', function $$xreftext(xrefstyle) {
        var self = this;
        return self.$reftext();
      }, -1);
    })($nesting[0], $$('AbstractNode'))
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/list"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $alias = Opal.alias, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $def = Opal.def, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('blocks,blocks?,==,next_list,callouts,convert,class,object_id,inspect,size,items,parent,attr_accessor,level,drop,nil_or_empty?,apply_subs,attr_writer,empty?,===,[],outline?,!,simple?,source,shift,context');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super) {
      var self = $klass($base, $super, 'List');

      var $proto = self.$$prototype;

      $proto.context = $proto.document = $proto.style = nil;
      
      $alias(self, "items", "blocks");
      $alias(self, "content", "blocks");
      $alias(self, "items?", "blocks?");
      
      $def(self, '$initialize', function $$initialize(parent, context, opts) {
        var $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        if (opts == null) opts = $hash2([], {});
        return $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, context, opts], $yield);
      }, -3);
      
      $def(self, '$outline?', function $List_outline$ques$1() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.context['$==']("ulist")))) {
          return $ret_or_1
        } else {
          return self.context['$==']("olist")
        }
      });
      
      $def(self, '$convert', function $$convert() {
        var $yield = $$convert.$$p || nil, self = this, result = nil;

        $$convert.$$p = null;
        if ($eqeq(self.context, "colist")) {
          
          result = $send2(self, $find_super(self, 'convert', $$convert, false, true), 'convert', [], $yield);
          self.document.$callouts().$next_list();
          return result;
        } else {
          return $send2(self, $find_super(self, 'convert', $$convert, false, true), 'convert', [], $yield)
        }
      });
      $alias(self, "render", "convert");
      return $def(self, '$to_s', function $$to_s() {
        var self = this;

        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {context: " + (self.context.$inspect()) + ", style: " + (self.style.$inspect()) + ", items: " + (self.$items().$size()) + "}>"
      });
    })($nesting[0], $$('AbstractBlock'));
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ListItem');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.text = $proto.subs = $proto.blocks = nil;
      
      $alias(self, "list", "parent");
      self.$attr_accessor("marker");
      
      $def(self, '$initialize', function $$initialize(parent, text) {
        $$initialize.$$p || nil; var self = this;

        $$initialize.$$p = null;
        
        if (text == null) text = nil;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, "list_item"], null);
        self.text = text;
        self.level = parent.$level();
        return (self.subs = $$('NORMAL_SUBS').$drop(0));
      }, -2);
      
      $def(self, '$text?', function $ListItem_text$ques$2() {
        var self = this;

        if ($truthy(self.text['$nil_or_empty?']())) {
          return false
        } else {
          return true
        }
      });
      
      $def(self, '$text', function $$text() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.text))) {
          
          return self.$apply_subs(self.text, self.subs);
        } else {
          return $ret_or_1
        }
      });
      self.$attr_writer("text");
      
      $def(self, '$simple?', function $ListItem_simple$ques$3() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil, blk = nil;

        if ($truthy(($ret_or_1 = self.blocks['$empty?']()))) {
          return $ret_or_1
        } else {
          
          if ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = self.blocks.$size()['$=='](1))) ? ($$('List')['$===']((blk = self.blocks['$[]'](0)))) : ($ret_or_3))))) {
            return blk['$outline?']()
          } else {
            return $ret_or_2
          }        }
      });
      
      $def(self, '$compound?', function $ListItem_compound$ques$4() {
        var self = this;

        return self['$simple?']()['$!']()
      });
      
      $def(self, '$fold_first', function $$fold_first() {
        var self = this;

        
        self.text = ($truthy(self.text['$nil_or_empty?']()) ? (self.blocks.$shift().$source()) : ("" + (self.text) + ($$('LF')) + (self.blocks.$shift().$source())));
        return nil;
      });
      return $def(self, '$to_s', function $$to_s() {
        var self = this, $ret_or_1 = nil;

        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {list_context: " + (self.$parent().$context().$inspect()) + ", text: " + (self.text.$inspect()) + ", blocks: " + (($truthy(($ret_or_1 = self.blocks)) ? ($ret_or_1) : ([])).$size()) + "}>"
      });
    })($nesting[0], $$('AbstractBlock'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/parser"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $send = Opal.send, $truthy = Opal.truthy, $hash2 = Opal.hash2, $to_ary = Opal.to_ary, $defs = Opal.defs, $eqeq = Opal.eqeq, $not = Opal.not, $gvars = Opal.gvars, $neqeq = Opal.neqeq, $rb_plus = Opal.rb_plus, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $to_a = Opal.to_a, $eqeqeq = Opal.eqeqeq, $rb_minus = Opal.rb_minus, $rb_times = Opal.rb_times, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,new,proc,start_with?,match?,is_delimited_block?,private_class_method,parse_document_header,[],has_more_lines?,next_section,assign_numeral,<<,blocks,skip_blank_lines,parse_block_metadata_lines,attributes,is_next_line_doctitle?,[]=,finalize_header,nil_or_empty?,title=,sourcemap,cursor,parse_section_title,id=,include?,sub_specialchars,sub_attributes,source_location=,header,attribute_locked?,id,clear,delete,instance_variable_get,parse_header_metadata,==,!,register,process_authors,update,doctype,parse_manpage_header,=~,downcase,error,logger,message_with_context,cursor_at_line,backend,save,is_next_line_section?,initialize_section,join,map,read_lines_until,lstrip,split,title,restore_save,discard_save,header?,empty?,context,!=,attr?,attr,key?,document,+,level,special,sectname,to_i,<,>,warn,next_block,blocks?,style,style=,parent=,content_model,content_model=,lines,subs,size,context=,shift,unwrap_standalone_preamble,source_location,merge,fetch,parse_block_metadata_line,extensions,block_macros?,mark,read_line,terminator,to_s,masq,to_sym,registered_for_block?,debug?,debug,cursor_at_mark,strict_verbatim_paragraphs,unshift_line,markdown_syntax,keys,chr,uniform?,length,end_with?,parse_attributes,attribute_missing,tr,basename,assign_caption,registered_for_block_macro?,config,process_method,replace,parse_callout_list,callouts,===,parse_list,parse_description_list,underline_style_section_titles,is_section_title?,peek_line,atx_section_title?,generate_id,level=,read_paragraph_lines,adjust_indentation!,map!,slice,pop,build_block,apply_subs,chop,catalog_inline_anchors,rekey,index,strip,-,parse_table,each,raise,title?,update_attributes,commit_subs,sub?,catalog_callouts,source,remove_sub,block_terminates_paragraph,to_proc,nil?,parse_blocks,parse_list_item,items,scan,gsub,count,advance,dup,match,callout_ids,next_list,catalog_inline_anchor,marker=,catalog_inline_biblio_anchor,set_option,text=,resolve_ordered_list_marker,read_lines_for_list_item,skip_line_comments,unshift_lines,fold_first,text?,is_sibling_list_item?,concat,find,casecmp,sectname=,special=,numbered=,numbered,lineno,peek_lines,setext_section_title?,abs,cursor_at_prev_line,process_attribute_entries,next_line_empty?,apply_header_subs,rstrip,each_with_index,compact,to_h,squeeze,to_a,parse_style_attribute,process_attribute_entry,skip_comment_lines,store_attribute,sanitize_attribute_name,set_attribute,save_to,delete_attribute,ord,int_to_roman,resolve_list_marker,parse_colspecs,create_columns,has_header_option=,format,starts_with_delimiter?,close_open_cell,parse_cellspec,delimiter,match_delimiter,pre_match,post_match,buffer_has_unclosed_quotes?,skip_past_delimiter,buffer=,buffer,skip_past_escaped_delimiter,keep_cell_open,push_cellspec,close_cell,cell_open?,columns,assign_column_widths,partition_header_footer,upto,partition,shorthand_property_syntax,each_char,yield_buffered_attribute,any?,*,each_byte,%');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Parser');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$('Logging'));
      $const_set($nesting[0], 'BlockMatchData', $$('Struct').$new("context", "masq", "tip", "terminator"));
      $const_set($nesting[0], 'TAB', "\t");
      $const_set($nesting[0], 'TabIndentRx', /^\t+/);
      $const_set($nesting[0], 'StartOfBlockProc', $send(self, 'proc', [], function $Parser$1(l){var self = $Parser$1.$$s == null ? this : $Parser$1.$$s, $ret_or_1 = nil, $ret_or_2 = nil;

        
        if (l == null) l = nil;
        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = l['$start_with?']("["))) ? ($$('BlockAttributeLineRx')['$match?'](l)) : ($ret_or_2))))) {
          return $ret_or_1
        } else {
          
          return self['$is_delimited_block?'](l);
        }}, {$$s: self}));
      $const_set($nesting[0], 'StartOfListProc', $send(self, 'proc', [], function $Parser$2(l){
        
        if (l == null) l = nil;
        return $$('AnyListRx')['$match?'](l);}));
      $const_set($nesting[0], 'StartOfBlockOrListProc', $send(self, 'proc', [], function $Parser$3(l){var self = $Parser$3.$$s == null ? this : $Parser$3.$$s, $ret_or_1 = nil, $ret_or_2 = nil, $ret_or_3 = nil;

        
        if (l == null) l = nil;
        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self['$is_delimited_block?'](l))) ? ($ret_or_2) : (($truthy(($ret_or_3 = l['$start_with?']("["))) ? ($$('BlockAttributeLineRx')['$match?'](l)) : ($ret_or_3))))))) {
          return $ret_or_1
        } else {
          
          return $$('AnyListRx')['$match?'](l);
        }}, {$$s: self}));
      $const_set($nesting[0], 'NoOp', nil);
      $const_set($nesting[0], 'AuthorKeys', ["author", "authorinitials", "firstname", "middlename", "lastname", "email"]);
      $const_set($nesting[0], 'TableCellHorzAlignments', $hash2(["<", ">", "^"], {"<": "left", ">": "right", "^": "center"}));
      $const_set($nesting[0], 'TableCellVertAlignments', $hash2(["<", ">", "^"], {"<": "top", ">": "bottom", "^": "middle"}));
      $const_set($nesting[0], 'TableCellStyles', $hash2(["d", "s", "e", "m", "h", "l", "a"], {"d": "none", "s": "strong", "e": "emphasis", "m": "monospaced", "h": "header", "l": "literal", "a": "asciidoc"}));
      self.$private_class_method("new");
      $defs(self, '$parse', function $$parse(reader, document, options) {
        var $a, $b, self = this, block_attributes = nil, header_only = nil, new_section = nil;

        
        if (options == null) options = $hash2([], {});
        block_attributes = self.$parse_document_header(reader, document, (header_only = options['$[]']("header_only")));
        if (!$truthy(header_only)) {
          while ($truthy(reader['$has_more_lines?']())) {
          
            $b = self.$next_section(reader, document, block_attributes), $a = $to_ary($b), (new_section = ($a[0] == null ? nil : $a[0])), (block_attributes = ($a[1] == null ? nil : $a[1]));
            if ($truthy(new_section)) {
              
              document.$assign_numeral(new_section);
              document.$blocks()['$<<'](new_section);
            }          }
        }        return document;
      }, -3);
      $defs(self, '$parse_document_header', function $$parse_document_header(reader, document, header_only) {
        var $a, $b, $c, self = this, block_attrs = nil, doc_attrs = nil, implicit_doctitle = nil, val = nil, doctitle_attr_val = nil, source_location = nil, l0_section_title = nil, atx = nil, separator = nil, doc_id = nil, role = nil, reftext = nil, modified_attrs = nil, author = nil, author_metadata = nil;

        
        if (header_only == null) header_only = false;
        block_attrs = ($truthy(reader.$skip_blank_lines()) ? (self.$parse_block_metadata_lines(reader, document)) : ($hash2([], {})));
        doc_attrs = document.$attributes();
        if (($truthy((implicit_doctitle = self['$is_next_line_doctitle?'](reader, block_attrs, doc_attrs['$[]']("leveloffset")))) && ($truthy(block_attrs['$[]']("title"))))) {
          
          doc_attrs['$[]=']("authorcount", 0);
          return document.$finalize_header(block_attrs, false);
        }        if (!$truthy((val = doc_attrs['$[]']("doctitle"))['$nil_or_empty?']())) {
          document['$title=']((doctitle_attr_val = val));
        }        if ($truthy(implicit_doctitle)) {
          
          if ($truthy(document.$sourcemap())) {
            source_location = reader.$cursor();
          }          $b = self.$parse_section_title(reader, document), $a = $to_ary($b), ($c = [($a[0] == null ? nil : $a[0])], $send(document, 'id=', $c), $c[$c.length - 1]), (($a[1] == null ? nil : $a[1])), (l0_section_title = ($a[2] == null ? nil : $a[2])), (($a[3] == null ? nil : $a[3])), (atx = ($a[4] == null ? nil : $a[4]));
          if ($truthy(doctitle_attr_val)) {
            l0_section_title = nil;
          } else {
            
            document['$title='](l0_section_title);
            if ($truthy(($a = ["doctitle", (doctitle_attr_val = document.$sub_specialchars(l0_section_title))], $send(doc_attrs, '[]=', $a), $a[$a.length - 1])['$include?']($$('ATTR_REF_HEAD')))) {
              doc_attrs['$[]=']("doctitle", (doctitle_attr_val = document.$sub_attributes(doctitle_attr_val, $hash2(["attribute_missing"], {"attribute_missing": "skip"}))));
            }          }          if ($truthy(source_location)) {
            document.$header()['$source_location='](source_location);
          }          if (!($truthy(atx) || ($truthy(document['$attribute_locked?']("compat-mode"))))) {
            doc_attrs['$[]=']("compat-mode", "");
          }          if ($truthy((separator = block_attrs['$[]']("separator")))) {
            if (!$truthy(document['$attribute_locked?']("title-separator"))) {
              doc_attrs['$[]=']("title-separator", separator);
            }
          }          if ($truthy((doc_id = block_attrs['$[]']("id")))) {
            document['$id='](doc_id);
          } else {
            doc_id = document.$id();
          }          if ($truthy((role = block_attrs['$[]']("role")))) {
            doc_attrs['$[]=']("role", role);
          }          if ($truthy((reftext = block_attrs['$[]']("reftext")))) {
            doc_attrs['$[]=']("reftext", reftext);
          }          block_attrs.$clear();
          (modified_attrs = document.$instance_variable_get("@attributes_modified")).$delete("doctitle");
          self.$parse_header_metadata(reader, document, nil);
          if ($truthy(modified_attrs['$include?']("doctitle"))) {
            if (($truthy((val = doc_attrs['$[]']("doctitle"))['$nil_or_empty?']()) || ($eqeq(val, doctitle_attr_val)))) {
              doc_attrs['$[]=']("doctitle", doctitle_attr_val);
            } else {
              document['$title='](val);
            }
          } else if ($not(l0_section_title)) {
            modified_attrs['$<<']("doctitle");
          }          if ($truthy(doc_id)) {
            document.$register("refs", [doc_id, document]);
          }        } else if ($truthy((author = doc_attrs['$[]']("author")))) {
          
          author_metadata = self.$process_authors(author, true, false);
          if ($truthy(doc_attrs['$[]']("authorinitials"))) {
            author_metadata.$delete("authorinitials");
          }          doc_attrs.$update(author_metadata);
        } else if ($truthy((author = doc_attrs['$[]']("authors")))) {
          
          author_metadata = self.$process_authors(author, true);
          doc_attrs.$update(author_metadata);
        } else {
          doc_attrs['$[]=']("authorcount", 0);
        }        if ($eqeq(document.$doctype(), "manpage")) {
          self.$parse_manpage_header(reader, document, block_attrs, header_only);
        }        return document.$finalize_header(block_attrs);
      }, -3);
      $defs(self, '$parse_manpage_header', function $$parse_manpage_header(reader, document, block_attributes, header_only) {
        var $a, self = this, doc_attrs = nil, manvolnum = nil, mantitle = nil, $ret_or_1 = nil, $ret_or_2 = nil, manname = nil, name_section_level = nil, name_section = nil, name_section_buffer = nil, mannames = nil, manpurpose = nil, error_msg = nil;

        
        if (header_only == null) header_only = false;
        if ($truthy($$('ManpageTitleVolnumRx')['$=~']((doc_attrs = document.$attributes())['$[]']("doctitle")))) {
          
          doc_attrs['$[]=']("manvolnum", (manvolnum = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))));
          doc_attrs['$[]=']("mantitle", ($truthy((mantitle = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))['$include?']($$('ATTR_REF_HEAD'))) ? (document.$sub_attributes(mantitle)) : (mantitle)).$downcase());
        } else {
          
          self.$logger().$error(self.$message_with_context("non-conforming manpage title", $hash2(["source_location"], {"source_location": reader.$cursor_at_line(1)})));
          doc_attrs['$[]=']("mantitle", ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = doc_attrs['$[]']("doctitle"))) ? ($ret_or_2) : (doc_attrs['$[]']("docname"))))) ? ($ret_or_1) : ("command")));
          doc_attrs['$[]=']("manvolnum", (manvolnum = "1"));
        }        if (($truthy((manname = doc_attrs['$[]']("manname"))) && ($truthy(doc_attrs['$[]']("manpurpose"))))) {
          
          if ($truthy(($ret_or_1 = doc_attrs['$[]']("manname-title")))) ; else {
            doc_attrs['$[]=']("manname-title", "Name");
          }          doc_attrs['$[]=']("mannames", [manname]);
          if ($eqeq(document.$backend(), "manpage")) {
            
            doc_attrs['$[]=']("docname", manname);
            doc_attrs['$[]=']("outfilesuffix", "." + (manvolnum));
          }        } else if (!$truthy(header_only)) {
          
          reader.$skip_blank_lines();
          reader.$save();
          block_attributes.$update(self.$parse_block_metadata_lines(reader, document));
          if ($truthy((name_section_level = self['$is_next_line_section?'](reader, $hash2([], {}))))) {
            if ($eqeq(name_section_level, 1)) {
              
              name_section = self.$initialize_section(reader, document, $hash2([], {}));
              name_section_buffer = $send(reader.$read_lines_until($hash2(["break_on_blank_lines", "skip_line_comments"], {"break_on_blank_lines": true, "skip_line_comments": true})), 'map', [], function $$4(l){
                
                if (l == null) l = nil;
                return l.$lstrip();}).$join(" ");
              if ($truthy($$('ManpageNamePurposeRx')['$=~'](name_section_buffer))) {
                
                if ($truthy((manname = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))['$include?']($$('ATTR_REF_HEAD')))) {
                  manname = document.$sub_attributes(manname);
                }                if ($truthy(manname['$include?'](","))) {
                  manname = (mannames = $send(manname.$split(","), 'map', [], function $$5(n){
                    
                    if (n == null) n = nil;
                    return n.$lstrip();}))['$[]'](0);
                } else {
                  mannames = [manname];
                }                if ($truthy((manpurpose = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))['$include?']($$('ATTR_REF_HEAD')))) {
                  manpurpose = document.$sub_attributes(manpurpose);
                }                if ($truthy(($ret_or_1 = doc_attrs['$[]']("manname-title")))) ; else {
                  doc_attrs['$[]=']("manname-title", name_section.$title());
                }                if ($truthy(name_section.$id())) {
                  doc_attrs['$[]=']("manname-id", name_section.$id());
                }                doc_attrs['$[]=']("manname", manname);
                doc_attrs['$[]=']("mannames", mannames);
                doc_attrs['$[]=']("manpurpose", manpurpose);
                if ($eqeq(document.$backend(), "manpage")) {
                  
                  doc_attrs['$[]=']("docname", manname);
                  doc_attrs['$[]=']("outfilesuffix", "." + (manvolnum));
                }              } else {
                error_msg = "non-conforming name section body";
              }            } else {
              error_msg = "name section must be at level 1";
            }
          } else {
            error_msg = "name section expected";
          }          if ($truthy(error_msg)) {
            
            reader.$restore_save();
            self.$logger().$error(self.$message_with_context(error_msg, $hash2(["source_location"], {"source_location": reader.$cursor()})));
            doc_attrs['$[]=']("manname", (manname = ($truthy(($ret_or_1 = doc_attrs['$[]']("docname"))) ? ($ret_or_1) : ("command"))));
            doc_attrs['$[]=']("mannames", [manname]);
            if ($eqeq(document.$backend(), "manpage")) {
              
              doc_attrs['$[]=']("docname", manname);
              doc_attrs['$[]=']("outfilesuffix", "." + (manvolnum));
            }          } else {
            reader.$discard_save();
          }        }        return nil;
      }, -4);
      $defs(self, '$next_section', function $$next_section(reader, parent, attributes) {
        var $a, $b, self = this, preamble = nil, intro = nil, part = nil, has_header = nil, book = nil, document = nil, section = nil, current_level = nil, expected_next_level = nil, expected_next_level_alt = nil, title = nil, sectname = nil, next_level = nil, expected_condition = nil, new_section = nil, block_cursor = nil, new_block = nil, $ret_or_1 = nil, first_block = nil, child_block = nil;

        
        if (attributes == null) attributes = $hash2([], {});
        preamble = (intro = (part = false));
        if ((($eqeq(parent.$context(), "document") && ($truthy(parent.$blocks()['$empty?']()))) && ((($truthy((has_header = parent['$header?']())) || ($truthy(attributes.$delete("invalid-header")))) || ($not(self['$is_next_line_section?'](reader, attributes))))))) {
          
          book = (document = parent).$doctype()['$==']("book");
          if (($truthy(has_header) || (($truthy(book) && ($neqeq(attributes['$[]'](1), "abstract")))))) {
            
            preamble = (intro = $$('Block').$new(parent, "preamble", $hash2(["content_model"], {"content_model": "compound"})));
            if (($truthy(book) && ($truthy(parent['$attr?']("preface-title"))))) {
              preamble['$title='](parent.$attr("preface-title"));
            }            parent.$blocks()['$<<'](preamble);
          }          section = parent;
          current_level = 0;
          if ($truthy(parent.$attributes()['$key?']("fragment"))) {
            expected_next_level = -1;
          } else if ($truthy(book)) {
            $a = [1, 0], (expected_next_level = $a[0]), (expected_next_level_alt = $a[1]);
          } else {
            expected_next_level = 1;
          }        } else {
          
          book = (document = parent.$document()).$doctype()['$==']("book");
          section = self.$initialize_section(reader, parent, attributes);
          attributes = ($truthy((title = attributes['$[]']("title"))) ? ($hash2(["title"], {"title": title})) : ($hash2([], {})));
          expected_next_level = $rb_plus((current_level = section.$level()), 1);
          if ($eqeq(current_level, 0)) {
            part = book;
          } else if (($eqeq(current_level, 1) && ($truthy(section.$special())))) {
            if (!(($eqeq((sectname = section.$sectname()), "appendix") || ($eqeq(sectname, "preface"))) || ($eqeq(sectname, "abstract")))) {
              expected_next_level = nil;
            }
          }        }        reader.$skip_blank_lines();
        while ($truthy(reader['$has_more_lines?']())) {
        
          self.$parse_block_metadata_lines(reader, document, attributes);
          if ($truthy((next_level = self['$is_next_line_section?'](reader, attributes)))) {
            
            if ($truthy(document['$attr?']("leveloffset"))) {
              
              next_level = $rb_plus(next_level, document.$attr("leveloffset").$to_i());
              if ($truthy($rb_lt(next_level, 0))) {
                next_level = 0;
              }            }            if ($truthy($rb_gt(next_level, current_level))) {
              
              if ($truthy(expected_next_level)) {
                if (!(($eqeq(next_level, expected_next_level) || (($truthy(expected_next_level_alt) && ($eqeq(next_level, expected_next_level_alt))))) || ($truthy($rb_lt(expected_next_level, 0))))) {
                  
                  expected_condition = ($truthy(expected_next_level_alt) ? ("expected levels " + (expected_next_level_alt) + " or " + (expected_next_level)) : ("expected level " + (expected_next_level)));
                  self.$logger().$warn(self.$message_with_context("section title out of sequence: " + (expected_condition) + ", got level " + (next_level), $hash2(["source_location"], {"source_location": reader.$cursor()})));
                }
              } else {
                self.$logger().$error(self.$message_with_context("" + (sectname) + " sections do not support nested sections", $hash2(["source_location"], {"source_location": reader.$cursor()})));
              }              $b = self.$next_section(reader, section, attributes), $a = $to_ary($b), (new_section = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1]));
              section.$assign_numeral(new_section);
              section.$blocks()['$<<'](new_section);
            } else if (($eqeq(next_level, 0) && ($eqeq(section, document)))) {
              
              if (!$truthy(book)) {
                self.$logger().$error(self.$message_with_context("level 0 sections can only be used when doctype is book", $hash2(["source_location"], {"source_location": reader.$cursor()})));
              }              $b = self.$next_section(reader, section, attributes), $a = $to_ary($b), (new_section = ($a[0] == null ? nil : $a[0])), (attributes = ($a[1] == null ? nil : $a[1]));
              section.$assign_numeral(new_section);
              section.$blocks()['$<<'](new_section);
            } else {
              break
            }          } else {
            
            block_cursor = reader.$cursor();
            if ($truthy((new_block = self.$next_block(reader, ($truthy(($ret_or_1 = intro)) ? ($ret_or_1) : (section)), attributes, $hash2(["parse_metadata"], {"parse_metadata": false}))))) {
              
              if ($truthy(part)) {
                if ($not(section['$blocks?']())) {
                  if ($neqeq(new_block.$style(), "partintro")) {
                    if (($eqeq(new_block.$style(), "open") && ($eqeq(new_block.$context(), "open")))) {
                      new_block['$style=']("partintro");
                    } else {
                      
                      new_block['$parent=']((intro = $$('Block').$new(section, "open", $hash2(["content_model"], {"content_model": "compound"}))));
                      intro['$style=']("partintro");
                      section.$blocks()['$<<'](intro);
                    }
                  } else if ($eqeq(new_block.$content_model(), "simple")) {
                    
                    new_block['$content_model=']("compound");
                    new_block['$<<']($$('Block').$new(new_block, "paragraph", $hash2(["source", "subs"], {"source": new_block.$lines(), "subs": new_block.$subs()})));
                    new_block.$lines().$clear();
                    new_block.$subs().$clear();
                  }
                } else if ($eqeq(section.$blocks().$size(), 1)) {
                  
                  first_block = section.$blocks()['$[]'](0);
                  if (($not(intro) && ($eqeq(first_block.$content_model(), "compound")))) {
                    self.$logger().$error(self.$message_with_context("illegal block content outside of partintro block", $hash2(["source_location"], {"source_location": block_cursor})));
                  } else if ($neqeq(first_block.$content_model(), "compound")) {
                    
                    new_block['$parent=']((intro = $$('Block').$new(section, "open", $hash2(["content_model"], {"content_model": "compound"}))));
                    if ($eqeq(first_block.$style(), ($a = ["partintro"], $send(intro, 'style=', $a), $a[$a.length - 1]))) {
                      
                      first_block['$context=']("paragraph");
                      first_block['$style='](nil);
                    }                    section.$blocks().$shift();
                    intro['$<<'](first_block);
                    section.$blocks()['$<<'](intro);
                  }                }
              }              ($truthy(($ret_or_1 = intro)) ? ($ret_or_1) : (section)).$blocks()['$<<'](new_block);
              attributes.$clear();
            }          }          if ($truthy(($ret_or_1 = reader.$skip_blank_lines()))) ; else {
            break
          }        }        if ($truthy(part)) {
          if (!($truthy(section['$blocks?']()) && ($eqeq(section.$blocks()['$[]'](-1).$context(), "section")))) {
            self.$logger().$error(self.$message_with_context("invalid part, must have at least one section (e.g., chapter, appendix, etc.)", $hash2(["source_location"], {"source_location": reader.$cursor()})));
          }
        } else if ($truthy(preamble)) {
          if ($truthy(preamble['$blocks?']())) {
            if ((($truthy(book) || ($truthy(document.$blocks()['$[]'](1)))) || ($not($$('Compliance').$unwrap_standalone_preamble())))) {
              if ($truthy(document.$sourcemap())) {
                preamble['$source_location='](preamble.$blocks()['$[]'](0).$source_location());
              }
            } else {
              
              document.$blocks().$shift();
              while ($truthy((child_block = preamble.$blocks().$shift()))) {
              document['$<<'](child_block);
              }            }
          } else {
            document.$blocks().$shift();
          }
        }        return [($eqeq(section, parent) ? (nil) : (section)), attributes.$merge()];
      }, -3);
      $defs(self, '$next_block', function $$next_block(reader, parent, attributes, options) {
        var $a, $b, self = this, skipped = nil, text_only = nil, document = nil, $ret_or_1 = nil, extensions = nil, block_extensions = nil, block_macro_extensions = nil, this_line = nil, doc_attrs = nil, style = nil, block = nil, block_context = nil, cloaked_context = nil, terminator = nil, delimited_block = nil, indented = nil, md_syntax = nil, ch0 = nil, layout_break_chars = nil, ll = nil, blk_ctx = nil, target = nil, blk_attrs = nil, posattrs = nil, expanded_target = nil, $ret_or_2 = nil, scaledwidth = nil, block_title = nil, extension = nil, report_unknown_block_macro = nil, content = nil, ext_config = nil, default_attrs = nil, float_id = nil, float_reftext = nil, float_level = nil, lines = nil, content_adjacent = nil, admonition_name = nil, credit_line = nil, attribution = nil, citetitle = nil, language = nil, comma_idx = nil, block_cursor = nil, block_reader = nil, content_model = nil, positional_attrs = nil, block_id = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (attributes == null) attributes = $hash2([], {});
        if (options == null) options = $hash2([], {});
        if (!$truthy((skipped = reader.$skip_blank_lines()))) {
          return nil
        }        if (($truthy((text_only = options['$[]']("text_only"))) && ($truthy($rb_gt(skipped, 0))))) {
          
          options.$delete("text_only");
          text_only = nil;
        }        document = parent.$document();
        if ($truthy(options.$fetch("parse_metadata", true))) {
          while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {
          
            reader.$shift();
            if ($truthy(($ret_or_1 = reader.$skip_blank_lines()))) ; else {
              return nil
            }          }
        }        if ($truthy((extensions = document.$extensions()))) {
          $a = [extensions['$blocks?'](), extensions['$block_macros?']()], (block_extensions = $a[0]), (block_macro_extensions = $a[1]);
        }        reader.$mark();
        $a = [reader.$read_line(), document.$attributes(), attributes['$[]'](1)], (this_line = $a[0]), (doc_attrs = $a[1]), (style = $a[2]);
        block = (block_context = (cloaked_context = (terminator = nil)));
        if ($truthy((delimited_block = self['$is_delimited_block?'](this_line, true)))) {
          
          block_context = (cloaked_context = delimited_block.$context());
          terminator = delimited_block.$terminator();
          if ($truthy(style)) {
            if (!$eqeq(style, block_context.$to_s())) {
              if ($truthy(delimited_block.$masq()['$include?'](style))) {
                block_context = style.$to_sym();
              } else if (($truthy(delimited_block.$masq()['$include?']("admonition")) && ($truthy($$('ADMONITION_STYLES')['$include?'](style))))) {
                block_context = "admonition";
              } else if (($truthy(block_extensions) && ($truthy(extensions['$registered_for_block?'](style, block_context))))) {
                block_context = style.$to_sym();
              } else {
                
                if ($truthy(self.$logger()['$debug?']())) {
                  self.$logger().$debug(self.$message_with_context("unknown style for " + (block_context) + " block: " + (style), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
                }                style = block_context.$to_s();
              }
            }
          } else {
            style = ($a = ["style", block_context.$to_s()], $send(attributes, '[]=', $a), $a[$a.length - 1]);
          }        }        if (!$truthy(delimited_block)) {
          while ($truthy(true)) {
          
            if ((($truthy(style) && ($truthy($$('Compliance').$strict_verbatim_paragraphs()))) && ($truthy($$('VERBATIM_STYLES')['$include?'](style))))) {
              
              block_context = style.$to_sym();
              reader.$unshift_line(this_line);
              break;
            }            if ($truthy(text_only)) {
              indented = this_line['$start_with?'](" ", $$('TAB'));
            } else {
              
              md_syntax = $$('Compliance').$markdown_syntax();
              if ($truthy(this_line['$start_with?'](" "))) {
                
                $a = [true, " "], (indented = $a[0]), (ch0 = $a[1]);
                if ((($truthy(md_syntax) && ($truthy($send(this_line.$lstrip(), 'start_with?', $to_a($$('MARKDOWN_THEMATIC_BREAK_CHARS').$keys()))))) && ($truthy($$('MarkdownThematicBreakRx')['$match?'](this_line))))) {
                  
                  block = $$('Block').$new(parent, "thematic_break", $hash2(["content_model"], {"content_model": "empty"}));
                  break;
                }              } else if ($truthy(this_line['$start_with?']($$('TAB')))) {
                $a = [true, $$('TAB')], (indented = $a[0]), (ch0 = $a[1]);
              } else {
                
                $a = [false, this_line.$chr()], (indented = $a[0]), (ch0 = $a[1]);
                layout_break_chars = ($truthy(md_syntax) ? ($$('HYBRID_LAYOUT_BREAK_CHARS')) : ($$('LAYOUT_BREAK_CHARS')));
                if (($truthy(layout_break_chars['$key?'](ch0)) && ($truthy(($truthy(md_syntax) ? ($$('ExtLayoutBreakRx')['$match?'](this_line)) : ($truthy(($ret_or_1 = self['$uniform?'](this_line, ch0, (ll = this_line.$length())))) ? ($rb_gt(ll, 2)) : ($ret_or_1))))))) {
                  
                  block = $$('Block').$new(parent, layout_break_chars['$[]'](ch0), $hash2(["content_model"], {"content_model": "empty"}));
                  break;
                } else if (($truthy(this_line['$end_with?']("]")) && ($truthy(this_line['$include?']("::"))))) {
                  if ((($eqeq(ch0, "i") || ($truthy(this_line['$start_with?']("video:", "audio:")))) && ($truthy($$('BlockMediaMacroRx')['$=~'](this_line))))) {
                    
                    $a = [(($b = $gvars['~']) === nil ? nil : $b['$[]'](1)).$to_sym(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (blk_ctx = $a[0]), (target = $a[1]), (blk_attrs = $a[2]);
                    block = $$('Block').$new(parent, blk_ctx, $hash2(["content_model"], {"content_model": "empty"}));
                    if ($truthy(blk_attrs)) {
                      
                      
                      switch (blk_ctx) {
                        case "video":
                          posattrs = ["poster", "width", "height"];
                          break;
                        case "audio":
                          posattrs = [];
                          break;
                        default:
                          posattrs = ["alt", "width", "height"];
                      }                      block.$parse_attributes(blk_attrs, posattrs, $hash2(["sub_input", "into"], {"sub_input": true, "into": attributes}));
                    }                    if ($truthy(attributes['$key?']("style"))) {
                      attributes.$delete("style");
                    }                    if ($truthy(target['$include?']($$('ATTR_REF_HEAD')))) {
                      if ((($truthy((expanded_target = block.$sub_attributes(target))['$empty?']()) && ($eqeq(($truthy(($ret_or_1 = doc_attrs['$[]']("attribute-missing"))) ? ($ret_or_1) : ($$('Compliance').$attribute_missing())), "drop-line"))) && ($truthy(block.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']())))) {
                        
                        attributes.$clear();
                        return nil;
                      } else {
                        target = expanded_target;
                      }
                    }                    if ($eqeq(blk_ctx, "image")) {
                      
                      document.$register("images", target);
                      attributes['$[]=']("imagesdir", doc_attrs['$[]']("imagesdir"));
                      if ($truthy(($ret_or_1 = attributes['$[]']("alt")))) ; else {
                        attributes['$[]=']("alt", ($truthy(($ret_or_2 = style)) ? ($ret_or_2) : (($a = ["default-alt", $$('Helpers').$basename(target, true).$tr("_-", " ")], $send(attributes, '[]=', $a), $a[$a.length - 1]))));
                      }                      if (!$truthy((scaledwidth = attributes.$delete("scaledwidth"))['$nil_or_empty?']())) {
                        attributes['$[]=']("scaledwidth", ($truthy($$('TrailingDigitsRx')['$match?'](scaledwidth)) ? ("" + (scaledwidth) + "%") : (scaledwidth)));
                      }                      if ($truthy(attributes['$[]']("title"))) {
                        
                        block['$title=']((block_title = attributes.$delete("title")));
                        block.$assign_caption(attributes.$delete("caption"), "figure");
                      }                    }                    attributes['$[]=']("target", target);
                    break;
                  } else if ((($eqeq(ch0, "t") && ($truthy(this_line['$start_with?']("toc:")))) && ($truthy($$('BlockTocMacroRx')['$=~'](this_line))))) {
                    
                    block = $$('Block').$new(parent, "toc", $hash2(["content_model"], {"content_model": "empty"}));
                    if ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))) {
                      block.$parse_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), [], $hash2(["into"], {"into": attributes}));
                    }                    break;
                  } else if ($truthy(($truthy(block_macro_extensions) ? (($truthy(($ret_or_1 = ($truthy(($ret_or_2 = $$('CustomBlockMacroRx')['$=~'](this_line))) ? ((extension = extensions['$registered_for_block_macro?']((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))) : ($ret_or_2)))) ? ($ret_or_1) : ((report_unknown_block_macro = self.$logger()['$debug?']())))) : (($truthy(($ret_or_1 = self.$logger()['$debug?']())) ? ((report_unknown_block_macro = $$('CustomBlockMacroRx')['$=~'](this_line))) : ($ret_or_1)))))) {
                    if ($truthy(report_unknown_block_macro)) {
                      self.$logger().$debug(self.$message_with_context("unknown name for block macro: " + ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
                    } else {
                      
                      content = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
                      if ($truthy((target = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))['$include?']($$('ATTR_REF_HEAD')))) {
                        if ((($truthy((expanded_target = parent.$sub_attributes(target))['$empty?']()) && ($eqeq(($truthy(($ret_or_1 = doc_attrs['$[]']("attribute-missing"))) ? ($ret_or_1) : ($$('Compliance').$attribute_missing())), "drop-line"))) && ($truthy(parent.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']())))) {
                          
                          attributes.$clear();
                          return nil;
                        } else {
                          target = expanded_target;
                        }
                      }                      if ($eqeq((ext_config = extension.$config())['$[]']("content_model"), "attributes")) {
                        if ($truthy(content)) {
                          document.$parse_attributes(content, ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ext_config['$[]']("positional_attrs"))) ? ($ret_or_2) : (ext_config['$[]']("pos_attrs"))))) ? ($ret_or_1) : ([])), $hash2(["sub_input", "into"], {"sub_input": true, "into": attributes}));
                        }
                      } else {
                        attributes['$[]=']("text", ($truthy(($ret_or_1 = content)) ? ($ret_or_1) : ("")));
                      }                      if ($truthy((default_attrs = ext_config['$[]']("default_attrs")))) {
                        $send(attributes, 'update', [default_attrs], function $$6(_, old_v){
                          if (old_v == null) old_v = nil;
                          return old_v;});
                      }                      if (($truthy((block = extension.$process_method()['$[]'](parent, target, attributes))) && ($neqeq(block, parent)))) {
                        
                        attributes.$replace(block.$attributes());
                        break;
                      } else {
                        
                        attributes.$clear();
                        return nil;
                      }                    }
                  }
                }              }            }            if ((($not(indented) && ($eqeq((ch0 = ($truthy(($ret_or_1 = ch0)) ? ($ret_or_1) : (this_line.$chr()))), "<"))) && ($truthy($$('CalloutListRx')['$=~'](this_line))))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_callout_list(reader, $gvars["~"], parent, document.$callouts());
              attributes['$[]=']("style", "arabic");
              break;
            } else if ($truthy($$('UnorderedListRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              if ((($not(style) && ($eqeqeq($$('Section'), parent))) && ($eqeq(parent.$sectname(), "bibliography")))) {
                attributes['$[]=']("style", (style = "bibliography"));
              }              block = self.$parse_list(reader, "ulist", parent, style);
              break;
            } else if ($truthy($$('OrderedListRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_list(reader, "olist", parent, style);
              if ($truthy(block.$style())) {
                attributes['$[]=']("style", block.$style());
              }              break;
            } else if ((($truthy(this_line['$include?']("::")) || ($truthy(this_line['$include?'](";;")))) && ($truthy($$('DescriptionListRx')['$=~'](this_line))))) {
              
              reader.$unshift_line(this_line);
              block = self.$parse_description_list(reader, $gvars["~"], parent);
              break;
            } else if ((($eqeq(style, "float") || ($eqeq(style, "discrete"))) && ($truthy(($truthy($$('Compliance').$underline_style_section_titles()) ? (self['$is_section_title?'](this_line, reader.$peek_line())) : ($truthy(($ret_or_1 = indented['$!']())) ? (self['$atx_section_title?'](this_line)) : ($ret_or_1))))))) {
              
              reader.$unshift_line(this_line);
              $b = self.$parse_section_title(reader, document, attributes['$[]']("id")), $a = $to_ary($b), (float_id = ($a[0] == null ? nil : $a[0])), (float_reftext = ($a[1] == null ? nil : $a[1])), (block_title = ($a[2] == null ? nil : $a[2])), (float_level = ($a[3] == null ? nil : $a[3]));
              if ($truthy(float_reftext)) {
                attributes['$[]=']("reftext", float_reftext);
              }              block = $$('Block').$new(parent, "floating_title", $hash2(["content_model"], {"content_model": "empty"}));
              block['$title='](block_title);
              attributes.$delete("title");
              block['$id='](($truthy(($ret_or_1 = float_id)) ? ($ret_or_1) : (($truthy(doc_attrs['$key?']("sectids")) ? ($$('Section').$generate_id(block.$title(), document)) : (nil)))));
              block['$level='](float_level);
              break;
            } else if (($truthy(style) && ($neqeq(style, "normal")))) {
              if ($truthy($$('PARAGRAPH_STYLES')['$include?'](style))) {
                
                block_context = style.$to_sym();
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;
              } else if ($truthy($$('ADMONITION_STYLES')['$include?'](style))) {
                
                block_context = "admonition";
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;
              } else if (($truthy(block_extensions) && ($truthy(extensions['$registered_for_block?'](style, "paragraph"))))) {
                
                block_context = style.$to_sym();
                cloaked_context = "paragraph";
                reader.$unshift_line(this_line);
                break;
              } else {
                
                if ($truthy(self.$logger()['$debug?']())) {
                  self.$logger().$debug(self.$message_with_context("unknown style for paragraph: " + (style), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
                }                style = nil;
              }
            }            reader.$unshift_line(this_line);
            if (($truthy(indented) && ($not(style)))) {
              
              lines = self.$read_paragraph_lines(reader, (content_adjacent = ($eqeq(skipped, 0) ? (options['$[]']("list_type")) : (nil))), $hash2(["skip_line_comments"], {"skip_line_comments": text_only}));
              self['$adjust_indentation!'](lines);
              if (($truthy(text_only) || ($eqeq(content_adjacent, "dlist")))) {
                block = $$('Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              } else {
                block = $$('Block').$new(parent, "literal", $hash2(["content_model", "source", "attributes"], {"content_model": "verbatim", "source": lines, "attributes": attributes}));
              }            } else {
              
              lines = self.$read_paragraph_lines(reader, ($truthy(($ret_or_1 = skipped['$=='](0))) ? (options['$[]']("list_type")) : ($ret_or_1)), $hash2(["skip_line_comments"], {"skip_line_comments": true}));
              if ($truthy(text_only)) {
                
                if (($truthy(indented) && ($eqeq(style, "normal")))) {
                  self['$adjust_indentation!'](lines);
                }                block = $$('Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              } else if ((($truthy($$('ADMONITION_STYLE_HEADS')['$include?'](ch0)) && ($truthy(this_line['$include?'](":")))) && ($truthy($$('AdmonitionParagraphRx')['$=~'](this_line))))) {
                
                lines['$[]='](0, (($a = $gvars['~']) === nil ? nil : $a.$post_match()));
                attributes['$[]=']("name", (admonition_name = ($a = ["style", (($b = $gvars['~']) === nil ? nil : $b['$[]'](1))], $send(attributes, '[]=', $a), $a[$a.length - 1]).$downcase()));
                attributes['$[]=']("textlabel", ($truthy(($ret_or_1 = attributes.$delete("caption"))) ? ($ret_or_1) : (doc_attrs['$[]']("" + (admonition_name) + "-caption"))));
                block = $$('Block').$new(parent, "admonition", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              } else if ((($truthy(md_syntax) && ($eqeq(ch0, ">"))) && ($truthy(this_line['$start_with?']("> "))))) {
                
                $send(lines, 'map!', [], function $$7(line){
                  
                  if (line == null) line = nil;
                  if ($eqeq(line, ">")) {
                    
                    return line.$slice(1, line.$length());
                  } else {
                    
                    if ($truthy(line['$start_with?']("> "))) {
                      
                      return line.$slice(2, line.$length());
                    } else {
                      return line
                    }                  }});
                if ($truthy(lines['$[]'](-1)['$start_with?']("-- "))) {
                  
                  credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                  if (!$truthy(lines['$empty?']())) {
                    while ($truthy(lines['$[]'](-1)['$empty?']())) {
                    lines.$pop();
                    }
                  }                }                attributes['$[]=']("style", "quote");
                block = self.$build_block("quote", "compound", false, parent, $$('Reader').$new(lines), attributes);
                if ($truthy(credit_line)) {
                  
                  $b = block.$apply_subs(credit_line).$split(", ", 2), $a = $to_ary($b), (attribution = ($a[0] == null ? nil : $a[0])), (citetitle = ($a[1] == null ? nil : $a[1]));
                  if ($truthy(attribution)) {
                    attributes['$[]=']("attribution", attribution);
                  }                  if ($truthy(citetitle)) {
                    attributes['$[]=']("citetitle", citetitle);
                  }                }              } else if (((($eqeq(ch0, "\"") && ($truthy($rb_gt(lines.$size(), 1)))) && ($truthy(lines['$[]'](-1)['$start_with?']("-- ")))) && ($truthy(lines['$[]'](-2)['$end_with?']("\""))))) {
                
                lines['$[]='](0, this_line.$slice(1, this_line.$length()));
                credit_line = (credit_line = lines.$pop()).$slice(3, credit_line.$length());
                while ($truthy(lines['$[]'](-1)['$empty?']())) {
                lines.$pop();
                }                lines['$<<'](lines.$pop().$chop());
                attributes['$[]=']("style", "quote");
                block = $$('Block').$new(parent, "quote", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
                $b = block.$apply_subs(credit_line).$split(", ", 2), $a = $to_ary($b), (attribution = ($a[0] == null ? nil : $a[0])), (citetitle = ($a[1] == null ? nil : $a[1]));
                if ($truthy(attribution)) {
                  attributes['$[]=']("attribution", attribution);
                }                if ($truthy(citetitle)) {
                  attributes['$[]=']("citetitle", citetitle);
                }              } else {
                
                if (($truthy(indented) && ($eqeq(style, "normal")))) {
                  self['$adjust_indentation!'](lines);
                }                block = $$('Block').$new(parent, "paragraph", $hash2(["content_model", "source", "attributes"], {"content_model": "simple", "source": lines, "attributes": attributes}));
              }              self.$catalog_inline_anchors(lines.$join($$('LF')), block, document, reader);
            }            break;
          }
        }        if (!$truthy(block)) {
          
          switch (block_context) {
            case "listing":
            case "source":
              
              if (($eqeq(block_context, "source") || (($not(attributes['$[]'](1)) && ($truthy((language = ($truthy(($ret_or_2 = attributes['$[]'](2))) ? ($ret_or_2) : (doc_attrs['$[]']("source-language")))))))))) {
                
                if ($truthy(language)) {
                  
                  attributes['$[]=']("style", "source");
                  attributes['$[]=']("language", language);
                  $$('AttributeList').$rekey(attributes, [nil, nil, "linenums"]);
                } else {
                  
                  $$('AttributeList').$rekey(attributes, [nil, "language", "linenums"]);
                  if (!$truthy(attributes['$key?']("language"))) {
                    if ($truthy(doc_attrs['$key?']("source-language"))) {
                      attributes['$[]=']("language", doc_attrs['$[]']("source-language"));
                    }
                  }                }                if (!$truthy(attributes['$key?']("linenums"))) {
                  if (($truthy(attributes['$[]']("linenums-option")) || ($truthy(doc_attrs['$[]']("source-linenums-option"))))) {
                    attributes['$[]=']("linenums", "");
                  }
                }                if (!$truthy(attributes['$key?']("indent"))) {
                  if ($truthy(doc_attrs['$key?']("source-indent"))) {
                    attributes['$[]=']("indent", doc_attrs['$[]']("source-indent"));
                  }
                }              }              block = self.$build_block("listing", "verbatim", terminator, parent, reader, attributes);
              break;
            case "fenced_code":
              
              attributes['$[]=']("style", "source");
              if ($truthy($rb_gt((ll = this_line.$length()), 3))) {
                if ($truthy((comma_idx = (language = this_line.$slice(3, ll)).$index(",")))) {
                  if ($truthy($rb_gt(comma_idx, 0))) {
                    
                    language = language.$slice(0, comma_idx).$strip();
                    if ($truthy($rb_lt(comma_idx, $rb_minus(ll, 4)))) {
                      attributes['$[]=']("linenums", "");
                    }                  } else if ($truthy($rb_gt(ll, 4))) {
                    attributes['$[]=']("linenums", "");
                  }
                } else {
                  language = language.$lstrip();
                }
              }              if ($truthy(language['$nil_or_empty?']())) {
                if ($truthy(doc_attrs['$key?']("source-language"))) {
                  attributes['$[]=']("language", doc_attrs['$[]']("source-language"));
                }
              } else {
                attributes['$[]=']("language", language);
              }              if (!$truthy(attributes['$key?']("linenums"))) {
                if (($truthy(attributes['$[]']("linenums-option")) || ($truthy(doc_attrs['$[]']("source-linenums-option"))))) {
                  attributes['$[]=']("linenums", "");
                }
              }              if (!$truthy(attributes['$key?']("indent"))) {
                if ($truthy(doc_attrs['$key?']("source-indent"))) {
                  attributes['$[]=']("indent", doc_attrs['$[]']("source-indent"));
                }
              }              terminator = terminator.$slice(0, 3);
              block = self.$build_block("listing", "verbatim", terminator, parent, reader, attributes);
              break;
            case "table":
              
              block_cursor = reader.$cursor();
              block_reader = $$('Reader').$new(reader.$read_lines_until($hash2(["terminator", "skip_line_comments", "context", "cursor"], {"terminator": terminator, "skip_line_comments": true, "context": "table", "cursor": "at_mark"})), block_cursor);
              if (!$truthy(terminator['$start_with?']("|", "!"))) {
                if ($truthy(($ret_or_2 = attributes['$[]']("format")))) ; else {
                  attributes['$[]=']("format", ($truthy(terminator['$start_with?'](",")) ? ("csv") : ("dsv")));
                }
              }              block = self.$parse_table(block_reader, parent, attributes);
              break;
            case "sidebar":
              block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes);
              break;
            case "admonition":
              
              attributes['$[]=']("name", (admonition_name = style.$downcase()));
              attributes['$[]=']("textlabel", ($truthy(($ret_or_2 = attributes.$delete("caption"))) ? ($ret_or_2) : (doc_attrs['$[]']("" + (admonition_name) + "-caption"))));
              block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes);
              break;
            case "open":
            case "abstract":
            case "partintro":
              block = self.$build_block("open", "compound", terminator, parent, reader, attributes);
              break;
            case "literal":
              block = self.$build_block(block_context, "verbatim", terminator, parent, reader, attributes);
              break;
            case "example":
              
              if ($truthy(attributes['$[]']("collapsible-option"))) {
                attributes['$[]=']("caption", "");
              }              block = self.$build_block(block_context, "compound", terminator, parent, reader, attributes);
              break;
            case "quote":
            case "verse":
              
              $$('AttributeList').$rekey(attributes, [nil, "attribution", "citetitle"]);
              block = self.$build_block(block_context, ($eqeq(block_context, "verse") ? ("verbatim") : ("compound")), terminator, parent, reader, attributes);
              break;
            case "stem":
            case "latexmath":
            case "asciimath":
              
              if ($eqeq(block_context, "stem")) {
                attributes['$[]=']("style", $$('STEM_TYPE_ALIASES')['$[]'](($truthy(($ret_or_2 = attributes['$[]'](2))) ? ($ret_or_2) : (doc_attrs['$[]']("stem")))));
              }              block = self.$build_block("stem", "raw", terminator, parent, reader, attributes);
              break;
            case "pass":
              block = self.$build_block(block_context, "raw", terminator, parent, reader, attributes);
              break;
            case "comment":
              
              self.$build_block(block_context, "skip", terminator, parent, reader, attributes);
              attributes.$clear();
              return nil;
            default:
              if (($truthy(block_extensions) && ($truthy((extension = extensions['$registered_for_block?'](block_context, cloaked_context)))))) {
                
                if (!$eqeq((content_model = (ext_config = extension.$config())['$[]']("content_model")), "skip")) {
                  
                  if (!$truthy((positional_attrs = ($truthy(($ret_or_2 = ext_config['$[]']("positional_attrs"))) ? ($ret_or_2) : (ext_config['$[]']("pos_attrs"))))['$nil_or_empty?']())) {
                    $$('AttributeList').$rekey(attributes, $rb_plus([nil], positional_attrs));
                  }                  if ($truthy((default_attrs = ext_config['$[]']("default_attrs")))) {
                    $send(default_attrs, 'each', [], function $$8(k, v){var $c;

                      
                      if (k == null) k = nil;
                      if (v == null) v = nil;
                      if ($truthy(($ret_or_2 = attributes['$[]'](k)))) {
                        return $ret_or_2
                      } else {
                        return ($c = [k, v], $send(attributes, '[]=', $c), $c[$c.length - 1])
                      }});
                  }                  attributes['$[]=']("cloaked-context", cloaked_context);
                }                if (!$truthy((block = self.$build_block(block_context, content_model, terminator, parent, reader, attributes, $hash2(["extension"], {"extension": extension}))))) {
                  
                  attributes.$clear();
                  return nil;
                }              } else {
                self.$raise("Unsupported block type " + (block_context) + " at " + (reader.$cursor()));
              }
          }
        }        if ($truthy(document.$sourcemap())) {
          block['$source_location='](reader.$cursor_at_mark());
        }        if ($truthy(attributes['$[]']("title"))) {
          
          block['$title=']((block_title = attributes.$delete("title")));
          if ($truthy($$('CAPTION_ATTRIBUTE_NAMES')['$[]'](block.$context()))) {
            block.$assign_caption(attributes.$delete("caption"));
          }        }        block['$style='](attributes['$[]']("style"));
        if ($truthy((block_id = ($truthy(($ret_or_1 = block.$id())) ? ($ret_or_1) : (($a = [attributes['$[]']("id")], $send(block, 'id=', $a), $a[$a.length - 1])))))) {
          
          if ($truthy(($truthy(block_title) ? (block_title['$include?']($$('ATTR_REF_HEAD'))) : (block['$title?']())))) {
            block.$title();
          }          if (!$truthy(document.$register("refs", [block_id, block]))) {
            self.$logger().$warn(self.$message_with_context("id assigned to block already in use: " + (block_id), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
          }        }        if (!$truthy(attributes['$empty?']())) {
          block.$update_attributes(attributes);
        }        block.$commit_subs();
        if ($truthy(block['$sub?']("callouts"))) {
          if (!$truthy(self.$catalog_callouts(block.$source(), document))) {
            block.$remove_sub("callouts");
          }
        }        return block;
      }, -3);
      $defs(self, '$read_paragraph_lines', function $$read_paragraph_lines(reader, break_at_list, opts) {
        var break_condition = nil;

        
        if (opts == null) opts = $hash2([], {});
        opts['$[]=']("break_on_blank_lines", true);
        opts['$[]=']("break_on_list_continuation", true);
        opts['$[]=']("preserve_last_line", true);
        break_condition = ($truthy(break_at_list) ? (($truthy($$('Compliance').$block_terminates_paragraph()) ? ($$('StartOfBlockOrListProc')) : ($$('StartOfListProc')))) : (($truthy($$('Compliance').$block_terminates_paragraph()) ? ($$('StartOfBlockProc')) : ($$('NoOp')))));
        return $send(reader, 'read_lines_until', [opts], break_condition.$to_proc());
      }, -3);
      $defs(self, '$is_delimited_block?', function $Parser_is_delimited_block$ques$9(line, return_match_data) {
        var $a, $b, self = this, line_len = nil, tip = nil, tip_len = nil, context = nil, masq = nil;

        
        if (return_match_data == null) return_match_data = nil;
        if (!($truthy($rb_gt((line_len = line.$length()), 1)) && ($truthy($$('DELIMITED_BLOCK_HEADS')['$[]'](line.$slice(0, 2)))))) {
          return nil
        }        if ($eqeq(line_len, 2)) {
          
          tip = line;
          tip_len = 2;
        } else {
          
          if ($truthy($rb_lt(line_len, 5))) {
            
            tip = line;
            tip_len = line_len;
          } else {
            tip = line.$slice(0, (tip_len = 4));
          }          if (($truthy($$('Compliance').$markdown_syntax()) && ($truthy(tip['$start_with?']("`"))))) {
            if ($eqeq(tip_len, 4)) {
              
              if (($eqeq(tip, "````") || ($neqeq((tip = tip.$chop()), "```")))) {
                return nil
              }              line = tip;
              line_len = (tip_len = 3);
            } else if ($neqeq(tip, "```")) {
              return nil
            }
          } else if ($eqeq(tip_len, 3)) {
            return nil
          }        }        $b = $$('DELIMITED_BLOCKS')['$[]'](tip), $a = $to_ary($b), (context = ($a[0] == null ? nil : $a[0])), (masq = ($a[1] == null ? nil : $a[1]));
        if (($truthy(context) && (($eqeq(line_len, tip_len) || ($truthy(self['$uniform?'](line.$slice(1, line_len), $$('DELIMITED_BLOCK_TAILS')['$[]'](tip), $rb_minus(line_len, 1)))))))) {
          if ($truthy(return_match_data)) {
            
            return $$('BlockMatchData').$new(context, masq, tip, line);
          } else {
            return true
          }
        } else {
          return nil
        }      }, -2);
      $defs(self, '$build_block', function $$build_block(block_context, content_model, terminator, parent, reader, attributes, options) {
        var $a, self = this, skip_processing = nil, parse_as_content_model = nil, lines = nil, block_reader = nil, block_cursor = nil, tab_size = nil, $ret_or_2 = nil, indent = nil, extension = nil, block = nil, $ret_or_1 = nil;

        
        if (options == null) options = $hash2([], {});
        
        switch (content_model) {
          case "skip":
            $a = [true, "simple"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]);
            break;
          case "raw":
            $a = [false, "simple"], (skip_processing = $a[0]), (parse_as_content_model = $a[1]);
            break;
          default:
            $a = [false, content_model], (skip_processing = $a[0]), (parse_as_content_model = $a[1]);
        }        if ($truthy(terminator['$nil?']())) {
          
          if ($eqeq(parse_as_content_model, "verbatim")) {
            lines = reader.$read_lines_until($hash2(["break_on_blank_lines", "break_on_list_continuation"], {"break_on_blank_lines": true, "break_on_list_continuation": true}));
          } else {
            
            if ($eqeq(content_model, "compound")) {
              content_model = "simple";
            }            lines = self.$read_paragraph_lines(reader, false, $hash2(["skip_line_comments", "skip_processing"], {"skip_line_comments": true, "skip_processing": skip_processing}));
          }          block_reader = nil;
        } else if ($neqeq(parse_as_content_model, "compound")) {
          
          lines = reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], {"terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark"}));
          block_reader = nil;
        } else if ($eqeq(terminator, false)) {
          
          lines = nil;
          block_reader = reader;
        } else {
          
          lines = nil;
          block_cursor = reader.$cursor();
          block_reader = $$('Reader').$new(reader.$read_lines_until($hash2(["terminator", "skip_processing", "context", "cursor"], {"terminator": terminator, "skip_processing": skip_processing, "context": block_context, "cursor": "at_mark"})), block_cursor);
        }        
        switch (content_model) {
          case "verbatim":
            
            tab_size = ($truthy(($ret_or_2 = attributes['$[]']("tabsize"))) ? ($ret_or_2) : (parent.$document().$attributes()['$[]']("tabsize"))).$to_i();
            if ($truthy((indent = attributes['$[]']("indent")))) {
              self['$adjust_indentation!'](lines, indent.$to_i(), tab_size);
            } else if ($truthy($rb_gt(tab_size, 0))) {
              self['$adjust_indentation!'](lines, -1, tab_size);
            }            break;
          case "skip":
            return nil
        }        if ($truthy((extension = options['$[]']("extension")))) {
          
          attributes.$delete("style");
          if (($truthy((block = extension.$process_method()['$[]'](parent, ($truthy(($ret_or_1 = block_reader)) ? ($ret_or_1) : ($$('Reader').$new(lines))), attributes.$merge()))) && ($neqeq(block, parent)))) {
            
            attributes.$replace(block.$attributes());
            if ((($eqeq(block.$content_model(), "compound") && ($eqeqeq($$('Block'), block))) && ($not((lines = block.$lines())['$empty?']())))) {
              
              content_model = "compound";
              block_reader = $$('Reader').$new(lines);
            }          } else {
            return nil
          }        } else {
          block = $$('Block').$new(parent, block_context, $hash2(["content_model", "source", "attributes"], {"content_model": content_model, "source": lines, "attributes": attributes}));
        }        if ($eqeq(content_model, "compound")) {
          self.$parse_blocks(block_reader, block);
        }        return block;
      }, -7);
      $defs(self, '$parse_blocks', function $$parse_blocks(reader, parent, attributes) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil, block = nil;

        
        if (attributes == null) attributes = nil;
        if ($truthy(attributes)) {
          while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = (block = self.$next_block(reader, parent, attributes.$merge())))) ? (parent.$blocks()['$<<'](block)) : ($ret_or_2)))) ? ($ret_or_1) : (reader['$has_more_lines?']())))) {
          
          }
        } else {
          while ($truthy(($truthy(($ret_or_1 = ($truthy(($ret_or_2 = (block = self.$next_block(reader, parent)))) ? (parent.$blocks()['$<<'](block)) : ($ret_or_2)))) ? ($ret_or_1) : (reader['$has_more_lines?']())))) {
          
          }
        }        return nil;
      }, -3);
      $defs(self, '$parse_list', function $$parse_list(reader, list_type, parent, style) {
        var $a, self = this, list_block = nil, list_rx = nil, $ret_or_1 = nil, list_item = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        list_block = $$('List').$new(parent, list_type);
        list_rx = $$('ListRxMap')['$[]'](list_type);
        while ($truthy(($truthy(($ret_or_1 = reader['$has_more_lines?']())) ? (list_rx['$=~'](reader.$peek_line())) : ($ret_or_1)))) {
        
          if ($truthy((list_item = self.$parse_list_item(reader, list_block, $gvars["~"], (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), style)))) {
            list_block.$items()['$<<'](list_item);
          }          if ($truthy(($ret_or_1 = reader.$skip_blank_lines()))) ; else {
            break
          }        }        return list_block;
      });
      $defs(self, '$catalog_callouts', function $$catalog_callouts(text, document) {
        var found = nil, autonum = nil;

        
        found = false;
        autonum = 0;
        if ($truthy(text['$include?']("<"))) {
          $send(text, 'scan', [$$('CalloutScanRx')], function $$10(){var $a;

            
            if (!$truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']("\\"))) {
              document.$callouts().$register(($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), ".") ? ((autonum = $rb_plus(autonum, 1)).$to_s()) : ((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))));
            }            return (found = true);});
        }        return found;
      });
      $defs(self, '$catalog_inline_anchor', function $$catalog_inline_anchor(id, reftext, node, location, doc) {
        var self = this;

        
        if (doc == null) doc = node.$document();
        if (($truthy(reftext) && ($truthy(reftext['$include?']($$('ATTR_REF_HEAD')))))) {
          reftext = doc.$sub_attributes(reftext);
        }        if (!$truthy(doc.$register("refs", [id, $$('Inline').$new(node, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id}))]))) {
          
          if ($eqeqeq($$('Reader'), location)) {
            location = location.$cursor();
          }          self.$logger().$warn(self.$message_with_context("id assigned to anchor already in use: " + (id), $hash2(["source_location"], {"source_location": location})));
        }        return nil;
      }, -5);
      $defs(self, '$catalog_inline_anchors', function $$catalog_inline_anchors(text, block, document, reader) {
        var self = this;

        
        if (($truthy(text['$include?']("[[")) || ($truthy(text['$include?']("or:"))))) {
          $send(text, 'scan', [$$('InlineAnchorScanRx')], function $$11(){var $a, self = $$11.$$s == null ? this : $$11.$$s, id = nil, reftext = nil, location = nil, offset = nil;

            
            if ($truthy((id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))) {
              if ((($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) && ($truthy(reftext['$include?']($$('ATTR_REF_HEAD'))))) && ($truthy((reftext = document.$sub_attributes(reftext))['$empty?']())))) {
                return nil
              }
            } else {
              
              id = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
              if ($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](4))))) {
                if ($truthy(reftext['$include?']("]"))) {
                  
                  reftext = reftext.$gsub("\\]", "]");
                  if ($truthy(reftext['$include?']($$('ATTR_REF_HEAD')))) {
                    reftext = document.$sub_attributes(reftext);
                  }                } else if ($truthy(reftext['$include?']($$('ATTR_REF_HEAD')))) {
                  if ($truthy((reftext = document.$sub_attributes(reftext))['$empty?']())) {
                    reftext = nil;
                  }
                }
              }            }            if ($truthy(document.$register("refs", [id, $$('Inline').$new(block, "anchor", reftext, $hash2(["type", "id"], {"type": "ref", "id": id}))]))) {
              return nil
            } else {
              
              location = reader.$cursor_at_mark();
              if ($truthy($rb_gt((offset = $rb_plus((($a = $gvars['~']) === nil ? nil : $a.$pre_match()).$count($$('LF')), ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](0))['$start_with?']($$('LF'))) ? (1) : (0)))), 0))) {
                (location = location.$dup()).$advance(offset);
              }              return self.$logger().$warn(self.$message_with_context("id assigned to anchor already in use: " + (id), $hash2(["source_location"], {"source_location": location})));
            }}, {$$s: self});
        }        return nil;
      });
      $defs(self, '$catalog_inline_biblio_anchor', function $$catalog_inline_biblio_anchor(id, reftext, node, reader) {
        var self = this, $ret_or_1 = nil;

        
        if (!$truthy(node.$document().$register("refs", [id, $$('Inline').$new(node, "anchor", ($truthy(($ret_or_1 = reftext)) ? ("[" + (reftext) + "]") : ($ret_or_1)), $hash2(["type", "id"], {"type": "bibref", "id": id}))]))) {
          self.$logger().$warn(self.$message_with_context("id assigned to bibliography anchor already in use: " + (id), $hash2(["source_location"], {"source_location": reader.$cursor()})));
        }        return nil;
      });
      $defs(self, '$parse_description_list', function $$parse_description_list(reader, match, parent) {
        var self = this, list_block = nil, sibling_pattern = nil, current_pair = nil, $ret_or_1 = nil, next_pair = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        list_block = $$('List').$new(parent, "dlist");
        sibling_pattern = $$('DescriptionListSiblingRx')['$[]'](match['$[]'](2));
        list_block.$items()['$<<']((current_pair = self.$parse_list_item(reader, list_block, match, sibling_pattern)));
        while ($truthy(($truthy(($ret_or_1 = reader['$has_more_lines?']())) ? (sibling_pattern['$=~'](reader.$peek_line())) : ($ret_or_1)))) {
        
          next_pair = self.$parse_list_item(reader, list_block, $gvars["~"], sibling_pattern);
          if ($truthy(current_pair['$[]'](1))) {
            list_block.$items()['$<<']((current_pair = next_pair));
          } else {
            
            current_pair['$[]'](0)['$<<'](next_pair['$[]'](0)['$[]'](0));
            current_pair['$[]='](1, next_pair['$[]'](1));
          }        }        return list_block;
      });
      $defs(self, '$parse_callout_list', function $$parse_callout_list(reader, match, parent, callouts) {
        var self = this, list_block = nil, next_index = nil, autonum = nil, $ret_or_1 = nil, $ret_or_2 = nil, num = nil, list_item = nil, coids = nil;

        
        list_block = $$('List').$new(parent, "colist");
        next_index = 1;
        autonum = 0;
        while ($truthy(($truthy(($ret_or_1 = match)) ? ($ret_or_1) : (($truthy(($ret_or_2 = (match = $$('CalloutListRx').$match(reader.$peek_line())))) ? (reader.$mark()) : ($ret_or_2)))))) {
        
          if ($eqeq((num = match['$[]'](1)), ".")) {
            num = (autonum = $rb_plus(autonum, 1)).$to_s();
          }          if (!$eqeq(num, next_index.$to_s())) {
            self.$logger().$warn(self.$message_with_context("callout list item index: expected " + (next_index) + ", got " + (num), $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
          }          if ($truthy((list_item = self.$parse_list_item(reader, list_block, match, "<1>")))) {
            
            list_block.$items()['$<<'](list_item);
            if ($truthy((coids = callouts.$callout_ids(list_block.$items().$size()))['$empty?']())) {
              self.$logger().$warn(self.$message_with_context("no callout found for <" + (list_block.$items().$size()) + ">", $hash2(["source_location"], {"source_location": reader.$cursor_at_mark()})));
            } else {
              list_item.$attributes()['$[]=']("coids", coids);
            }          }          next_index = $rb_plus(next_index, 1);
          match = nil;
        }        callouts.$next_list();
        return list_block;
      });
      $defs(self, '$parse_list_item', function $$parse_list_item(reader, list_block, match, sibling_trait, style) {
        var $a, $b, self = this, list_type = nil, dlist = nil, list_term = nil, term_text = nil, $ret_or_1 = nil, item_text = nil, has_text = nil, list_item = nil, sourcemap_assignment_deferred = nil, ordinal = nil, implicit_style = nil, $ret_or_2 = nil, $ret_or_3 = nil, block_cursor = nil, list_item_reader = nil, comment_lines = nil, subsequent_line = nil, content_adjacent = nil, block = nil, first_block = nil;

        
        if (style == null) style = nil;
        if ($eqeq((list_type = list_block.$context()), "dlist")) {
          
          dlist = true;
          list_term = $$('ListItem').$new(list_block, (term_text = match['$[]'](1)));
          if (($truthy(term_text['$start_with?']("[[")) && ($truthy($$('LeadingInlineAnchorRx')['$=~'](term_text))))) {
            self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), ($truthy(($ret_or_1 = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)))) ? ($ret_or_1) : ((($a = $gvars['~']) === nil ? nil : $a.$post_match()).$lstrip())), list_term, reader);
          }          if ($truthy((item_text = match['$[]'](3)))) {
            has_text = true;
          }          list_item = $$('ListItem').$new(list_block, item_text);
          if ($truthy(list_block.$document().$sourcemap())) {
            
            list_term['$source_location='](reader.$cursor());
            if ($truthy(has_text)) {
              list_item['$source_location='](list_term.$source_location());
            } else {
              sourcemap_assignment_deferred = true;
            }          }        } else {
          
          has_text = true;
          list_item = $$('ListItem').$new(list_block, (item_text = match['$[]'](2)));
          if ($truthy(list_block.$document().$sourcemap())) {
            list_item['$source_location='](reader.$cursor());
          }          
          switch (list_type) {
            case "ulist":
              
              list_item['$marker='](sibling_trait);
              if ($truthy(item_text['$start_with?']("["))) {
                if (($truthy(style) && ($eqeq(style, "bibliography")))) {
                  if ($truthy($$('InlineBiblioAnchorRx')['$=~'](item_text))) {
                    self.$catalog_inline_biblio_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader);
                  }
                } else if ($truthy(item_text['$start_with?']("[["))) {
                  if ($truthy($$('LeadingInlineAnchorRx')['$=~'](item_text))) {
                    self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader);
                  }
                } else if ($truthy(item_text['$start_with?']("[ ] ", "[x] ", "[*] "))) {
                  
                  list_block.$set_option("checklist");
                  list_item.$attributes()['$[]=']("checkbox", "");
                  if (!$truthy(item_text['$start_with?']("[ "))) {
                    list_item.$attributes()['$[]=']("checked", "");
                  }                  list_item['$text='](item_text.$slice(4, item_text.$length()));
                }
              }              break;
            case "olist":
              
              $b = self.$resolve_ordered_list_marker(sibling_trait, (ordinal = list_block.$items().$size()), true, reader), $a = $to_ary($b), (sibling_trait = ($a[0] == null ? nil : $a[0])), (implicit_style = ($a[1] == null ? nil : $a[1]));
              list_item['$marker='](sibling_trait);
              if (($eqeq(ordinal, 0) && ($not(style)))) {
                list_block['$style='](($truthy(($ret_or_2 = implicit_style)) ? ($ret_or_2) : (($truthy(($ret_or_3 = $$('ORDERED_LIST_STYLES')['$[]']($rb_minus(sibling_trait.$length(), 1)))) ? ($ret_or_3) : ("arabic")).$to_s())));
              }              if (($truthy(item_text['$start_with?']("[[")) && ($truthy($$('LeadingInlineAnchorRx')['$=~'](item_text))))) {
                self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader);
              }              break;
            default:
              
              list_item['$marker='](sibling_trait);
              if (($truthy(item_text['$start_with?']("[[")) && ($truthy($$('LeadingInlineAnchorRx')['$=~'](item_text))))) {
                self.$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), list_item, reader);
              }          }        }        reader.$shift();
        block_cursor = reader.$cursor();
        list_item_reader = $$('Reader').$new(self.$read_lines_for_list_item(reader, list_type, sibling_trait, has_text), block_cursor);
        if ($truthy(list_item_reader['$has_more_lines?']())) {
          
          if ($truthy(sourcemap_assignment_deferred)) {
            list_item['$source_location='](block_cursor);
          }          comment_lines = list_item_reader.$skip_line_comments();
          if ($truthy((subsequent_line = list_item_reader.$peek_line()))) {
            
            if (!$truthy(comment_lines['$empty?']())) {
              list_item_reader.$unshift_lines(comment_lines);
            }            if (!$truthy(subsequent_line['$empty?']())) {
              
              content_adjacent = true;
              if (!$truthy(dlist)) {
                has_text = nil;
              }            }          }          if ($truthy((block = self.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["text_only", "list_type"], {"text_only": ($truthy(has_text) ? (nil) : (true)), "list_type": list_type}))))) {
            list_item.$blocks()['$<<'](block);
          }          while ($truthy(list_item_reader['$has_more_lines?']())) {
          if ($truthy((block = self.$next_block(list_item_reader, list_item, $hash2([], {}), $hash2(["list_type"], {"list_type": list_type}))))) {
              list_item.$blocks()['$<<'](block);
            }
          }          if ((($truthy(content_adjacent) && ($truthy((first_block = list_item.$blocks()['$[]'](0))))) && ($eqeq(first_block.$context(), "paragraph")))) {
            list_item.$fold_first();
          }        }        if ($truthy(dlist)) {
          return [[list_term], (($truthy(list_item['$text?']()) || ($truthy(list_item['$blocks?']()))) ? (list_item) : (nil))]
        } else {
          return list_item
        }      }, -5);
      $defs(self, '$read_lines_for_list_item', function $$read_lines_for_list_item(reader, list_type, sibling_trait, has_text) {
        var $a, self = this, buffer = nil, continuation = nil, within_nested_list = nil, detached_continuation = nil, dlist = nil, this_line = nil, prev_line = nil, match = nil, block_attribute_lines = nil, next_line = nil, interrupt = nil, ch0 = nil, nested_list_type = nil, $ret_or_1 = nil, last_line = nil;

        
        if (sibling_trait == null) sibling_trait = nil;
        if (has_text == null) has_text = true;
        buffer = [];
        continuation = "inactive";
        within_nested_list = false;
        detached_continuation = nil;
        dlist = list_type['$==']("dlist");
        while ($truthy(reader['$has_more_lines?']())) {
        
          this_line = reader.$read_line();
          if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
            break
          }          prev_line = ($truthy(buffer['$empty?']()) ? (nil) : (buffer['$[]'](-1)));
          if ($eqeq(prev_line, $$('LIST_CONTINUATION'))) {
            
            if ($eqeq(continuation, "inactive")) {
              
              continuation = "active";
              has_text = true;
              if (!$truthy(within_nested_list)) {
                buffer['$[]='](-1, "");
              }            }            if ($eqeq(this_line, $$('LIST_CONTINUATION'))) {
              
              if ($neqeq(continuation, "frozen")) {
                
                continuation = "frozen";
                buffer['$<<'](this_line);
              }              this_line = nil;
              continue;
            }          }          if ($truthy((match = self['$is_delimited_block?'](this_line, true)))) {
            
            if (!$eqeq(continuation, "active")) {
              break
            }            buffer['$<<'](this_line);
            buffer.$concat(reader.$read_lines_until($hash2(["terminator", "read_last_line", "context"], {"terminator": match.$terminator(), "read_last_line": true, "context": nil})));
            continuation = "inactive";
          } else if (((($truthy(dlist) && ($neqeq(continuation, "active"))) && ($truthy(this_line['$start_with?']("[")))) && ($truthy($$('BlockAttributeLineRx')['$match?'](this_line))))) {
            
            block_attribute_lines = [this_line];
            while ($truthy((next_line = reader.$peek_line()))) {
            
              if ($truthy(self['$is_delimited_block?'](next_line))) {
                interrupt = true;
              } else if (($truthy(next_line['$empty?']()) || (($truthy(next_line['$start_with?']("[")) && ($truthy($$('BlockAttributeLineRx')['$match?'](next_line))))))) {
                
                block_attribute_lines['$<<'](reader.$read_line());
                continue;
              } else if (($truthy($$('AnyListRx')['$match?'](next_line)) && ($not(self['$is_sibling_list_item?'](next_line, list_type, sibling_trait))))) {
                buffer.$concat(block_attribute_lines);
              } else {
                interrupt = true;
              }              break;
            }            if ($truthy(interrupt)) {
              
              reader.$unshift_lines(block_attribute_lines);
              break;
            }          } else if (($eqeq(continuation, "active") && ($not(this_line['$empty?']())))) {
            if ($truthy($$('LiteralParagraphRx')['$match?'](this_line))) {
              
              reader.$unshift_line(this_line);
              if ($truthy(dlist)) {
                buffer.$concat($send(reader, 'read_lines_until', [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})], function $$12(line){var self = $$12.$$s == null ? this : $$12.$$s;

                  
                  if (line == null) line = nil;
                  return self['$is_sibling_list_item?'](line, list_type, sibling_trait);}, {$$s: self}));
              } else {
                buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})));
              }              continuation = "inactive";
            } else if (((($eqeq((ch0 = this_line.$chr()), ".") && ($truthy($$('BlockTitleRx')['$match?'](this_line)))) || (($eqeq(ch0, "[") && ($truthy($$('BlockAttributeLineRx')['$match?'](this_line)))))) || (($eqeq(ch0, ":") && ($truthy($$('AttributeEntryRx')['$match?'](this_line))))))) {
              buffer['$<<'](this_line);
            } else {
              
              if ($truthy((nested_list_type = $send(($truthy(within_nested_list) ? (["dlist"]) : ($$('NESTABLE_LIST_CONTEXTS'))), 'find', [], function $$13(ctx){
                
                if (ctx == null) ctx = nil;
                return $$('ListRxMap')['$[]'](ctx)['$match?'](this_line);})))) {
                
                within_nested_list = true;
                if (($eqeq(nested_list_type, "dlist") && ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3))['$nil_or_empty?']())))) {
                  has_text = false;
                }              }              buffer['$<<'](this_line);
              continuation = "inactive";
            }
          } else if (($truthy(prev_line) && ($truthy(prev_line['$empty?']())))) {
            
            if ($truthy(this_line['$empty?']())) {
              
              if (!$truthy((this_line = ($truthy(($ret_or_1 = reader.$skip_blank_lines())) ? (reader.$read_line()) : ($ret_or_1))))) {
                break
              }              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
                break
              }            }            if ($eqeq(this_line, $$('LIST_CONTINUATION'))) {
              
              detached_continuation = buffer.$size();
              buffer['$<<'](this_line);
            } else if ($truthy(has_text)) {
              if ($truthy(self['$is_sibling_list_item?'](this_line, list_type, sibling_trait))) {
                break
              } else if ($truthy((nested_list_type = $send($$('NESTABLE_LIST_CONTEXTS'), 'find', [], function $$14(ctx){
                
                if (ctx == null) ctx = nil;
                return $$('ListRxMap')['$[]'](ctx)['$=~'](this_line);})))) {
                
                buffer['$<<'](this_line);
                within_nested_list = true;
                if (($eqeq(nested_list_type, "dlist") && ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3))['$nil_or_empty?']())))) {
                  has_text = false;
                }              } else if ($truthy($$('LiteralParagraphRx')['$match?'](this_line))) {
                
                reader.$unshift_line(this_line);
                if ($truthy(dlist)) {
                  buffer.$concat($send(reader, 'read_lines_until', [$hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})], function $$15(line){var self = $$15.$$s == null ? this : $$15.$$s;

                    
                    if (line == null) line = nil;
                    return self['$is_sibling_list_item?'](line, list_type, sibling_trait);}, {$$s: self}));
                } else {
                  buffer.$concat(reader.$read_lines_until($hash2(["preserve_last_line", "break_on_blank_lines", "break_on_list_continuation"], {"preserve_last_line": true, "break_on_blank_lines": true, "break_on_list_continuation": true})));
                }              } else {
                break
              }
            } else {
              
              if (!$truthy(within_nested_list)) {
                buffer.$pop();
              }              buffer['$<<'](this_line);
              has_text = true;
            }          } else {
            
            if (!$truthy(this_line['$empty?']())) {
              has_text = true;
            }            if ($truthy((nested_list_type = $send(($truthy(within_nested_list) ? (["dlist"]) : ($$('NESTABLE_LIST_CONTEXTS'))), 'find', [], function $$16(ctx){
              
              if (ctx == null) ctx = nil;
              return $$('ListRxMap')['$[]'](ctx)['$=~'](this_line);})))) {
              
              within_nested_list = true;
              if (($eqeq(nested_list_type, "dlist") && ($truthy((($a = $gvars['~']) === nil ? nil : $a['$[]'](3))['$nil_or_empty?']())))) {
                has_text = false;
              }            }            buffer['$<<'](this_line);
          }          this_line = nil;
        }        if ($truthy(this_line)) {
          reader.$unshift_line(this_line);
        }        if ($truthy(detached_continuation)) {
          buffer['$[]='](detached_continuation, "");
        }        while (!($truthy(buffer['$empty?']()))) {
        if ($truthy((last_line = buffer['$[]'](-1))['$empty?']())) {
            buffer.$pop();
          } else {
            
            if ($eqeq(last_line, $$('LIST_CONTINUATION'))) {
              buffer.$pop();
            }            break;
          }
        }        return buffer;
      }, -3);
      $defs(self, '$initialize_section', function $$initialize_section(reader, parent, attributes) {
        var $a, $b, self = this, document = nil, book = nil, doctype = nil, source_location = nil, sect_style = nil, sect_id = nil, sect_reftext = nil, sect_title = nil, sect_level = nil, sect_atx = nil, sect_name = nil, sect_special = nil, sect_numbered = nil, section = nil, $ret_or_1 = nil, id = nil, generated_id = nil;

        
        if (attributes == null) attributes = $hash2([], {});
        document = parent.$document();
        book = (doctype = document.$doctype())['$==']("book");
        if ($truthy(document.$sourcemap())) {
          source_location = reader.$cursor();
        }        sect_style = attributes['$[]'](1);
        $b = self.$parse_section_title(reader, document, attributes['$[]']("id")), $a = $to_ary($b), (sect_id = ($a[0] == null ? nil : $a[0])), (sect_reftext = ($a[1] == null ? nil : $a[1])), (sect_title = ($a[2] == null ? nil : $a[2])), (sect_level = ($a[3] == null ? nil : $a[3])), (sect_atx = ($a[4] == null ? nil : $a[4]));
        if ($truthy(sect_style)) {
          if (($truthy(book) && ($eqeq(sect_style, "abstract")))) {
            $a = ["chapter", 1], (sect_name = $a[0]), (sect_level = $a[1]);
          } else if (($truthy(sect_style['$start_with?']("sect")) && ($truthy($$('SectionLevelStyleRx')['$match?'](sect_style))))) {
            sect_name = "section";
          } else {
            
            $a = [sect_style, true], (sect_name = $a[0]), (sect_special = $a[1]);
            if ($eqeq(sect_level, 0)) {
              sect_level = 1;
            }            sect_numbered = sect_name['$==']("appendix");
          }
        } else if ($truthy(book)) {
          sect_name = ($eqeq(sect_level, 0) ? ("part") : (($truthy($rb_gt(sect_level, 1)) ? ("section") : ("chapter"))));
        } else if (($eqeq(doctype, "manpage") && ($eqeq(sect_title.$casecmp("synopsis"), 0)))) {
          $a = ["synopsis", true], (sect_name = $a[0]), (sect_special = $a[1]);
        } else {
          sect_name = "section";
        }        if ($truthy(sect_reftext)) {
          attributes['$[]=']("reftext", sect_reftext);
        }        section = $$('Section').$new(parent, sect_level);
        $a = [sect_id, sect_title, sect_name, source_location], ($b = [$a[0]], $send(section, 'id=', $b), $b[$b.length - 1]), ($b = [$a[1]], $send(section, 'title=', $b), $b[$b.length - 1]), ($b = [$a[2]], $send(section, 'sectname=', $b), $b[$b.length - 1]), ($b = [$a[3]], $send(section, 'source_location=', $b), $b[$b.length - 1]);
        if ($truthy(sect_special)) {
          
          section['$special='](true);
          if ($truthy(sect_numbered)) {
            section['$numbered='](true);
          } else if ($eqeq(document.$attributes()['$[]']("sectnums"), "all")) {
            section['$numbered=']((($truthy(book) && ($eqeq(sect_level, 1))) ? ("chapter") : (true)));
          }        } else if (($truthy(document.$attributes()['$[]']("sectnums")) && ($truthy($rb_gt(sect_level, 0))))) {
          section['$numbered='](($truthy(section.$special()) ? (($truthy(($ret_or_1 = parent.$numbered())) || ($ret_or_1))) : (true)));
        } else if ((($truthy(book) && ($eqeq(sect_level, 0))) && ($truthy(document.$attributes()['$[]']("partnums"))))) {
          section['$numbered='](true);
        }        if ($truthy((id = ($truthy(($ret_or_1 = section.$id())) ? ($ret_or_1) : (($a = [($truthy(document.$attributes()['$key?']("sectids")) ? ((generated_id = $$('Section').$generate_id(section.$title(), document))) : (nil))], $send(section, 'id=', $a), $a[$a.length - 1])))))) {
          
          if (!($truthy(generated_id) || ($not(sect_title['$include?']($$('ATTR_REF_HEAD')))))) {
            section.$title();
          }          if (!$truthy(document.$register("refs", [id, section]))) {
            self.$logger().$warn(self.$message_with_context("id assigned to section already in use: " + (id), $hash2(["source_location"], {"source_location": reader.$cursor_at_line($rb_minus(reader.$lineno(), ($truthy(sect_atx) ? (1) : (2))))})));
          }        }        section.$update_attributes(attributes);
        reader.$skip_blank_lines();
        return section;
      }, -3);
      $defs(self, '$is_next_line_section?', function $Parser_is_next_line_section$ques$17(reader, attributes) {
        var self = this, style = nil, next_lines = nil, $ret_or_1 = nil;

        
        if (($truthy((style = attributes['$[]'](1))) && (($eqeq(style, "discrete") || ($eqeq(style, "float")))))) {
          return nil
        }        if ($truthy($$('Compliance').$underline_style_section_titles())) {
          
          next_lines = reader.$peek_lines(2, ($truthy(($ret_or_1 = style)) ? (style['$==']("comment")) : ($ret_or_1)));
          return self['$is_section_title?'](($truthy(($ret_or_1 = next_lines['$[]'](0))) ? ($ret_or_1) : ("")), next_lines['$[]'](1));
        } else {
          return self['$atx_section_title?'](($truthy(($ret_or_1 = reader.$peek_line())) ? ($ret_or_1) : ("")))
        }      });
      $defs(self, '$is_next_line_doctitle?', function $Parser_is_next_line_doctitle$ques$18(reader, attributes, leveloffset) {
        var self = this, $ret_or_1 = nil, sect_level = nil;

        if ($truthy(leveloffset)) {
          if ($truthy(($ret_or_1 = (sect_level = self['$is_next_line_section?'](reader, attributes))))) {
            
            return $rb_plus(sect_level, leveloffset.$to_i())['$=='](0);
          } else {
            return $ret_or_1
          }
        } else {
          return self['$is_next_line_section?'](reader, attributes)['$=='](0)
        }
      });
      $defs(self, '$is_section_title?', function $Parser_is_section_title$ques$19(line1, line2) {
        var self = this, $ret_or_1 = nil;

        
        if (line2 == null) line2 = nil;
        if ($truthy(($ret_or_1 = self['$atx_section_title?'](line1)))) {
          return $ret_or_1
        } else {
          
          if ($truthy(line2['$nil_or_empty?']())) {
            return nil
          } else {
            return self['$setext_section_title?'](line1, line2)
          }        }      }, -2);
      $defs(self, '$atx_section_title?', function $Parser_atx_section_title$ques$20(line) {
        var $a, $ret_or_1 = nil;

        if ($truthy(($truthy($$('Compliance').$markdown_syntax()) ? (($truthy(($ret_or_1 = line['$start_with?']("=", "#"))) ? ($$('ExtAtxSectionTitleRx')['$=~'](line)) : ($ret_or_1))) : (($truthy(($ret_or_1 = line['$start_with?']("="))) ? ($$('AtxSectionTitleRx')['$=~'](line)) : ($ret_or_1)))))) {
          return $rb_minus((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)).$length(), 1)
        } else {
          return nil
        }
      });
      $defs(self, '$setext_section_title?', function $Parser_setext_section_title$ques$21(line1, line2) {
        var self = this, line2_len = nil, level = nil, line2_ch0 = nil;

        if (((($truthy((level = $$('SETEXT_SECTION_LEVELS')['$[]']((line2_ch0 = line2.$chr())))) && ($truthy(self['$uniform?'](line2, line2_ch0, (line2_len = line2.$length()))))) && ($truthy($$('SetextSectionTitleRx')['$match?'](line1)))) && ($truthy($rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2))))) {
          return level
        } else {
          return nil
        }
      });
      $defs(self, '$parse_section_title', function $$parse_section_title(reader, document, sect_id) {
        var $a, $b, self = this, sect_reftext = nil, line1 = nil, $ret_or_1 = nil, sect_level = nil, sect_title = nil, atx = nil, line2_len = nil, line2_ch0 = nil, line2 = nil;

        
        if (sect_id == null) sect_id = nil;
        sect_reftext = nil;
        line1 = reader.$read_line();
        if ($truthy(($truthy($$('Compliance').$markdown_syntax()) ? (($truthy(($ret_or_1 = line1['$start_with?']("=", "#"))) ? ($$('ExtAtxSectionTitleRx')['$=~'](line1)) : ($ret_or_1))) : (($truthy(($ret_or_1 = line1['$start_with?']("="))) ? ($$('AtxSectionTitleRx')['$=~'](line1)) : ($ret_or_1)))))) {
          
          $a = [$rb_minus((($b = $gvars['~']) === nil ? nil : $b['$[]'](1)).$length(), 1), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), true], (sect_level = $a[0]), (sect_title = $a[1]), (atx = $a[2]);
          if (!$truthy(sect_id)) {
            if ((($truthy(sect_title['$end_with?']("]]")) && ($truthy($$('InlineSectionAnchorRx')['$=~'](sect_title)))) && ($not((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))))) {
              $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]);
            }
          }        } else if (((((($truthy($$('Compliance').$underline_style_section_titles()) && ($truthy((line2 = reader.$peek_line(true))))) && ($truthy((sect_level = $$('SETEXT_SECTION_LEVELS')['$[]']((line2_ch0 = line2.$chr())))))) && ($truthy(self['$uniform?'](line2, line2_ch0, (line2_len = line2.$length()))))) && ($truthy((sect_title = ($truthy(($ret_or_1 = $$('SetextSectionTitleRx')['$=~'](line1))) ? ((($a = $gvars['~']) === nil ? nil : $a['$[]'](1))) : ($ret_or_1)))))) && ($truthy($rb_lt($rb_minus(line1.$length(), line2_len).$abs(), 2))))) {
          
          atx = false;
          if (!$truthy(sect_id)) {
            if ((($truthy(sect_title['$end_with?']("]]")) && ($truthy($$('InlineSectionAnchorRx')['$=~'](sect_title)))) && ($not((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)))))) {
              $a = [sect_title.$slice(0, $rb_minus(sect_title.$length(), (($b = $gvars['~']) === nil ? nil : $b['$[]'](0)).$length())), (($b = $gvars['~']) === nil ? nil : $b['$[]'](2)), (($b = $gvars['~']) === nil ? nil : $b['$[]'](3))], (sect_title = $a[0]), (sect_id = $a[1]), (sect_reftext = $a[2]);
            }
          }          reader.$shift();
        } else {
          self.$raise("Unrecognized section at " + (reader.$cursor_at_prev_line()));
        }        if ($truthy(document['$attr?']("leveloffset"))) {
          
          sect_level = $rb_plus(sect_level, document.$attr("leveloffset").$to_i());
          if ($truthy($rb_lt(sect_level, 0))) {
            sect_level = 0;
          }        }        return [sect_id, sect_reftext, sect_title, sect_level, atx];
      }, -3);
      $defs(self, '$parse_header_metadata', function $$parse_header_metadata(reader, document, retrieve) {
        var $a, self = this, doc_attrs = nil, $ret_or_1 = nil, authorcount = nil, implicit_author_metadata = nil, implicit_author = nil, implicit_authorinitials = nil, implicit_authors = nil, rev_line = nil, match = nil, rev_metadata = nil, component = nil, author_line = nil, author_metadata = nil, authors = nil, author_idx = nil, author_key = nil, explicit = nil, sparse = nil, author_override = nil;

        
        if (document == null) document = nil;
        if (retrieve == null) retrieve = true;
        doc_attrs = ($truthy(($ret_or_1 = document)) ? (document.$attributes()) : ($ret_or_1));
        self.$process_attribute_entries(reader, document);
        if (($truthy(reader['$has_more_lines?']()) && ($not(reader['$next_line_empty?']())))) {
          
          authorcount = (implicit_author_metadata = self.$process_authors(reader.$read_line())).$delete("authorcount");
          if (($truthy(document) && ($truthy($rb_gt(($a = ["authorcount", authorcount], $send(doc_attrs, '[]=', $a), $a[$a.length - 1]), 0))))) {
            
            $send(implicit_author_metadata, 'each', [], function $$22(key, val){var $b;

              
              if (key == null) key = nil;
              if (val == null) val = nil;
              if ($truthy(doc_attrs['$key?'](key))) {
                return nil
              } else {
                return ($b = [key, document.$apply_header_subs(val)], $send(doc_attrs, '[]=', $b), $b[$b.length - 1])
              }});
            implicit_author = doc_attrs['$[]']("author");
            implicit_authorinitials = doc_attrs['$[]']("authorinitials");
            implicit_authors = doc_attrs['$[]']("authors");
          }          implicit_author_metadata['$[]=']("authorcount", authorcount);
          self.$process_attribute_entries(reader, document);
          if (($truthy(reader['$has_more_lines?']()) && ($not(reader['$next_line_empty?']())))) {
            
            rev_line = reader.$read_line();
            if ($truthy((match = $$('RevisionInfoLineRx').$match(rev_line)))) {
              
              rev_metadata = $hash2([], {});
              if ($truthy(match['$[]'](1))) {
                rev_metadata['$[]=']("revnumber", match['$[]'](1).$rstrip());
              }              if (!$truthy((component = match['$[]'](2).$strip())['$empty?']())) {
                if (($not(match['$[]'](1)) && ($truthy(component['$start_with?']("v"))))) {
                  rev_metadata['$[]=']("revnumber", component.$slice(1, component.$length()));
                } else {
                  rev_metadata['$[]=']("revdate", component);
                }
              }              if ($truthy(match['$[]'](3))) {
                rev_metadata['$[]=']("revremark", match['$[]'](3).$rstrip());
              }              if (($truthy(document) && ($not(rev_metadata['$empty?']())))) {
                $send(rev_metadata, 'each', [], function $$23(key, val){var $b;

                  
                  if (key == null) key = nil;
                  if (val == null) val = nil;
                  if ($truthy(doc_attrs['$key?'](key))) {
                    return nil
                  } else {
                    return ($b = [key, document.$apply_header_subs(val)], $send(doc_attrs, '[]=', $b), $b[$b.length - 1])
                  }});
              }            } else {
              reader.$unshift_line(rev_line);
            }          }          self.$process_attribute_entries(reader, document);
          reader.$skip_blank_lines();
        } else {
          implicit_author_metadata = $hash2([], {});
        }        if ($truthy(document)) {
          
          if (($truthy(doc_attrs['$key?']("author")) && ($neqeq((author_line = doc_attrs['$[]']("author")), implicit_author)))) {
            
            author_metadata = self.$process_authors(author_line, true, false);
            if ($neqeq(doc_attrs['$[]']("authorinitials"), implicit_authorinitials)) {
              author_metadata.$delete("authorinitials");
            }          } else if (($truthy(doc_attrs['$key?']("authors")) && ($neqeq((author_line = doc_attrs['$[]']("authors")), implicit_authors)))) {
            author_metadata = self.$process_authors(author_line, true);
          } else {
            
            $a = [[], 1, "author_1", false, false], (authors = $a[0]), (author_idx = $a[1]), (author_key = $a[2]), (explicit = $a[3]), (sparse = $a[4]);
            while ($truthy(doc_attrs['$key?'](author_key))) {
            
              if ($eqeq((author_override = doc_attrs['$[]'](author_key)), implicit_author_metadata['$[]'](author_key))) {
                
                authors['$<<'](nil);
                sparse = true;
              } else {
                
                authors['$<<'](author_override);
                explicit = true;
              }              author_key = "author_" + ((author_idx = $rb_plus(author_idx, 1)));
            }            if ($truthy(explicit)) {
              
              if ($truthy(sparse)) {
                $send(authors, 'each_with_index', [], function $$24(author, idx){var $b, name_idx = nil;

                  
                  if (author == null) author = nil;
                  if (idx == null) idx = nil;
                  if ($truthy(author)) {
                    return nil
                  }                  return ($b = [idx, $send([implicit_author_metadata['$[]']("firstname_" + ((name_idx = $rb_plus(idx, 1)))), implicit_author_metadata['$[]']("middlename_" + (name_idx)), implicit_author_metadata['$[]']("lastname_" + (name_idx))].$compact(), 'map', [], function $$25(it){
                    
                    if (it == null) it = nil;
                    return it.$tr(" ", "_");}).$join(" ")], $send(authors, '[]=', $b), $b[$b.length - 1]);});
              }              author_metadata = self.$process_authors(authors, true, false);
            } else {
              author_metadata = $hash2(["authorcount"], {"authorcount": 0});
            }          }          if ($eqeq(author_metadata['$[]']("authorcount"), 0)) {
            if ($truthy(authorcount)) {
              author_metadata = nil;
            } else {
              doc_attrs['$[]=']("authorcount", 0);
            }
          } else {
            
            doc_attrs.$update(author_metadata);
            if (($not(doc_attrs['$key?']("email")) && ($truthy(doc_attrs['$key?']("email_1"))))) {
              doc_attrs['$[]=']("email", doc_attrs['$[]']("email_1"));
            }          }        }        if ($truthy(retrieve)) {
          return implicit_author_metadata.$merge(rev_metadata.$to_h(), author_metadata.$to_h())
        } else {
          return nil
        }      }, -2);
      $defs(self, '$process_authors', function $$process_authors(author_line, names_only, multiple) {
        var author_metadata = nil, author_idx = nil;

        
        if (names_only == null) names_only = false;
        if (multiple == null) multiple = true;
        author_metadata = $hash2([], {});
        author_idx = 0;
        $send((($truthy(multiple) && ($truthy(author_line['$include?'](";")))) ? (author_line.$split($$('AuthorDelimiterRx'))) : ([].concat($to_a(author_line)))), 'each', [], function $$26(author_entry){var $a, key_map = nil, segments = nil, match = nil, author = nil, fname = nil, mname = nil, lname = nil;

          
          if (author_entry == null) author_entry = nil;
          if ($truthy(author_entry['$empty?']())) {
            return nil
          }          key_map = $hash2([], {});
          if ($eqeq((author_idx = $rb_plus(author_idx, 1)), 1)) {
            $send($$('AuthorKeys'), 'each', [], function $$27(key){var $a;

              
              if (key == null) key = nil;
              return ($a = [key.$to_sym(), key], $send(key_map, '[]=', $a), $a[$a.length - 1]);});
          } else {
            $send($$('AuthorKeys'), 'each', [], function $$28(key){var $a;

              
              if (key == null) key = nil;
              return ($a = [key.$to_sym(), "" + (key) + "_" + (author_idx)], $send(key_map, '[]=', $a), $a[$a.length - 1]);});
          }          if ($truthy(names_only)) {
            
            if ($truthy(author_entry['$include?']("<"))) {
              
              author_metadata['$[]='](key_map['$[]']("author"), author_entry.$tr("_", " "));
              author_entry = author_entry.$gsub($$('XmlSanitizeRx'), "");
            }            if ($eqeq((segments = author_entry.$split(nil, 3)).$size(), 3)) {
              segments['$<<'](segments.$pop().$squeeze(" "));
            }          } else if ($truthy((match = $$('AuthorInfoLineRx').$match(author_entry)))) {
            (segments = match.$to_a()).$shift();
          }          if ($truthy(segments)) {
            
            author = ($a = [key_map['$[]']("firstname"), (fname = segments['$[]'](0).$tr("_", " "))], $send(author_metadata, '[]=', $a), $a[$a.length - 1]);
            author_metadata['$[]='](key_map['$[]']("authorinitials"), fname.$chr());
            if ($truthy(segments['$[]'](1))) {
              if ($truthy(segments['$[]'](2))) {
                
                author_metadata['$[]='](key_map['$[]']("middlename"), (mname = segments['$[]'](1).$tr("_", " ")));
                author_metadata['$[]='](key_map['$[]']("lastname"), (lname = segments['$[]'](2).$tr("_", " ")));
                author = $rb_plus($rb_plus($rb_plus($rb_plus(fname, " "), mname), " "), lname);
                author_metadata['$[]='](key_map['$[]']("authorinitials"), "" + (fname.$chr()) + (mname.$chr()) + (lname.$chr()));
              } else {
                
                author_metadata['$[]='](key_map['$[]']("lastname"), (lname = segments['$[]'](1).$tr("_", " ")));
                author = $rb_plus($rb_plus(fname, " "), lname);
                author_metadata['$[]='](key_map['$[]']("authorinitials"), "" + (fname.$chr()) + (lname.$chr()));
              }
            }            if ($truthy((author_metadata['$[]'](key_map['$[]']("author"))))) ; else {
              author_metadata['$[]='](key_map['$[]']("author"), author);
            }            if (!($truthy(names_only) || ($not(segments['$[]'](3))))) {
              author_metadata['$[]='](key_map['$[]']("email"), segments['$[]'](3));
            }          } else {
            
            author_metadata['$[]='](key_map['$[]']("author"), ($a = [key_map['$[]']("firstname"), (fname = author_entry.$squeeze(" ").$strip())], $send(author_metadata, '[]=', $a), $a[$a.length - 1]));
            author_metadata['$[]='](key_map['$[]']("authorinitials"), fname.$chr());
          }          if ($eqeq(author_idx, 1)) {
            return ($a = ["authors", author_metadata['$[]'](key_map['$[]']("author"))], $send(author_metadata, '[]=', $a), $a[$a.length - 1])
          } else {
            
            if ($eqeq(author_idx, 2)) {
              $send($$('AuthorKeys'), 'each', [], function $$29(key){var $b;

                
                if (key == null) key = nil;
                if ($truthy(author_metadata['$key?'](key))) {
                  return ($b = ["" + (key) + "_1", author_metadata['$[]'](key)], $send(author_metadata, '[]=', $b), $b[$b.length - 1])
                } else {
                  return nil
                }});
            }            return ($a = ["authors", "" + (author_metadata['$[]']("authors")) + ", " + (author_metadata['$[]'](key_map['$[]']("author")))], $send(author_metadata, '[]=', $a), $a[$a.length - 1]);
          }});
        author_metadata['$[]=']("authorcount", author_idx);
        return author_metadata;
      }, -2);
      $defs(self, '$parse_block_metadata_lines', function $$parse_block_metadata_lines(reader, document, attributes, options) {
        var self = this;

        
        if (attributes == null) attributes = $hash2([], {});
        if (options == null) options = $hash2([], {});
        while ($truthy(self.$parse_block_metadata_line(reader, document, attributes, options))) {
        
          reader.$shift();
          if ($truthy((reader.$skip_blank_lines()))) ; else {
            break
          }        }        return attributes;
      }, -3);
      $defs(self, '$parse_block_metadata_line', function $$parse_block_metadata_line(reader, document, attributes, options) {
        var $a, self = this, normal = nil, next_line = nil, reftext = nil, current_style = nil, $ret_or_1 = nil, ll = nil;
        if ($gvars["~"] == null) $gvars["~"] = nil;

        
        if (options == null) options = $hash2([], {});
        if (($truthy((next_line = reader.$peek_line())) && ($truthy(($truthy(options['$[]']("text_only")) ? (next_line['$start_with?']("[", "/")) : ((normal = next_line['$start_with?']("[", ".", "/", ":")))))))) {
          if ($truthy(next_line['$start_with?']("["))) {
            if ($truthy(next_line['$start_with?']("[["))) {
              if (($truthy(next_line['$end_with?']("]]")) && ($truthy($$('BlockAnchorRx')['$=~'](next_line))))) {
                
                attributes['$[]=']("id", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)));
                if ($truthy((reftext = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2))))) {
                  attributes['$[]=']("reftext", ($truthy(reftext['$include?']($$('ATTR_REF_HEAD'))) ? (document.$sub_attributes(reftext)) : (reftext)));
                }                return true;
              }
            } else if (($truthy(next_line['$end_with?']("]")) && ($truthy($$('BlockAttributeListRx')['$=~'](next_line))))) {
              
              current_style = attributes['$[]'](1);
              if ($truthy(document.$parse_attributes((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), [], $hash2(["sub_input", "sub_result", "into"], {"sub_input": true, "sub_result": true, "into": attributes}))['$[]'](1))) {
                attributes['$[]='](1, ($truthy(($ret_or_1 = self.$parse_style_attribute(attributes, reader))) ? ($ret_or_1) : (current_style)));
              }              return true;
            }
          } else if (($truthy(normal) && ($truthy(next_line['$start_with?']("."))))) {
            if ($truthy($$('BlockTitleRx')['$=~'](next_line))) {
              
              attributes['$[]=']("title", (($a = $gvars['~']) === nil ? nil : $a['$[]'](1)));
              return true;
            }
          } else if (($not(normal) || ($truthy(next_line['$start_with?']("/"))))) {
            if ($truthy(next_line['$start_with?']("//"))) {
              if ($eqeq(next_line, "//")) {
                return true
              } else if (($truthy(normal) && ($truthy(self['$uniform?'](next_line, "/", (ll = next_line.$length())))))) {
                if (!$eqeq(ll, 3)) {
                  
                  reader.$read_lines_until($hash2(["terminator", "skip_first_line", "preserve_last_line", "skip_processing", "context"], {"terminator": next_line, "skip_first_line": true, "preserve_last_line": true, "skip_processing": true, "context": "comment"}));
                  return true;
                }
              } else if (!$truthy(next_line['$start_with?']("///"))) {
                return true
              }
            }
          } else if ((($truthy(normal) && ($truthy(next_line['$start_with?'](":")))) && ($truthy($$('AttributeEntryRx')['$=~'](next_line))))) {
            
            self.$process_attribute_entry(reader, document, attributes, $gvars["~"]);
            return true;
          }
        }        return nil;
      }, -4);
      $defs(self, '$process_attribute_entries', function $$process_attribute_entries(reader, document, attributes) {
        var self = this;

        
        if (attributes == null) attributes = nil;
        reader.$skip_comment_lines();
        while ($truthy(self.$process_attribute_entry(reader, document, attributes))) {
        
          reader.$shift();
          reader.$skip_comment_lines();
        }      }, -3);
      $defs(self, '$process_attribute_entry', function $$process_attribute_entry(reader, document, attributes, match) {
        var $a, self = this, value = nil, con = nil, $ret_or_1 = nil, next_line = nil, $ret_or_2 = nil, keep_open = nil;

        
        if (attributes == null) attributes = nil;
        if (match == null) match = nil;
        if (($truthy(match) || ($truthy((match = ($truthy(reader['$has_more_lines?']()) ? ($$('AttributeEntryRx').$match(reader.$peek_line())) : (nil))))))) {
          
          if ($truthy((value = match['$[]'](2))['$nil_or_empty?']())) {
            value = "";
          } else if ($truthy(value['$end_with?']($$('LINE_CONTINUATION'), $$('LINE_CONTINUATION_LEGACY')))) {
            
            $a = [value.$slice($rb_minus(value.$length(), 2), 2), value.$slice(0, $rb_minus(value.$length(), 2)).$rstrip()], (con = $a[0]), (value = $a[1]);
            while ($truthy(($truthy(($ret_or_1 = reader.$advance())) ? ((next_line = ($truthy(($ret_or_2 = reader.$peek_line())) ? ($ret_or_2) : ("")))['$empty?']()['$!']()) : ($ret_or_1)))) {
            
              next_line = next_line.$lstrip();
              if ($truthy((keep_open = next_line['$end_with?'](con)))) {
                next_line = next_line.$slice(0, $rb_minus(next_line.$length(), 2)).$rstrip();
              }              value = "" + (value) + (($truthy(value['$end_with?']($$('HARD_LINE_BREAK'))) ? ($$('LF')) : (" "))) + (next_line);
              if (!$truthy(keep_open)) {
                break
              }            }          }          self.$store_attribute(match['$[]'](1), value, document, attributes);
          return true;
        } else {
          return nil
        }      }, -3);
      $defs(self, '$store_attribute', function $$store_attribute(name, value, doc, attrs) {
        var self = this, resolved_value = nil;

        
        if (doc == null) doc = nil;
        if (attrs == null) attrs = nil;
        if ($truthy(name['$end_with?']("!"))) {
          
          name = name.$chop();
          value = nil;
        } else if ($truthy(name['$start_with?']("!"))) {
          
          name = name.$slice(1, name.$length());
          value = nil;
        }        if ($eqeq((name = self.$sanitize_attribute_name(name)), "numbered")) {
          name = "sectnums";
        } else if ($eqeq(name, "hardbreaks")) {
          name = "hardbreaks-option";
        } else if ($eqeq(name, "showtitle")) {
          self.$store_attribute("notitle", ($truthy(value) ? (nil) : ("")), doc, attrs);
        }        if ($truthy(doc)) {
          if ($truthy(value)) {
            
            if ($eqeq(name, "leveloffset")) {
              if ($truthy(value['$start_with?']("+"))) {
                value = $rb_plus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s();
              } else if ($truthy(value['$start_with?']("-"))) {
                value = $rb_minus(doc.$attr("leveloffset", 0).$to_i(), value.$slice(1, value.$length()).$to_i()).$to_s();
              }
            }            if ($truthy((resolved_value = doc.$set_attribute(name, value)))) {
              
              value = resolved_value;
              if ($truthy(attrs)) {
                $$$($$('Document'), 'AttributeEntry').$new(name, value).$save_to(attrs);
              }            }          } else if (($truthy(doc.$delete_attribute(name)) && ($truthy(attrs)))) {
            $$$($$('Document'), 'AttributeEntry').$new(name, value).$save_to(attrs);
          }
        } else if ($truthy(attrs)) {
          $$$($$('Document'), 'AttributeEntry').$new(name, value).$save_to(attrs);
        }        return [name, value];
      }, -3);
      $defs(self, '$resolve_list_marker', function $$resolve_list_marker(list_type, marker, ordinal, validate, reader) {
        var self = this;

        
        if (ordinal == null) ordinal = 0;
        if (validate == null) validate = false;
        if (reader == null) reader = nil;
        
        switch (list_type) {
          case "ulist":
            return marker
          case "olist":
            return self.$resolve_ordered_list_marker(marker, ordinal, validate, reader)['$[]'](0)
          default:
            return "<1>"
        }      }, -3);
      $defs(self, '$resolve_ordered_list_marker', function $$resolve_ordered_list_marker(marker, ordinal, validate, reader) {
        var self = this, style = nil, expected = nil, actual = nil;

        
        if (ordinal == null) ordinal = 0;
        if (validate == null) validate = false;
        if (reader == null) reader = nil;
        if ($truthy(marker['$start_with?']("."))) {
          return [marker]
        }        
        switch ((style = $send($$('ORDERED_LIST_STYLES'), 'find', [], function $$30(s){
          
          if (s == null) s = nil;
          return $$('OrderedListMarkerRxMap')['$[]'](s)['$match?'](marker);}))) {
          case "arabic":
            
            if ($truthy(validate)) {
              
              expected = $rb_plus(ordinal, 1);
              actual = marker.$to_i();
            }            marker = "1.";
            break;
          case "loweralpha":
            
            if ($truthy(validate)) {
              
              expected = $rb_plus("a"['$[]'](0).$ord(), ordinal).$chr();
              actual = marker.$chop();
            }            marker = "a.";
            break;
          case "upperalpha":
            
            if ($truthy(validate)) {
              
              expected = $rb_plus("A"['$[]'](0).$ord(), ordinal).$chr();
              actual = marker.$chop();
            }            marker = "A.";
            break;
          case "lowerroman":
            
            if ($truthy(validate)) {
              
              expected = $$('Helpers').$int_to_roman($rb_plus(ordinal, 1)).$downcase();
              actual = marker.$chop();
            }            marker = "i)";
            break;
          case "upperroman":
            
            if ($truthy(validate)) {
              
              expected = $$('Helpers').$int_to_roman($rb_plus(ordinal, 1));
              actual = marker.$chop();
            }            marker = "I)";
            break;
        }        if (($truthy(validate) && ($neqeq(expected, actual)))) {
          self.$logger().$warn(self.$message_with_context("list item index: expected " + (expected) + ", got " + (actual), $hash2(["source_location"], {"source_location": reader.$cursor()})));
        }        return [marker, style];
      }, -2);
      $defs(self, '$is_sibling_list_item?', function $Parser_is_sibling_list_item$ques$31(line, list_type, sibling_trait) {
        var $a, self = this, $ret_or_1 = nil;

        if ($eqeqeq($$$('Regexp'), sibling_trait)) {
          return sibling_trait['$match?'](line)
        } else if ($truthy(($ret_or_1 = $$('ListRxMap')['$[]'](list_type)['$=~'](line)))) {
          return sibling_trait['$=='](self.$resolve_list_marker(list_type, (($a = $gvars['~']) === nil ? nil : $a['$[]'](1))))
        } else {
          return $ret_or_1
        }
      });
      $defs(self, '$parse_table', function $$parse_table(table_reader, parent, attributes) {
        var $a, $b, $c, self = this, table = nil, colspecs = nil, explicit_colspecs = nil, skipped = nil, $ret_or_1 = nil, implicit_header = nil, parser_ctx = nil, format = nil, loop_idx = nil, implicit_header_boundary = nil, line = nil, beyond_first = nil, next_cellspec = nil, m = nil, pre_match = nil, post_match = nil, cell_text = nil, $logical_op_recvr_tmp_2 = nil;

        
        table = $$('Table').$new(parent, attributes);
        if (($truthy(attributes['$key?']("cols")) && ($not((colspecs = self.$parse_colspecs(attributes['$[]']("cols")))['$empty?']())))) {
          
          table.$create_columns(colspecs);
          explicit_colspecs = true;
        }        skipped = ($truthy(($ret_or_1 = table_reader.$skip_blank_lines())) ? ($ret_or_1) : (0));
        if ($truthy(attributes['$[]']("header-option"))) {
          table['$has_header_option='](true);
        } else if (($eqeq(skipped, 0) && ($not(attributes['$[]']("noheader-option"))))) {
          
          table['$has_header_option=']("implicit");
          implicit_header = true;
        }        parser_ctx = $$$($$('Table'), 'ParserContext').$new(table_reader, table, attributes);
        $a = [parser_ctx.$format(), -1, nil], (format = $a[0]), (loop_idx = $a[1]), (implicit_header_boundary = $a[2]);
        while ($truthy((line = table_reader.$read_line()))) {
        
          if (($truthy((beyond_first = $rb_gt((loop_idx = $rb_plus(loop_idx, 1)), 0))) && ($truthy(line['$empty?']())))) {
            
            line = nil;
            if ($truthy(implicit_header_boundary)) {
              implicit_header_boundary = $rb_plus(implicit_header_boundary, 1);
            }          } else if ($eqeq(format, "psv")) {
            if ($truthy(parser_ctx['$starts_with_delimiter?'](line))) {
              
              line = line.$slice(1, line.$length());
              parser_ctx.$close_open_cell();
              if ($truthy(implicit_header_boundary)) {
                implicit_header_boundary = nil;
              }            } else {
              
              $b = self.$parse_cellspec(line, "start", parser_ctx.$delimiter()), $a = $to_ary($b), (next_cellspec = ($a[0] == null ? nil : $a[0])), (line = ($a[1] == null ? nil : $a[1]));
              if ($truthy(next_cellspec)) {
                
                parser_ctx.$close_open_cell(next_cellspec);
                if ($truthy(implicit_header_boundary)) {
                  implicit_header_boundary = nil;
                }              } else if (($truthy(implicit_header_boundary) && ($eqeq(implicit_header_boundary, loop_idx)))) {
                table['$has_header_option=']((implicit_header = (implicit_header_boundary = nil)));
              }            }
          }          if (!$truthy(beyond_first)) {
            
            table_reader.$mark();
            if ($truthy(implicit_header)) {
              if (($truthy(table_reader['$has_more_lines?']()) && ($truthy(table_reader.$peek_line()['$empty?']())))) {
                implicit_header_boundary = 1;
              } else {
                table['$has_header_option=']((implicit_header = nil));
              }
            }          }          $a = false;while ($a || $truthy(true)) {$a = false;
          if (($truthy(line) && ($truthy((m = parser_ctx.$match_delimiter(line)))))) {
              
              $b = [m.$pre_match(), m.$post_match()], (pre_match = $b[0]), (post_match = $b[1]);
              if ($eqeqeq("csv", ($ret_or_1 = format))) {
                
                if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?'](pre_match))) {
                  
                  parser_ctx.$skip_past_delimiter(pre_match);
                  if ($truthy((line = post_match)['$empty?']())) {
                    break
                  }                  $a = true;continue;
                }                parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + (pre_match));
              } else if ($eqeqeq("dsv", $ret_or_1)) {
                
                if ($truthy(pre_match['$end_with?']("\\"))) {
                  
                  parser_ctx.$skip_past_escaped_delimiter(pre_match);
                  if ($truthy((line = post_match)['$empty?']())) {
                    
                    parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + ($$('LF')));
                    parser_ctx.$keep_cell_open();
                    break;
                  }                  $a = true;continue;
                }                parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + (pre_match));
              } else {
                
                if ($truthy(pre_match['$end_with?']("\\"))) {
                  
                  parser_ctx.$skip_past_escaped_delimiter(pre_match);
                  if ($truthy((line = post_match)['$empty?']())) {
                    
                    parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + ($$('LF')));
                    parser_ctx.$keep_cell_open();
                    break;
                  }                  $a = true;continue;
                }                $c = self.$parse_cellspec(pre_match), $b = $to_ary($c), (next_cellspec = ($b[0] == null ? nil : $b[0])), (cell_text = ($b[1] == null ? nil : $b[1]));
                parser_ctx.$push_cellspec(next_cellspec);
                parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + (cell_text));
              }              if ($truthy((line = post_match)['$empty?']())) {
                line = nil;
              }              parser_ctx.$close_cell();
            } else {
              
              parser_ctx['$buffer=']("" + (parser_ctx.$buffer()) + (line) + ($$('LF')));
              
              switch (format) {
                case "csv":
                  if ($truthy(parser_ctx['$buffer_has_unclosed_quotes?']())) {
                    
                    if (($truthy(implicit_header_boundary) && ($eqeq(loop_idx, 0)))) {
                      table['$has_header_option=']((implicit_header = (implicit_header_boundary = nil)));
                    }                    parser_ctx.$keep_cell_open();
                  } else {
                    parser_ctx.$close_cell(true);
                  }
                  break;
                case "dsv":
                  parser_ctx.$close_cell(true);
                  break;
                default:
                  parser_ctx.$keep_cell_open();
              }              break;
            }
          }          if ($truthy(parser_ctx['$cell_open?']())) {
            if (!$truthy(table_reader['$has_more_lines?']())) {
              parser_ctx.$close_cell(true);
            }
          } else if ($truthy(($ret_or_1 = table_reader.$skip_blank_lines()))) ; else {
            break
          }        }        if (!($eqeq((($logical_op_recvr_tmp_2 = table.$attributes()), ($truthy(($ret_or_1 = $logical_op_recvr_tmp_2['$[]']("colcount"))) ? ($ret_or_1) : (($a = ["colcount", table.$columns().$size()], $send($logical_op_recvr_tmp_2, '[]=', $a), $a[$a.length - 1])))), 0) || ($truthy(explicit_colspecs)))) {
          table.$assign_column_widths();
        }        if ($truthy(implicit_header)) {
          table['$has_header_option='](true);
        }        table.$partition_header_footer(attributes);
        return table;
      });
      $defs(self, '$parse_colspecs', function $$parse_colspecs(records) {
        var specs = nil;

        
        if ($truthy(records['$include?'](" "))) {
          records = records.$delete(" ");
        }        if ($eqeq(records, records.$to_i().$to_s())) {
          return $send($$$('Array'), 'new', [records.$to_i()], function $$32(){
            return $hash2(["width"], {"width": 1})})
        }        specs = [];
        $send(($truthy(records['$include?'](",")) ? (records.$split(",", -1)) : (records.$split(";", -1))), 'each', [], function $$33(record){var $a, $b, m = nil, spec = nil, colspec = nil, rowspec = nil, width = nil;

          
          if (record == null) record = nil;
          if ($truthy(record['$empty?']())) {
            return specs['$<<']($hash2(["width"], {"width": 1}))
          } else if ($truthy((m = $$('ColumnSpecRx').$match(record)))) {
            
            spec = $hash2([], {});
            if ($truthy(m['$[]'](2))) {
              
              $b = m['$[]'](2).$split("."), $a = $to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1]));
              if (($not(colspec['$nil_or_empty?']()) && ($truthy($$('TableCellHorzAlignments')['$key?'](colspec))))) {
                spec['$[]=']("halign", $$('TableCellHorzAlignments')['$[]'](colspec));
              }              if (($not(rowspec['$nil_or_empty?']()) && ($truthy($$('TableCellVertAlignments')['$key?'](rowspec))))) {
                spec['$[]=']("valign", $$('TableCellVertAlignments')['$[]'](rowspec));
              }            }            if ($truthy((width = m['$[]'](3)))) {
              spec['$[]=']("width", ($eqeq(width, "~") ? (-1) : (width.$to_i())));
            } else {
              spec['$[]=']("width", 1);
            }            if (($truthy(m['$[]'](4)) && ($truthy($$('TableCellStyles')['$key?'](m['$[]'](4)))))) {
              spec['$[]=']("style", $$('TableCellStyles')['$[]'](m['$[]'](4)));
            }            if ($truthy(m['$[]'](1))) {
              return $send((1), 'upto', [m['$[]'](1).$to_i()], function $$34(){
                return specs['$<<'](spec.$merge())})
            } else {
              return specs['$<<'](spec)
            }          } else {
            return nil
          }});
        return specs;
      });
      $defs(self, '$parse_cellspec', function $$parse_cellspec(line, pos, delimiter) {
        var $a, $b, m = nil, rest = nil, spec_part = nil, spec = nil, colspec = nil, rowspec = nil;

        
        if (pos == null) pos = "end";
        if (delimiter == null) delimiter = nil;
        $a = [nil, ""], (m = $a[0]), (rest = $a[1]);
        if ($eqeq(pos, "start")) {
          if ($truthy(line['$include?'](delimiter))) {
            
            $b = line.$partition(delimiter), $a = $to_ary($b), (spec_part = ($a[0] == null ? nil : $a[0])), (($a[1] == null ? nil : $a[1])), (rest = ($a[2] == null ? nil : $a[2]));
            if ($truthy((m = $$('CellSpecStartRx').$match(spec_part)))) {
              if ($truthy(m['$[]'](0)['$empty?']())) {
                return [$hash2([], {}), rest]
              }
            } else {
              return [nil, line]
            }          } else {
            return [nil, line]
          }
        } else if ($truthy((m = $$('CellSpecEndRx').$match(line)))) {
          
          if ($truthy(m['$[]'](0).$lstrip()['$empty?']())) {
            return [$hash2([], {}), line.$rstrip()]
          }          rest = m.$pre_match();
        } else {
          return [$hash2([], {}), line]
        }        spec = $hash2([], {});
        if ($truthy(m['$[]'](1))) {
          
          $b = m['$[]'](1).$split("."), $a = $to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1]));
          colspec = ($truthy(colspec['$nil_or_empty?']()) ? (1) : (colspec.$to_i()));
          rowspec = ($truthy(rowspec['$nil_or_empty?']()) ? (1) : (rowspec.$to_i()));
          
          switch (m['$[]'](2)) {
            case "+":
              
              if (!$eqeq(colspec, 1)) {
                spec['$[]=']("colspan", colspec);
              }              if (!$eqeq(rowspec, 1)) {
                spec['$[]=']("rowspan", rowspec);
              }              break;
            case "*":
              if (!$eqeq(colspec, 1)) {
                spec['$[]=']("repeatcol", colspec);
              }
              break;
          }        }        if ($truthy(m['$[]'](3))) {
          
          $b = m['$[]'](3).$split("."), $a = $to_ary($b), (colspec = ($a[0] == null ? nil : $a[0])), (rowspec = ($a[1] == null ? nil : $a[1]));
          if (($not(colspec['$nil_or_empty?']()) && ($truthy($$('TableCellHorzAlignments')['$key?'](colspec))))) {
            spec['$[]=']("halign", $$('TableCellHorzAlignments')['$[]'](colspec));
          }          if (($not(rowspec['$nil_or_empty?']()) && ($truthy($$('TableCellVertAlignments')['$key?'](rowspec))))) {
            spec['$[]=']("valign", $$('TableCellVertAlignments')['$[]'](rowspec));
          }        }        if (($truthy(m['$[]'](4)) && ($truthy($$('TableCellStyles')['$key?'](m['$[]'](4)))))) {
          spec['$[]=']("style", $$('TableCellStyles')['$[]'](m['$[]'](4)));
        }        return [spec, rest];
      }, -2);
      $defs(self, '$parse_style_attribute', function $$parse_style_attribute(attributes, reader) {
        var $a, self = this, raw_style = nil, name = nil, accum = nil, parsed_attrs = nil, parsed_style = nil, existing_role = nil;

        
        if (reader == null) reader = nil;
        if ((($truthy((raw_style = attributes['$[]'](1))) && ($not(raw_style['$include?'](" ")))) && ($truthy($$('Compliance').$shorthand_property_syntax())))) {
          
          name = nil;
          accum = "";
          parsed_attrs = $hash2([], {});
          $send(raw_style, 'each_char', [], function $$35(c){var self = $$35.$$s == null ? this : $$35.$$s;

            
            if (c == null) c = nil;
            
            switch (c) {
              case ".":
                
                self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                accum = "";
                return (name = "role");
              case "#":
                
                self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                accum = "";
                return (name = "id");
              case "%":
                
                self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
                accum = "";
                return (name = "option");
              default:
                return (accum = $rb_plus(accum, c))
            }}, {$$s: self});
          if ($truthy(name)) {
            
            self.$yield_buffered_attribute(parsed_attrs, name, accum, reader);
            if ($truthy((parsed_style = parsed_attrs['$[]']("style")))) {
              attributes['$[]=']("style", parsed_style);
            }            if ($truthy(parsed_attrs['$key?']("id"))) {
              attributes['$[]=']("id", parsed_attrs['$[]']("id"));
            }            if ($truthy(parsed_attrs['$key?']("role"))) {
              attributes['$[]=']("role", ($truthy((existing_role = attributes['$[]']("role"))['$nil_or_empty?']()) ? (parsed_attrs['$[]']("role").$join(" ")) : ("" + (existing_role) + " " + (parsed_attrs['$[]']("role").$join(" ")))));
            }            if ($truthy(parsed_attrs['$key?']("option"))) {
              $send(parsed_attrs['$[]']("option"), 'each', [], function $$36(opt){var $a;

                
                if (opt == null) opt = nil;
                return ($a = ["" + (opt) + "-option", ""], $send(attributes, '[]=', $a), $a[$a.length - 1]);});
            }            return parsed_style;
          } else {
            return ($a = ["style", raw_style], $send(attributes, '[]=', $a), $a[$a.length - 1])
          }        } else {
          return ($a = ["style", raw_style], $send(attributes, '[]=', $a), $a[$a.length - 1])
        }      }, -2);
      $defs(self, '$yield_buffered_attribute', function $$yield_buffered_attribute(attrs, name, value, reader) {
        var $a, self = this, $ret_or_1 = nil;

        
        if ($truthy(name)) {
          if ($truthy(value['$empty?']())) {
            if ($truthy(reader)) {
              self.$logger().$warn(self.$message_with_context("invalid empty " + (name) + " detected in style attribute", $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})));
            } else {
              self.$logger().$warn("invalid empty " + (name) + " detected in style attribute");
            }
          } else if ($eqeq(name, "id")) {
            
            if ($truthy(attrs['$key?']("id"))) {
              if ($truthy(reader)) {
                self.$logger().$warn(self.$message_with_context("multiple ids detected in style attribute", $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})));
              } else {
                self.$logger().$warn("multiple ids detected in style attribute");
              }
            }            attrs['$[]='](name, value);
          } else {
            ($truthy(($ret_or_1 = attrs['$[]'](name))) ? ($ret_or_1) : (($a = [name, []], $send(attrs, '[]=', $a), $a[$a.length - 1])))['$<<'](value);
          }
        } else if (!$truthy(value['$empty?']())) {
          attrs['$[]=']("style", value);
        }        return nil;
      });
      $defs(self, '$adjust_indentation!', function $Parser_adjust_indentation$excl$37(lines, indent_size, tab_size) {
        var full_tab_space = nil, block_indent = nil, new_block_indent = nil;

        
        if (indent_size == null) indent_size = 0;
        if (tab_size == null) tab_size = 0;
        if ($truthy(lines['$empty?']())) {
          return nil
        }        if (($truthy($rb_gt(tab_size, 0)) && ($truthy($send(lines, 'any?', [], function $$38(line){
          
          if (line == null) line = nil;
          return line['$include?']($$('TAB'));}))))) {
          
          full_tab_space = $rb_times(" ", tab_size);
          $send(lines, 'map!', [], function $$39(line){var tab_idx = nil, leading_tabs = nil, spaces_added = nil, idx = nil, result = nil;

            
            if (line == null) line = nil;
            if (($truthy(line['$empty?']()) || ($truthy((tab_idx = line.$index($$('TAB')))['$nil?']())))) {
              return line
            } else {
              
              if ($eqeq(tab_idx, 0)) {
                
                leading_tabs = 0;
                (function(){try { var $t_break = $thrower('break'); return $send(line, 'each_byte', [], function $$40(b){
                  
                  if (b == null) b = nil;
                  if (!$eqeq(b, 9)) {
                    $t_break.$throw();
                  };
                  return (leading_tabs = $rb_plus(leading_tabs, 1));})} catch($e) {
                  if ($e === $t_break) return $e.$v;
                  throw $e;
                }})();
                line = "" + ($rb_times(full_tab_space, leading_tabs)) + (line.$slice(leading_tabs, line.$length()));
                if (!$truthy(line['$include?']($$('TAB')))) {
                  return line
                }              }              spaces_added = 0;
              idx = 0;
              result = "";
              $send(line, 'each_char', [], function $$41(c){var offset = nil, spaces = nil;

                
                if (c == null) c = nil;
                if ($eqeq(c, $$('TAB'))) {
                  if ($eqeq((offset = $rb_plus(idx, spaces_added))['$%'](tab_size), 0)) {
                    
                    spaces_added = $rb_plus(spaces_added, $rb_minus(tab_size, 1));
                    result = $rb_plus(result, full_tab_space);
                  } else {
                    
                    if (!$eqeq((spaces = $rb_minus(tab_size, offset['$%'](tab_size))), 1)) {
                      spaces_added = $rb_plus(spaces_added, $rb_minus(spaces, 1));
                    }                    result = $rb_plus(result, $rb_times(" ", spaces));
                  }
                } else {
                  result = $rb_plus(result, c);
                }                return (idx = $rb_plus(idx, 1));});
              return result;
            }});
        }        if ($truthy($rb_lt(indent_size, 0))) {
          return nil
        }        block_indent = nil;
        (function(){try { var $t_break = $thrower('break'); return $send(lines, 'each', [], function $$42(line){var line_indent = nil;

          
          if (line == null) line = nil;
          if ($truthy(line['$empty?']())) {
            return nil
          };
          if ($eqeq((line_indent = $rb_minus(line.$length(), line.$lstrip().$length())), 0)) {
            
            block_indent = nil;
            $t_break.$throw();
          };
          if (($truthy(block_indent) && ($truthy($rb_lt(block_indent, line_indent))))) {
            return nil
          } else {
            return (block_indent = line_indent)
          };})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
        if ($eqeq(indent_size, 0)) {
          if ($truthy(block_indent)) {
            $send(lines, 'map!', [], function $$43(line){
              
              if (line == null) line = nil;
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                
                return line.$slice(block_indent, line.$length());
              }});
          }
        } else {
          
          new_block_indent = $rb_times(" ", indent_size);
          if ($truthy(block_indent)) {
            $send(lines, 'map!', [], function $$44(line){
              
              if (line == null) line = nil;
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                return $rb_plus(new_block_indent, line.$slice(block_indent, line.$length()))
              }});
          } else {
            $send(lines, 'map!', [], function $$45(line){
              
              if (line == null) line = nil;
              if ($truthy(line['$empty?']())) {
                return line
              } else {
                return $rb_plus(new_block_indent, line)
              }});
          }        }        return nil;
      }, -2);
      $defs(self, '$uniform?', function $Parser_uniform$ques$46(str, chr, len) {
        
        return str.$count(chr)['$=='](len)
      });
      return $defs(self, '$sanitize_attribute_name', function $$sanitize_attribute_name(name) {
        
        return name.$gsub($$('InvalidAttributeNameCharsRx'), "").$downcase()
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/path_resolver"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $truthy = Opal.truthy, $hash2 = Opal.hash2, $def = Opal.def, $eqeq = Opal.eqeq, $alias = Opal.alias, $rb_plus = Opal.rb_plus, $to_ary = Opal.to_ary, $send = Opal.send, $not = Opal.not, $neqeq = Opal.neqeq, $rb_gt = Opal.rb_gt, $gvars = Opal.gvars, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_accessor,root?,posixify,expand_path,pwd,start_with?,==,match?,absolute_path?,+,length,descends_from?,slice,to_s,relative_path_from,new,include?,tr,partition_path,each,pop,<<,join_path,[],web_root?,unc?,index,split,delete,[]=,join,raise,!,fetch,warn,logger,empty?,nil_or_empty?,chomp,!=,>,size,extract_uri_prefix,end_with?,gsub,private,=~');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'PathResolver');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.file_separator = $proto._partition_path_web = $proto._partition_path_sys = $proto.working_dir = nil;
      
      self.$include($$('Logging'));
      $const_set($nesting[0], 'DOT', ".");
      $const_set($nesting[0], 'DOT_DOT', "..");
      $const_set($nesting[0], 'DOT_SLASH', "./");
      $const_set($nesting[0], 'SLASH', "/");
      $const_set($nesting[0], 'BACKSLASH', "\\");
      $const_set($nesting[0], 'DOUBLE_SLASH', "//");
      $const_set($nesting[0], 'URI_CLASSLOADER', "uri:classloader:");
      $const_set($nesting[0], 'WindowsRootRx', /^(?:[a-zA-Z]:)?[\\\/]/);
      self.$attr_accessor("file_separator");
      self.$attr_accessor("working_dir");
      
      $def(self, '$initialize', function $$initialize(file_separator, working_dir) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        
        if (file_separator == null) file_separator = nil;
        if (working_dir == null) working_dir = nil;
        self.file_separator = ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = file_separator)) ? ($ret_or_2) : ($$$($$$('File'), 'ALT_SEPARATOR'))))) ? ($ret_or_1) : ($$$($$$('File'), 'SEPARATOR')));
        self.working_dir = ($truthy(working_dir) ? (($truthy(self['$root?'](working_dir)) ? (self.$posixify(working_dir)) : ($$$('File').$expand_path(working_dir)))) : ($$$('Dir').$pwd()));
        self._partition_path_sys = $hash2([], {});
        return (self._partition_path_web = $hash2([], {}));
      }, -1);
      
      $def(self, '$absolute_path?', function $PathResolver_absolute_path$ques$1(path) {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = path['$start_with?']($$('SLASH'))))) {
          return $ret_or_1
        } else {
          
          if ($truthy(($ret_or_2 = self.file_separator['$==']($$('BACKSLASH'))))) {
            
            return $$('WindowsRootRx')['$match?'](path);
          } else {
            return $ret_or_2
          }        }
      });
      if (($eqeq($$('RUBY_ENGINE'), "opal") && ($eqeq($$$('JAVASCRIPT_IO_MODULE'), "xmlhttprequest")))) {
        
        $def(self, '$root?', function $PathResolver_root$ques$2(path) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$absolute_path?'](path)))) {
            return $ret_or_1
          } else {
            
            return path['$start_with?']("file://", "http://", "https://");
          }
        });
      } else if ($eqeq($$$('RUBY_ENGINE'), "jruby")) {
        
        $def(self, '$root?', function $PathResolver_root$ques$3(path) {
          var self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self['$absolute_path?'](path)))) {
            return $ret_or_1
          } else {
            
            return path['$start_with?']($$('URI_CLASSLOADER'));
          }
        });
      } else {
        $alias(self, "root?", "absolute_path?");
      }      
      $def(self, '$unc?', function $PathResolver_unc$ques$4(path) {
        
        return path['$start_with?']($$('DOUBLE_SLASH'))
      });
      
      $def(self, '$web_root?', function $PathResolver_web_root$ques$5(path) {
        
        return path['$start_with?']($$('SLASH'))
      });
      
      $def(self, '$descends_from?', function $PathResolver_descends_from$ques$6(path, base) {
        var $ret_or_1 = nil;

        if ($eqeq(base, path)) {
          return 0
        } else if ($eqeq(base, $$('SLASH'))) {
          if ($truthy(($ret_or_1 = path['$start_with?']($$('SLASH'))))) {
            return 1
          } else {
            return $ret_or_1
          }
        } else if ($truthy(($ret_or_1 = path['$start_with?']($rb_plus(base, $$('SLASH')))))) {
          
          return $rb_plus(base.$length(), 1);
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$relative_path', function $$relative_path(path, base) {
        var self = this, offset = nil;

        if ($truthy(self['$root?'](path))) {
          if ($truthy((offset = self['$descends_from?'](path, base)))) {
            return path.$slice(offset, path.$length())
          } else {
            
            try {
              return $$('Pathname').$new(path).$relative_path_from($$('Pathname').$new(base)).$to_s()
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  return path
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }          }
        } else {
          return path
        }
      });
      
      $def(self, '$posixify', function $$posixify(path) {
        var self = this;

        if ($truthy(path)) {
          if (($eqeq(self.file_separator, $$('BACKSLASH')) && ($truthy(path['$include?']($$('BACKSLASH')))))) {
            
            return path.$tr($$('BACKSLASH'), $$('SLASH'));
          } else {
            return path
          }
        } else {
          return ""
        }
      });
      $alias(self, "posixfy", "posixify");
      
      $def(self, '$expand_path', function $$expand_path(path) {
        var $a, $b, self = this, path_segments = nil, path_root = nil, resolved_segments = nil;

        
        $b = self.$partition_path(path), $a = $to_ary($b), (path_segments = ($a[0] == null ? nil : $a[0])), (path_root = ($a[1] == null ? nil : $a[1]));
        if ($truthy(path['$include?']($$('DOT_DOT')))) {
          
          resolved_segments = [];
          $send(path_segments, 'each', [], function $$7(segment){
            
            if (segment == null) segment = nil;
            if ($eqeq(segment, $$('DOT_DOT'))) {
              return resolved_segments.$pop()
            } else {
              return resolved_segments['$<<'](segment)
            }});
          return self.$join_path(resolved_segments, path_root);
        } else {
          return self.$join_path(path_segments, path_root)
        }      });
      
      $def(self, '$partition_path', function $$partition_path(path, web) {
        var $a, self = this, result = nil, cache = nil, posix_path = nil, root = nil, path_segments = nil;

        
        if (web == null) web = nil;
        if ($truthy((result = (cache = ($truthy(web) ? (self._partition_path_web) : (self._partition_path_sys)))['$[]'](path)))) {
          return result
        }        posix_path = self.$posixify(path);
        if ($truthy(web)) {
          if ($truthy(self['$web_root?'](posix_path))) {
            root = $$('SLASH');
          } else if ($truthy(posix_path['$start_with?']($$('DOT_SLASH')))) {
            root = $$('DOT_SLASH');
          }
        } else if ($truthy(self['$root?'](posix_path))) {
          if ($truthy(self['$unc?'](posix_path))) {
            root = $$('DOUBLE_SLASH');
          } else if ($truthy(posix_path['$start_with?']($$('SLASH')))) {
            root = $$('SLASH');
          } else if ($truthy(posix_path['$start_with?']($$('URI_CLASSLOADER')))) {
            root = posix_path.$slice(0, $$('URI_CLASSLOADER').$length());
          } else {
            root = posix_path.$slice(0, $rb_plus(posix_path.$index($$('SLASH')), 1));
          }
        } else if ($truthy(posix_path['$start_with?']($$('DOT_SLASH')))) {
          root = $$('DOT_SLASH');
        }        path_segments = ($truthy(root) ? (posix_path.$slice(root.$length(), posix_path.$length())) : (posix_path)).$split($$('SLASH'));
        path_segments.$delete($$('DOT'));
        return ($a = [path, [path_segments, root]], $send(cache, '[]=', $a), $a[$a.length - 1]);
      }, -2);
      
      $def(self, '$join_path', function $$join_path(segments, root) {
        
        
        if (root == null) root = nil;
        if ($truthy(root)) {
          return "" + (root) + (segments.$join($$('SLASH')))
        } else {
          
          return segments.$join($$('SLASH'));
        }      }, -2);
      
      $def(self, '$system_path', function $$system_path(target, start, jail, opts) {
        var $a, $b, self = this, target_path = nil, $ret_or_1 = nil, target_segments = nil, jail_segments = nil, jail_root = nil, recheck = nil, start_segments = nil, start_root = nil, resolved_segments = nil, unresolved_segments = nil, warned = nil;

        
        if (start == null) start = nil;
        if (jail == null) jail = nil;
        if (opts == null) opts = $hash2([], {});
        if ($truthy(jail)) {
          
          if (!$truthy(self['$root?'](jail))) {
            self.$raise($$$('SecurityError'), "Jail is not an absolute path: " + (jail));
          }          jail = self.$posixify(jail);
        }        if ($truthy(target)) {
          if ($truthy(self['$root?'](target))) {
            
            target_path = self.$expand_path(target);
            if (($truthy(jail) && ($not(self['$descends_from?'](target_path, jail))))) {
              if ($truthy(opts.$fetch("recover", true))) {
                
                self.$logger().$warn("" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " is outside of jail; recovering automatically");
                $b = self.$partition_path(target_path), $a = $to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0]));
                $b = self.$partition_path(jail), $a = $to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1]));
                return self.$join_path($rb_plus(jail_segments, target_segments), jail_root);
              } else {
                self.$raise($$$('SecurityError'), "" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " " + (target) + " is outside of jail: " + (jail) + " (disallowed in safe mode)");
              }
            }            return target_path;
          } else {
            $b = self.$partition_path(target), $a = $to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0]));
          }
        } else {
          target_segments = [];
        }        if ($truthy(target_segments['$empty?']())) {
          if ($truthy(start['$nil_or_empty?']())) {
            return ($truthy(($ret_or_1 = jail)) ? ($ret_or_1) : (self.working_dir))
          } else if ($truthy(self['$root?'](start))) {
            if ($truthy(jail)) {
              start = self.$posixify(start);
            } else {
              return self.$expand_path(start)
            }
          } else {
            
            $b = self.$partition_path(start), $a = $to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0]));
            start = ($truthy(($ret_or_1 = jail)) ? ($ret_or_1) : (self.working_dir));
          }
        } else if ($truthy(start['$nil_or_empty?']())) {
          start = ($truthy(($ret_or_1 = jail)) ? ($ret_or_1) : (self.working_dir));
        } else if ($truthy(self['$root?'](start))) {
          if ($truthy(jail)) {
            start = self.$posixify(start);
          }
        } else {
          start = "" + (($truthy(($ret_or_1 = jail)) ? ($ret_or_1) : (self.working_dir)).$chomp("/")) + "/" + (start);
        }        if ((($truthy(jail) && ($truthy((recheck = self['$descends_from?'](start, jail)['$!']())))) && ($eqeq(self.file_separator, $$('BACKSLASH'))))) {
          
          $b = self.$partition_path(start), $a = $to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (start_root = ($a[1] == null ? nil : $a[1]));
          $b = self.$partition_path(jail), $a = $to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1]));
          if ($neqeq(start_root, jail_root)) {
            if ($truthy(opts.$fetch("recover", true))) {
              
              self.$logger().$warn("start path for " + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " is outside of jail root; recovering automatically");
              start_segments = jail_segments;
              recheck = false;
            } else {
              self.$raise($$$('SecurityError'), "start path for " + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " " + (start) + " refers to location outside jail root: " + (jail) + " (disallowed in safe mode)");
            }
          }        } else {
          $b = self.$partition_path(start), $a = $to_ary($b), (start_segments = ($a[0] == null ? nil : $a[0])), (jail_root = ($a[1] == null ? nil : $a[1]));
        }        if ($truthy((resolved_segments = $rb_plus(start_segments, target_segments))['$include?']($$('DOT_DOT')))) {
          
          $a = [resolved_segments, []], (unresolved_segments = $a[0]), (resolved_segments = $a[1]);
          if ($truthy(jail)) {
            
            if (!$truthy(jail_segments)) {
              $b = self.$partition_path(jail), $a = $to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0]));
            }            warned = false;
            $send(unresolved_segments, 'each', [], function $$8(segment){var self = $$8.$$s == null ? this : $$8.$$s;

              
              if (segment == null) segment = nil;
              if ($eqeq(segment, $$('DOT_DOT'))) {
                if ($truthy($rb_gt(resolved_segments.$size(), jail_segments.$size()))) {
                  return resolved_segments.$pop()
                } else if ($truthy(opts.$fetch("recover", true))) {
                  if ($truthy(warned)) {
                    return nil
                  } else {
                    
                    self.$logger().$warn("" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " has illegal reference to ancestor of jail; recovering automatically");
                    return (warned = true);
                  }
                } else {
                  return self.$raise($$$('SecurityError'), "" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " " + (target) + " refers to location outside jail: " + (jail) + " (disallowed in safe mode)")
                }
              } else {
                return resolved_segments['$<<'](segment)
              }}, {$$s: self});
          } else {
            $send(unresolved_segments, 'each', [], function $$9(segment){
              
              if (segment == null) segment = nil;
              if ($eqeq(segment, $$('DOT_DOT'))) {
                return resolved_segments.$pop()
              } else {
                return resolved_segments['$<<'](segment)
              }});
          }        }        if ($truthy(recheck)) {
          
          target_path = self.$join_path(resolved_segments, jail_root);
          if ($truthy(self['$descends_from?'](target_path, jail))) {
            return target_path
          } else if ($truthy(opts.$fetch("recover", true))) {
            
            self.$logger().$warn("" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " is outside of jail; recovering automatically");
            if (!$truthy(jail_segments)) {
              $b = self.$partition_path(jail), $a = $to_ary($b), (jail_segments = ($a[0] == null ? nil : $a[0]));
            }            return self.$join_path($rb_plus(jail_segments, target_segments), jail_root);
          } else {
            return self.$raise($$$('SecurityError'), "" + (($truthy(($ret_or_1 = opts['$[]']("target_name"))) ? ($ret_or_1) : ("path"))) + " " + (target) + " is outside of jail: " + (jail) + " (disallowed in safe mode)")
          }        } else {
          return self.$join_path(resolved_segments, jail_root)
        }      }, -2);
      
      $def(self, '$web_path', function $$web_path(target, start) {
        var $a, $b, self = this, uri_prefix = nil, target_segments = nil, target_root = nil, resolved_segments = nil, resolved_path = nil;

        
        if (start == null) start = nil;
        target = self.$posixify(target);
        start = self.$posixify(start);
        if (!($truthy(start['$nil_or_empty?']()) || ($truthy(self['$web_root?'](target))))) {
          $b = self.$extract_uri_prefix("" + (start) + (($truthy(start['$end_with?']($$('SLASH'))) ? ("") : ($$('SLASH')))) + (target)), $a = $to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (uri_prefix = ($a[1] == null ? nil : $a[1]));
        }        $b = self.$partition_path(target, true), $a = $to_ary($b), (target_segments = ($a[0] == null ? nil : $a[0])), (target_root = ($a[1] == null ? nil : $a[1]));
        resolved_segments = [];
        $send(target_segments, 'each', [], function $$10(segment){
          
          if (segment == null) segment = nil;
          if ($eqeq(segment, $$('DOT_DOT'))) {
            if ($truthy(resolved_segments['$empty?']())) {
              if (($truthy(target_root) && ($neqeq(target_root, $$('DOT_SLASH'))))) {
                return nil
              } else {
                return resolved_segments['$<<'](segment)
              }
            } else if ($eqeq(resolved_segments['$[]'](-1), $$('DOT_DOT'))) {
              return resolved_segments['$<<'](segment)
            } else {
              return resolved_segments.$pop()
            }
          } else {
            return resolved_segments['$<<'](segment)
          }});
        if ($truthy((resolved_path = self.$join_path(resolved_segments, target_root))['$include?'](" "))) {
          resolved_path = resolved_path.$gsub(" ", "%20");
        }        if ($truthy(uri_prefix)) {
          return "" + (uri_prefix) + (resolved_path)
        } else {
          return resolved_path
        }      }, -2);
      self.$private();
      return $def(self, '$extract_uri_prefix', function $$extract_uri_prefix(str) {
        var $a;

        if (($truthy(str['$include?'](":")) && ($truthy($$('UriSniffRx')['$=~'](str))))) {
          return [str.$slice((($a = $gvars['~']) === nil ? nil : $a['$[]'](0)).$length(), str.$length()), (($a = $gvars['~']) === nil ? nil : $a['$[]'](0))]
        } else {
          return str
        }
      });
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/reader"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $rb_plus = Opal.rb_plus, $alias = Opal.alias, $hash2 = Opal.hash2, $not = Opal.not, $eqeqeq = Opal.eqeqeq, $to_ary = Opal.to_ary, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $send = Opal.send, $rb_minus = Opal.rb_minus, $thrower = Opal.thrower, $eqeq = Opal.eqeq, $rb_times = Opal.rb_times, $neqeq = Opal.neqeq, $to_a = Opal.to_a, $assign_ivar_val = Opal.assign_ivar_val, $send2 = Opal.send2, $find_super = Opal.find_super, $rb_ge = Opal.rb_ge, $gvars = Opal.gvars, $rb_lt = Opal.rb_lt, $hash = Opal.hash, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('include,attr_reader,+,line_info,attr_accessor,!,===,split,file,dir,dirname,path,basename,lineno,reverse,prepare_lines,empty?,nil_or_empty?,peek_line,[],>,slice,length,process_line,times,shift,read_line,<<,-,unshift_all,has_more_lines?,read_lines,join,unshift,unshift_line,unshift_lines,replace_next_line,start_with?,==,*,read_lines_until,size,clear,cursor,[]=,fetch,!=,cursor_at_mark,warn,logger,message_with_context,pop,push,respond_to?,reverse_each,new,tap,each,instance_variables,instance_variable_get,drop,instance_variable_set,class,object_id,inspect,private,prepare_source_array,prepare_source_string,chomp,valid_encoding?,to_s,raise,to_i,attributes,catalog,pop_include,parse,path=,dup,end_with?,keys,rindex,rootname,key?,attr,reverse!,>=,exceeds_max_depth?,nil?,include_processors?,extensions,extensions?,include_processors,map,skip_front_matter!,adjust_indentation!,include?,=~,preprocess_conditional_directive,preprocess_include_directive,downcase,error,none?,any?,all?,strip,send,resolve_expr_val,rstrip,sub_attributes,attribute_missing,info,parse_attributes,find,handles?,instance,process_method,safe,resolve_include_path,method,split_delimited_value,partition,<,to_a,uniq,sort,call,each_line,infinite?,push_include,delete,first,values,value?,create_include_cursor,delete_at,keep_if,read,uriish?,attr?,require_library,normalize_system_path,file?,relative_path,path_resolver,base_dir,to_f');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Reader');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.file = $proto.lines = $proto.look_ahead = $proto.unescape_next_line = $proto.lineno = $proto.process_lines = $proto.dir = $proto.path = $proto.mark = $proto.source_lines = $proto.saved = nil;
      
      self.$include($$('Logging'));
      (function($base, $super) {
        var self = $klass($base, $super, 'Cursor');

        var $proto = self.$$prototype;

        $proto.lineno = $proto.path = nil;
        
        self.$attr_reader("file", "dir", "path", "lineno");
        
        $def(self, '$initialize', function $$initialize(file, dir, path, lineno) {
          var $a, self = this;

          
          if (dir == null) dir = nil;
          if (path == null) path = nil;
          if (lineno == null) lineno = 1;
          return $a = [file, dir, path, lineno], (self.file = $a[0]), (self.dir = $a[1]), (self.path = $a[2]), (self.lineno = $a[3]), $a;
        }, -2);
        
        $def(self, '$advance', function $$advance(num) {
          var self = this;

          return (self.lineno = $rb_plus(self.lineno, num))
        });
        
        $def(self, '$line_info', function $$line_info() {
          var self = this;

          return "" + (self.path) + ": line " + (self.lineno)
        });
        return $alias(self, "to_s", "line_info");
      })($nesting[0], null);
      self.$attr_reader("file");
      self.$attr_reader("dir");
      self.$attr_reader("path");
      self.$attr_reader("lineno");
      self.$attr_reader("source_lines");
      self.$attr_accessor("process_lines");
      self.$attr_accessor("unterminated");
      
      $def(self, '$initialize', function $$initialize(data, cursor, opts) {
        var $a, $b, self = this, $ret_or_1 = nil;

        
        if (data == null) data = nil;
        if (cursor == null) cursor = nil;
        if (opts == null) opts = $hash2([], {});
        if ($not(cursor)) {
          
          self.file = nil;
          self.dir = ".";
          self.path = "<stdin>";
          self.lineno = 1;
        } else if ($eqeqeq($$$('String'), cursor)) {
          
          self.file = cursor;
          $b = $$$('File').$split(self.file), $a = $to_ary($b), (self.dir = ($a[0] == null ? nil : $a[0])), (self.path = ($a[1] == null ? nil : $a[1]));
          self.lineno = 1;
        } else {
          
          if ($truthy((self.file = cursor.$file()))) {
            
            self.dir = ($truthy(($ret_or_1 = cursor.$dir())) ? ($ret_or_1) : ($$$('File').$dirname(self.file)));
            self.path = ($truthy(($ret_or_1 = cursor.$path())) ? ($ret_or_1) : ($$$('File').$basename(self.file)));
          } else {
            
            self.dir = ($truthy(($ret_or_1 = cursor.$dir())) ? ($ret_or_1) : ("."));
            self.path = ($truthy(($ret_or_1 = cursor.$path())) ? ($ret_or_1) : ("<stdin>"));
          }          self.lineno = ($truthy(($ret_or_1 = cursor.$lineno())) ? ($ret_or_1) : (1));
        }        self.lines = (self.source_lines = self.$prepare_lines(data, opts)).$reverse();
        self.mark = nil;
        self.look_ahead = 0;
        self.process_lines = true;
        self.unescape_next_line = false;
        self.unterminated = nil;
        return (self.saved = nil);
      }, -1);
      
      $def(self, '$has_more_lines?', function $Reader_has_more_lines$ques$1() {
        var self = this;

        if ($truthy(self.lines['$empty?']())) {
          
          self.look_ahead = 0;
          return false;
        } else {
          return true
        }
      });
      
      $def(self, '$empty?', function $Reader_empty$ques$2() {
        var self = this;

        if ($truthy(self.lines['$empty?']())) {
          
          self.look_ahead = 0;
          return true;
        } else {
          return false
        }
      });
      $alias(self, "eof?", "empty?");
      
      $def(self, '$next_line_empty?', function $Reader_next_line_empty$ques$3() {
        var self = this;

        return self.$peek_line()['$nil_or_empty?']()
      });
      
      $def(self, '$peek_line', function $$peek_line(direct) {
        var self = this, next_line = nil, line = nil;

        
        if (direct == null) direct = false;
        while ($truthy(true)) {
        
          next_line = self.lines['$[]'](-1);
          if (($truthy(direct) || ($truthy($rb_gt(self.look_ahead, 0))))) {
            return ($truthy(self.unescape_next_line) ? (next_line.$slice(1, next_line.$length())) : (next_line))
          } else if ($truthy(next_line)) {
            if ($truthy((line = self.$process_line(next_line)))) {
              return line
            }
          } else {
            
            self.look_ahead = 0;
            return nil;
          }        }      }, -1);
      
      $def(self, '$peek_lines', function $$peek_lines(num, direct) {
        var self = this, old_look_ahead = nil, result = nil, $ret_or_1 = nil;

        
        if (num == null) num = nil;
        if (direct == null) direct = false;
        old_look_ahead = self.look_ahead;
        result = [];
        (function(){try { var $t_break = $thrower('break'); return $send(($truthy(($ret_or_1 = num)) ? ($ret_or_1) : ($$('MAX_INT'))), 'times', [], function $$4(){var self = $$4.$$s == null ? this : $$4.$$s, line = nil;
          if (self.lineno == null) self.lineno = nil;

          if ($truthy((line = ($truthy(direct) ? (self.$shift()) : (self.$read_line()))))) {
            return result['$<<'](line)
          } else {
            
            if ($truthy(direct)) {
              self.lineno = $rb_minus(self.lineno, 1);
            };
            $t_break.$throw();
          }}, {$$s: self})} catch($e) {
          if ($e === $t_break) return $e.$v;
          throw $e;
        }})();
        if (!$truthy(result['$empty?']())) {
          
          self.$unshift_all(result);
          if ($truthy(direct)) {
            self.look_ahead = old_look_ahead;
          }        }        return result;
      }, -1);
      
      $def(self, '$read_line', function $$read_line() {
        var self = this;

        if (($truthy($rb_gt(self.look_ahead, 0)) || ($truthy(self['$has_more_lines?']())))) {
          return self.$shift()
        } else {
          return nil
        }
      });
      
      $def(self, '$read_lines', function $$read_lines() {
        var self = this, lines = nil;

        
        lines = [];
        while ($truthy(self['$has_more_lines?']())) {
        lines['$<<'](self.$shift());
        }        return lines;
      });
      $alias(self, "readlines", "read_lines");
      
      $def(self, '$read', function $$read() {
        var self = this;

        return self.$read_lines().$join($$('LF'))
      });
      
      $def(self, '$advance', function $$advance() {
        var self = this;

        if ($truthy(self.$shift())) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$unshift_line', function $$unshift_line(line_to_restore) {
        var self = this;

        
        self.$unshift(line_to_restore);
        return nil;
      });
      $alias(self, "restore_line", "unshift_line");
      
      $def(self, '$unshift_lines', function $$unshift_lines(lines_to_restore) {
        var self = this;

        return self.$unshift_all(lines_to_restore)
      });
      $alias(self, "restore_lines", "unshift_lines");
      
      $def(self, '$replace_next_line', function $$replace_next_line(replacement) {
        var self = this;

        
        self.$shift();
        self.$unshift(replacement);
        return true;
      });
      $alias(self, "replace_line", "replace_next_line");
      
      $def(self, '$skip_blank_lines', function $$skip_blank_lines() {
        var self = this, num_skipped = nil, next_line = nil;

        
        if ($truthy(self['$empty?']())) {
          return nil
        }        num_skipped = 0;
        while ($truthy((next_line = self.$peek_line()))) {
        if ($truthy(next_line['$empty?']())) {
            
            self.$shift();
            num_skipped = $rb_plus(num_skipped, 1);
          } else {
            return num_skipped
          }
        }      });
      
      $def(self, '$skip_comment_lines', function $$skip_comment_lines() {
        var self = this, $ret_or_1 = nil, next_line = nil, ll = nil;

        
        if ($truthy(self['$empty?']())) {
          return nil
        }        while ($truthy(($truthy(($ret_or_1 = (next_line = self.$peek_line()))) ? (next_line['$empty?']()['$!']()) : ($ret_or_1)))) {
        if ($truthy(next_line['$start_with?']("//"))) {
            if ($truthy(next_line['$start_with?']("///"))) {
              if (($truthy($rb_gt((ll = next_line.$length()), 3)) && ($eqeq(next_line, $rb_times("/", ll))))) {
                self.$read_lines_until($hash2(["terminator", "skip_first_line", "read_last_line", "skip_processing", "context"], {"terminator": next_line, "skip_first_line": true, "read_last_line": true, "skip_processing": true, "context": "comment"}));
              } else {
                break
              }
            } else {
              self.$shift();
            }
          } else {
            break
          }
        }        return nil;
      });
      
      $def(self, '$skip_line_comments', function $$skip_line_comments() {
        var self = this, comment_lines = nil, $ret_or_1 = nil, next_line = nil;

        
        if ($truthy(self['$empty?']())) {
          return []
        }        comment_lines = [];
        while ($truthy(($truthy(($ret_or_1 = (next_line = self.$peek_line()))) ? (next_line['$empty?']()['$!']()) : ($ret_or_1)))) {
        if ($truthy(next_line['$start_with?']("//"))) {
            comment_lines['$<<'](self.$shift());
          } else {
            break
          }
        }        return comment_lines;
      });
      
      $def(self, '$terminate', function $$terminate() {
        var self = this;

        
        self.lineno = $rb_plus(self.lineno, self.lines.$size());
        self.lines.$clear();
        self.look_ahead = 0;
        return nil;
      });
      
      $def(self, '$read_lines_until', function $$read_lines_until(options) {
        var $a, $yield = $$read_lines_until.$$p || nil, self = this, result = nil, restore_process_lines = nil, terminator = nil, start_cursor = nil, $ret_or_1 = nil, break_on_blank_lines = nil, break_on_list_continuation = nil, skip_comments = nil, line_read = nil, line_restored = nil, line = nil, $ret_or_2 = nil, $ret_or_3 = nil, $ret_or_4 = nil, $ret_or_5 = nil, context = nil;

        $$read_lines_until.$$p = null;
        
        if (options == null) options = $hash2([], {});
        result = [];
        if (($truthy(self.process_lines) && ($truthy(options['$[]']("skip_processing"))))) {
          
          self.process_lines = false;
          restore_process_lines = true;
        }        if ($truthy((terminator = options['$[]']("terminator")))) {
          
          start_cursor = ($truthy(($ret_or_1 = options['$[]']("cursor"))) ? ($ret_or_1) : (self.$cursor()));
          break_on_blank_lines = false;
          break_on_list_continuation = false;
        } else {
          
          break_on_blank_lines = options['$[]']("break_on_blank_lines");
          break_on_list_continuation = options['$[]']("break_on_list_continuation");
        }        skip_comments = options['$[]']("skip_line_comments");
        line_read = (line_restored = nil);
        if ($truthy(options['$[]']("skip_first_line"))) {
          self.$shift();
        }        while ($truthy((line = self.$read_line()))) {
        
          if ($truthy(($truthy(terminator) ? (line['$=='](terminator)) : (($truthy(($ret_or_1 = ($truthy(($ret_or_2 = ($truthy(($ret_or_3 = break_on_blank_lines)) ? (line['$empty?']()) : ($ret_or_3)))) ? ($ret_or_2) : (($truthy(($ret_or_3 = ($truthy(($ret_or_4 = ($truthy(($ret_or_5 = break_on_list_continuation)) ? (line_read) : ($ret_or_5)))) ? (line['$==']($$('LIST_CONTINUATION'))) : ($ret_or_4)))) ? (($a = ["preserve_last_line", true], $send(options, '[]=', $a), $a[$a.length - 1])) : ($ret_or_3)))))) ? ($ret_or_1) : (($truthy(($ret_or_2 = ($yield !== nil))) ? (Opal.yield1($yield, line)) : ($ret_or_2)))))))) {
            
            if ($truthy(options['$[]']("read_last_line"))) {
              result['$<<'](line);
            }            if ($truthy(options['$[]']("preserve_last_line"))) {
              
              self.$unshift(line);
              line_restored = true;
            }            break;
          }          if (!(($truthy(skip_comments) && ($truthy(line['$start_with?']("//")))) && ($not(line['$start_with?']("///"))))) {
            
            result['$<<'](line);
            line_read = true;
          }        }        if ($truthy(restore_process_lines)) {
          
          self.process_lines = true;
          if (($truthy(line_restored) && ($not(terminator)))) {
            self.look_ahead = $rb_minus(self.look_ahead, 1);
          }        }        if ((($truthy(terminator) && ($neqeq(terminator, line))) && ($truthy((context = options.$fetch("context", terminator)))))) {
          
          if ($eqeq(start_cursor, "at_mark")) {
            start_cursor = self.$cursor_at_mark();
          }          self.$logger().$warn(self.$message_with_context("unterminated " + (context) + " block", $hash2(["source_location"], {"source_location": start_cursor})));
          self.unterminated = true;
        }        return result;
      }, -1);
      
      $def(self, '$shift', function $$shift() {
        var self = this;

        
        self.lineno = $rb_plus(self.lineno, 1);
        if (!$eqeq(self.look_ahead, 0)) {
          self.look_ahead = $rb_minus(self.look_ahead, 1);
        }        return self.lines.$pop();
      });
      
      $def(self, '$unshift', function $$unshift(line) {
        var self = this;

        
        self.lineno = $rb_minus(self.lineno, 1);
        self.look_ahead = $rb_plus(self.look_ahead, 1);
        self.lines.$push(line);
        return nil;
      });
      if ($eqeq($$$('RUBY_ENGINE'), "jruby")) {
        
        $def(self, '$unshift_all', function $$unshift_all(lines_to_restore) {
          var self = this;

          
          self.lineno = $rb_minus(self.lineno, lines_to_restore.$size());
          self.look_ahead = $rb_plus(self.look_ahead, lines_to_restore.$size());
          if ($truthy(lines_to_restore['$respond_to?']("reverse"))) {
            $send(self.lines, 'push', $to_a(lines_to_restore.$reverse()));
          } else {
            $send(lines_to_restore, 'reverse_each', [], function $$5(it){var self = $$5.$$s == null ? this : $$5.$$s;
              if (self.lines == null) self.lines = nil;

              
              if (it == null) it = nil;
              return self.lines.$push(it);}, {$$s: self});
          }          return nil;
        });
      } else {
        
        $def(self, '$unshift_all', function $$unshift_all(lines_to_restore) {
          var self = this;

          
          self.lineno = $rb_minus(self.lineno, lines_to_restore.$size());
          self.look_ahead = $rb_plus(self.look_ahead, lines_to_restore.$size());
          $send(self.lines, 'push', $to_a(lines_to_restore.$reverse()));
          return nil;
        });
      }      
      $def(self, '$cursor', function $$cursor() {
        var self = this;

        return $$('Cursor').$new(self.file, self.dir, self.path, self.lineno)
      });
      
      $def(self, '$cursor_at_line', function $$cursor_at_line(lineno) {
        var self = this;

        return $$('Cursor').$new(self.file, self.dir, self.path, lineno)
      });
      
      $def(self, '$cursor_at_mark', function $$cursor_at_mark() {
        var self = this;

        if ($truthy(self.mark)) {
          return $send($$('Cursor'), 'new', $to_a(self.mark))
        } else {
          return self.$cursor()
        }
      });
      
      $def(self, '$cursor_before_mark', function $$cursor_before_mark() {
        var $a, $b, self = this, m_file = nil, m_dir = nil, m_path = nil, m_lineno = nil;

        if ($truthy(self.mark)) {
          
          $b = self.mark, $a = $to_ary($b), (m_file = ($a[0] == null ? nil : $a[0])), (m_dir = ($a[1] == null ? nil : $a[1])), (m_path = ($a[2] == null ? nil : $a[2])), (m_lineno = ($a[3] == null ? nil : $a[3]));
          return $$('Cursor').$new(m_file, m_dir, m_path, $rb_minus(m_lineno, 1));
        } else {
          return $$('Cursor').$new(self.file, self.dir, self.path, $rb_minus(self.lineno, 1))
        }
      });
      
      $def(self, '$cursor_at_prev_line', function $$cursor_at_prev_line() {
        var self = this;

        return $$('Cursor').$new(self.file, self.dir, self.path, $rb_minus(self.lineno, 1))
      });
      
      $def(self, '$mark', function $$mark() {
        var self = this;

        return (self.mark = [self.file, self.dir, self.path, self.lineno])
      });
      
      $def(self, '$line_info', function $$line_info() {
        var self = this;

        return "" + (self.path) + ": line " + (self.lineno)
      });
      
      $def(self, '$lines', function $$lines() {
        var self = this;

        return self.lines.$reverse()
      });
      
      $def(self, '$string', function $$string() {
        var self = this;

        return self.lines.$reverse().$join($$('LF'))
      });
      
      $def(self, '$source', function $$source() {
        var self = this;

        return self.source_lines.$join($$('LF'))
      });
      
      $def(self, '$save', function $$save() {
        var self = this;

        
        self.saved = $send($hash2([], {}), 'tap', [], function $$6(accum){var self = $$6.$$s == null ? this : $$6.$$s;

          
          if (accum == null) accum = nil;
          return $send(self.$instance_variables(), 'each', [], function $$7(name){var $a, self = $$7.$$s == null ? this : $$7.$$s, val = nil;

            
            if (name == null) name = nil;
            if (($eqeq(name, "@saved") || ($eqeq(name, "@source_lines")))) {
              return nil
            } else {
              return ($a = [name, ($eqeqeq($$$('Array'), (val = self.$instance_variable_get(name))) ? (val.$drop(0)) : (val))], $send(accum, '[]=', $a), $a[$a.length - 1])
            }}, {$$s: self});}, {$$s: self});
        return nil;
      });
      
      $def(self, '$restore_save', function $$restore_save() {
        var self = this;

        if ($truthy(self.saved)) {
          
          $send(self.saved, 'each', [], function $$8(name, val){var self = $$8.$$s == null ? this : $$8.$$s;

            
            if (name == null) name = nil;
            if (val == null) val = nil;
            return self.$instance_variable_set(name, val);}, {$$s: self});
          return (self.saved = nil);
        } else {
          return nil
        }
      });
      
      $def(self, '$discard_save', $assign_ivar_val("saved", nil));
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {path: " + (self.path.$inspect()) + ", line: " + (self.lineno) + "}>"
      });
      self.$private();
      
      $def(self, '$prepare_lines', function $$prepare_lines(data, opts) {
        var self = this, normalize = nil;

        
        if (opts == null) opts = $hash2([], {});
        try {
          if ($truthy((normalize = opts['$[]']("normalize")))) {
            if ($eqeqeq($$$('Array'), data)) {
              
              return $$('Helpers').$prepare_source_array(data, normalize['$!=']("chomp"));
            } else {
              
              return $$('Helpers').$prepare_source_string(data, normalize['$!=']("chomp"));
            }
          } else if ($eqeqeq($$$('Array'), data)) {
            return data.$drop(0)
          } else if ($truthy(data)) {
            return data.$chomp().$split($$('LF'), -1)
          } else {
            return []
          }
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {
            try {
              if ($truthy(($eqeqeq($$$('Array'), data) ? (data.$join()) : (data.$to_s()))['$valid_encoding?']())) {
                return self.$raise()
              } else {
                return self.$raise($$$('ArgumentError'), "source is either binary or contains invalid Unicode data")
              }
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }      }, -2);
      return $def(self, '$process_line', function $$process_line(line) {
        var self = this;

        
        if ($truthy(self.process_lines)) {
          self.look_ahead = $rb_plus(self.look_ahead, 1);
        }        return line;
      });
    })($nesting[0], null, $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'PreprocessorReader');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.include_stack = $proto.lines = $proto.file = $proto.dir = $proto.path = $proto.lineno = $proto.maxdepth = $proto.process_lines = $proto.includes = $proto.document = $proto.unescape_next_line = $proto.include_processor_extensions = $proto.look_ahead = $proto.skipping = $proto.conditional_stack = nil;
      
      self.$attr_reader("include_stack");
      
      $def(self, '$initialize', function $$initialize(document, data, cursor, opts) {
        $$initialize.$$p || nil; var self = this, default_include_depth = nil, $ret_or_1 = nil;

        $$initialize.$$p = null;
        
        if (data == null) data = nil;
        if (cursor == null) cursor = nil;
        if (opts == null) opts = $hash2([], {});
        self.document = document;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [data, cursor, opts], null);
        if ($truthy($rb_gt((default_include_depth = ($truthy(($ret_or_1 = document.$attributes()['$[]']("max-include-depth"))) ? ($ret_or_1) : (64)).$to_i()), 0))) {
          self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": default_include_depth, "curr": default_include_depth, "rel": default_include_depth});
        } else {
          self.maxdepth = nil;
        }        self.include_stack = [];
        self.includes = document.$catalog()['$[]']("includes");
        self.skipping = false;
        self.conditional_stack = [];
        return (self.include_processor_extensions = nil);
      }, -2);
      
      $def(self, '$has_more_lines?', function $PreprocessorReader_has_more_lines$ques$9() {
        var self = this;

        if ($truthy(self.$peek_line())) {
          return true
        } else {
          return false
        }
      });
      
      $def(self, '$empty?', function $PreprocessorReader_empty$ques$10() {
        var self = this;

        if ($truthy(self.$peek_line())) {
          return false
        } else {
          return true
        }
      });
      $alias(self, "eof?", "empty?");
      
      $def(self, '$peek_line', function $$peek_line(direct) {
        var $yield = $$peek_line.$$p || nil, self = this, line = nil;

        $$peek_line.$$p = null;
        
        if (direct == null) direct = false;
        if ($truthy((line = $send2(self, $find_super(self, 'peek_line', $$peek_line, false, true), 'peek_line', [direct], $yield)))) {
          return line
        } else if ($truthy(self.include_stack['$empty?']())) {
          return nil
        } else {
          
          self.$pop_include();
          return self.$peek_line(direct);
        }      }, -1);
      
      $def(self, '$push_include', function $$push_include(data, file, path, lineno, attributes) {
        var self = this, dir = nil, $ret_or_1 = nil, rel_maxdepth = nil, curr_maxdepth = nil, abs_maxdepth = nil, leveloffset = nil;

        
        if (file == null) file = nil;
        if (path == null) path = nil;
        if (lineno == null) lineno = 1;
        if (attributes == null) attributes = $hash2([], {});
        self.include_stack['$<<']([self.lines, self.file, self.dir, self.path, self.lineno, self.maxdepth, self.process_lines]);
        if ($truthy((self.file = file))) {
          
          if ($eqeqeq($$$('String'), file)) {
            self.dir = $$$('File').$dirname(file);
          } else if ($truthy($$('RUBY_ENGINE_OPAL'))) {
            self.dir = $$$('URI').$parse($$$('File').$dirname((file = file.$to_s())));
          } else {
            
            (self.dir = file.$dup())['$path='](($eqeq((dir = $$$('File').$dirname(file.$path())), "/") ? ("") : (dir)));
            file = file.$to_s();
          }          self.path = (path = ($truthy(($ret_or_1 = path)) ? ($ret_or_1) : ($$$('File').$basename(file))));
          if ($truthy((self.process_lines = $send(file, 'end_with?', $to_a($$('ASCIIDOC_EXTENSIONS').$keys()))))) {
            if ($truthy(($ret_or_1 = self.includes['$[]'](path.$slice(0, path.$rindex(".")))))) ; else {
              self.includes['$[]='](path.$slice(0, path.$rindex(".")), ($truthy(attributes['$[]']("partial-option")) ? (nil) : (true)));
            }
          }        } else {
          
          self.dir = ".";
          self.process_lines = true;
          if ($truthy((self.path = path))) {
            if ($truthy(($ret_or_1 = self.includes['$[]']($$('Helpers').$rootname(path))))) ; else {
              self.includes['$[]=']($$('Helpers').$rootname(path), ($truthy(attributes['$[]']("partial-option")) ? (nil) : (true)));
            }
          } else {
            self.path = "<stdin>";
          }        }        self.lineno = lineno;
        if (($truthy(self.maxdepth) && ($truthy(attributes['$key?']("depth"))))) {
          if ($truthy($rb_gt((rel_maxdepth = attributes['$[]']("depth").$to_i()), 0))) {
            
            if ($truthy($rb_gt((curr_maxdepth = $rb_plus(self.include_stack.$size(), rel_maxdepth)), (abs_maxdepth = self.maxdepth['$[]']("abs"))))) {
              curr_maxdepth = (rel_maxdepth = abs_maxdepth);
            }            self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": abs_maxdepth, "curr": curr_maxdepth, "rel": rel_maxdepth});
          } else {
            self.maxdepth = $hash2(["abs", "curr", "rel"], {"abs": self.maxdepth['$[]']("abs"), "curr": self.include_stack.$size(), "rel": 0});
          }
        }        if ($truthy((self.lines = self.$prepare_lines(data, $hash2(["normalize", "condense", "indent"], {"normalize": ($truthy(($ret_or_1 = self.process_lines)) ? ($ret_or_1) : ("chomp")), "condense": false, "indent": attributes['$[]']("indent")})))['$empty?']())) {
          self.$pop_include();
        } else {
          
          if ($truthy(attributes['$key?']("leveloffset"))) {
            
            self.lines = $rb_plus($rb_plus([($truthy((leveloffset = self.document.$attr("leveloffset"))) ? (":leveloffset: " + (leveloffset)) : (":leveloffset!:")), ""], self.lines.$reverse()), ["", ":leveloffset: " + (attributes['$[]']("leveloffset"))]);
            self.lineno = $rb_minus(self.lineno, 2);
          } else {
            self.lines['$reverse!']();
          }          self.look_ahead = 0;
        }        return self;
      }, -2);
      
      $def(self, '$include_depth', function $$include_depth() {
        var self = this;

        return self.include_stack.$size()
      });
      
      $def(self, '$exceeds_max_depth?', function $PreprocessorReader_exceeds_max_depth$ques$11() {
        var self = this, $ret_or_1 = nil, $ret_or_2 = nil;

        if ($truthy(($ret_or_1 = ($truthy(($ret_or_2 = self.maxdepth)) ? ($rb_ge(self.include_stack.$size(), self.maxdepth['$[]']("curr"))) : ($ret_or_2))))) {
          return self.maxdepth['$[]']("rel")
        } else {
          return $ret_or_1
        }
      });
      $alias(self, "exceeded_max_depth?", "exceeds_max_depth?");
      
      $def(self, '$shift', function $$shift() {
        var $yield = $$shift.$$p || nil, self = this, line = nil;

        $$shift.$$p = null;
        if ($truthy(self.unescape_next_line)) {
          
          self.unescape_next_line = false;
          return (line = $send2(self, $find_super(self, 'shift', $$shift, false, true), 'shift', [], $yield)).$slice(1, line.$length());
        } else {
          return $send2(self, $find_super(self, 'shift', $$shift, false, true), 'shift', [], $yield)
        }
      });
      
      $def(self, '$include_processors?', function $PreprocessorReader_include_processors$ques$12() {
        var self = this;

        if ($truthy(self.include_processor_extensions['$nil?']())) {
          if (($truthy(self.document['$extensions?']()) && ($truthy(self.document.$extensions()['$include_processors?']())))) {
            return (self.include_processor_extensions = self.document.$extensions().$include_processors())['$!']()['$!']()
          } else {
            return (self.include_processor_extensions = false)
          }
        } else {
          return self.include_processor_extensions['$!='](false)
        }
      });
      
      $def(self, '$create_include_cursor', function $$create_include_cursor(file, path, lineno) {
        var dir = nil;

        
        if ($eqeqeq($$$('String'), file)) {
          dir = $$$('File').$dirname(file);
        } else if ($truthy($$('RUBY_ENGINE_OPAL'))) {
          dir = $$$('File').$dirname((file = file.$to_s()));
        } else {
          
          dir = ($eqeq((dir = $$$('File').$dirname(file.$path())), "") ? ("/") : (dir));
          file = file.$to_s();
        }        return $$('Cursor').$new(file, dir, path, lineno);
      });
      
      $def(self, '$to_s', function $$to_s() {
        var self = this;

        return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {path: " + (self.path.$inspect()) + ", line: " + (self.lineno) + ", include depth: " + (self.include_stack.$size()) + ", include stack: [" + ($send(self.include_stack, 'map', [], function $$13(inc){
          
          if (inc == null) inc = nil;
          return inc.$to_s();}).$join(", ")) + "]}>"
      });
      self.$private();
      
      $def(self, '$prepare_lines', function $$prepare_lines(data, opts) {
        var $yield = $$prepare_lines.$$p || nil, self = this, result = nil, front_matter = nil, $ret_or_1 = nil, last = nil;

        $$prepare_lines.$$p = null;
        
        if (opts == null) opts = $hash2([], {});
        result = $send2(self, $find_super(self, 'prepare_lines', $$prepare_lines, false, true), 'prepare_lines', [data, opts], $yield);
        if ((($truthy(self.document) && ($truthy(self.document.$attributes()['$[]']("skip-front-matter")))) && ($truthy((front_matter = self['$skip_front_matter!'](result)))))) {
          self.document.$attributes()['$[]=']("front-matter", front_matter.$join($$('LF')));
        }        if ($truthy(opts.$fetch("condense", true))) {
          while ($truthy(($truthy(($ret_or_1 = (last = result['$[]'](-1)))) ? (last['$empty?']()) : ($ret_or_1)))) {
          result.$pop();
          }
        }        if ($truthy(opts['$[]']("indent"))) {
          $$('Parser')['$adjust_indentation!'](result, opts['$[]']("indent").$to_i(), self.document.$attr("tabsize").$to_i());
        }        return result;
      }, -2);
      
      $def(self, '$process_line', function $$process_line(line) {
        var $a, self = this;

        
        if (!$truthy(self.process_lines)) {
          return line
        }        if ($truthy(line['$empty?']())) {
          
          self.look_ahead = $rb_plus(self.look_ahead, 1);
          return line;
        }        if ((($truthy(line['$end_with?']("]")) && ($not(line['$start_with?']("[")))) && ($truthy(line['$include?']("::"))))) {
          if (($truthy(line['$include?']("if")) && ($truthy($$('ConditionalDirectiveRx')['$=~'](line))))) {
            if ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), "\\")) {
              
              self.unescape_next_line = true;
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line.$slice(1, line.$length());
            } else if ($truthy(self.$preprocess_conditional_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](4)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](5))))) {
              
              self.$shift();
              return nil;
            } else {
              
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line;
            }
          } else if ($truthy(self.skipping)) {
            
            self.$shift();
            return nil;
          } else if (($truthy(line['$start_with?']("inc", "\\inc")) && ($truthy($$('IncludeDirectiveRx')['$=~'](line))))) {
            if ($eqeq((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), "\\")) {
              
              self.unescape_next_line = true;
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line.$slice(1, line.$length());
            } else if ($truthy(self.$preprocess_include_directive((($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](3))))) {
              return nil
            } else {
              
              self.look_ahead = $rb_plus(self.look_ahead, 1);
              return line;
            }
          } else {
            
            self.look_ahead = $rb_plus(self.look_ahead, 1);
            return line;
          }
        } else if ($truthy(self.skipping)) {
          
          self.$shift();
          return nil;
        } else {
          
          self.look_ahead = $rb_plus(self.look_ahead, 1);
          return line;
        }      });
      
      $def(self, '$preprocess_conditional_directive', function $$preprocess_conditional_directive(keyword, target, delimiter, text) {
        var $a, self = this, no_target = nil, pair = nil, skip = nil, lhs = nil, op = nil, rhs = nil;

        
        if (!$truthy((no_target = target['$empty?']()))) {
          target = target.$downcase();
        }        if ($eqeq(keyword, "endif")) {
          
          if ($truthy(text)) {
            self.$logger().$error(self.$message_with_context("malformed preprocessor directive - text not permitted: endif::" + (target) + "[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
          } else if ($truthy(self.conditional_stack['$empty?']())) {
            self.$logger().$error(self.$message_with_context("unmatched preprocessor directive: endif::" + (target) + "[]", $hash2(["source_location"], {"source_location": self.$cursor()})));
          } else if (($truthy(no_target) || ($eqeq(target, (pair = self.conditional_stack['$[]'](-1))['$[]']("target"))))) {
            
            self.conditional_stack.$pop();
            self.skipping = ($truthy(self.conditional_stack['$empty?']()) ? (false) : (self.conditional_stack['$[]'](-1)['$[]']("skipping")));
          } else {
            self.$logger().$error(self.$message_with_context("mismatched preprocessor directive: endif::" + (target) + "[], expected endif::" + (pair['$[]']("target")) + "[]", $hash2(["source_location"], {"source_location": self.$cursor()})));
          }          return true;
        } else if ($truthy(self.skipping)) {
          skip = false;
        } else 
        switch (keyword) {
          case "ifdef":
            
            if ($truthy(no_target)) {
              
              self.$logger().$error(self.$message_with_context("malformed preprocessor directive - missing target: ifdef::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
              return true;
            }            
            switch (delimiter) {
              case ",":
                skip = $send(target.$split(",", -1), 'none?', [], function $$14(name){var self = $$14.$$s == null ? this : $$14.$$s;
                  if (self.document == null) self.document = nil;

                  
                  if (name == null) name = nil;
                  return self.document.$attributes()['$key?'](name);}, {$$s: self});
                break;
              case "+":
                skip = $send(target.$split("+", -1), 'any?', [], function $$15(name){var self = $$15.$$s == null ? this : $$15.$$s;
                  if (self.document == null) self.document = nil;

                  
                  if (name == null) name = nil;
                  return self.document.$attributes()['$key?'](name)['$!']();}, {$$s: self});
                break;
              default:
                skip = self.document.$attributes()['$key?'](target)['$!']();
            }            break;
          case "ifndef":
            
            if ($truthy(no_target)) {
              
              self.$logger().$error(self.$message_with_context("malformed preprocessor directive - missing target: ifndef::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
              return true;
            }            
            switch (delimiter) {
              case ",":
                skip = $send(target.$split(",", -1), 'any?', [], function $$16(name){var self = $$16.$$s == null ? this : $$16.$$s;
                  if (self.document == null) self.document = nil;

                  
                  if (name == null) name = nil;
                  return self.document.$attributes()['$key?'](name);}, {$$s: self});
                break;
              case "+":
                skip = $send(target.$split("+", -1), 'all?', [], function $$17(name){var self = $$17.$$s == null ? this : $$17.$$s;
                  if (self.document == null) self.document = nil;

                  
                  if (name == null) name = nil;
                  return self.document.$attributes()['$key?'](name);}, {$$s: self});
                break;
              default:
                skip = self.document.$attributes()['$key?'](target);
            }            break;
          case "ifeval":
            if ($truthy(no_target)) {
              if (($truthy(text) && ($truthy($$('EvalExpressionRx')['$=~'](text.$strip()))))) {
                
                lhs = (($a = $gvars['~']) === nil ? nil : $a['$[]'](1));
                op = (($a = $gvars['~']) === nil ? nil : $a['$[]'](2));
                rhs = (($a = $gvars['~']) === nil ? nil : $a['$[]'](3));
                skip = (function() { try {
                  if ($truthy(self.$resolve_expr_val(lhs).$send(op, self.$resolve_expr_val(rhs)))) {
                    return false
                  } else {
                    return true
                  }
                } catch ($err) {
                  if (Opal.rescue($err, [$$('StandardError')])) {
                    try {
                      return true
                    } finally { Opal.pop_exception(); }
                  } else { throw $err; }
                }})();
              } else {
                
                self.$logger().$error(self.$message_with_context("malformed preprocessor directive - " + (($truthy(text) ? ("invalid expression") : ("missing expression"))) + ": ifeval::[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
                return true;
              }
            } else {
              
              self.$logger().$error(self.$message_with_context("malformed preprocessor directive - target not permitted: ifeval::" + (target) + "[" + (text) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
              return true;
            }
            break;
        }        if (($eqeq(keyword, "ifeval") || ($not(text)))) {
          
          if ($truthy(skip)) {
            self.skipping = true;
          }          self.conditional_stack['$<<']($hash2(["target", "skip", "skipping"], {"target": target, "skip": skip, "skipping": self.skipping}));
        } else if (!($truthy(self.skipping) || ($truthy(skip)))) {
          
          self.$replace_next_line(text.$rstrip());
          self.$unshift("");
          if ($truthy(text['$start_with?']("include::"))) {
            self.look_ahead = $rb_minus(self.look_ahead, 1);
          }        }        return true;
      });
      
      $def(self, '$preprocess_include_directive', function $$preprocess_include_directive(target, attrlist) {
        var $a, $b, self = this, doc = nil, expanded_target = nil, attr_missing = nil, $ret_or_1 = nil, ext = nil, parsed_attrs = nil, inc_path = nil, target_type = nil, relpath = nil, reader = nil, read_mode = nil, enc = nil, read_mode_params = nil, inc_linenos = nil, inc_tags = nil, tag = nil, inc_lines = nil, inc_offset = nil, inc_lineno = nil, tag_stack = nil, tags_selected = nil, active_tag = nil, select = nil, base_select = nil, wildcard = nil, missing_tags = nil, inc_content = nil;

        
        doc = self.document;
        if (($truthy((expanded_target = target)['$include?']($$('ATTR_REF_HEAD'))) && ($truthy((expanded_target = doc.$sub_attributes(target, $hash2(["attribute_missing"], {"attribute_missing": ($eqeq((attr_missing = ($truthy(($ret_or_1 = doc.$attributes()['$[]']("attribute-missing"))) ? ($ret_or_1) : ($$('Compliance').$attribute_missing()))), "warn") ? ("drop-line") : (attr_missing))})))['$empty?']())))) {
          if (($eqeq(attr_missing, "drop-line") && ($truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']())))) {
            
            $send(self.$logger(), 'info', [], function $$18(){var self = $$18.$$s == null ? this : $$18.$$s;

              return self.$message_with_context("include dropped due to missing attribute: include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()}))}, {$$s: self});
            self.$shift();
            return true;
          } else if ($truthy(doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true}))['$[]']("optional-option"))) {
            
            $send(self.$logger(), 'info', [], function $$19(){var self = $$19.$$s == null ? this : $$19.$$s;

              return self.$message_with_context("optional include dropped " + ((($eqeq(attr_missing, "warn") && ($truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']()))) ? ("due to missing attribute") : ("because resolved target is blank"))) + ": include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()}))}, {$$s: self});
            self.$shift();
            return true;
          } else {
            
            self.$logger().$warn(self.$message_with_context("include dropped " + ((($eqeq(attr_missing, "warn") && ($truthy(doc.$sub_attributes($rb_plus(target, " "), $hash2(["attribute_missing", "drop_line_severity"], {"attribute_missing": "drop-line", "drop_line_severity": "ignore"}))['$empty?']()))) ? ("due to missing attribute") : ("because resolved target is blank"))) + ": include::" + (target) + "[" + (attrlist) + "]", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return self.$replace_next_line("Unresolved directive in " + (self.path) + " - include::" + (target) + "[" + (attrlist) + "]");
          }
        } else if (($truthy(self['$include_processors?']()) && ($truthy((ext = $send(self.include_processor_extensions, 'find', [], function $$20(candidate){
          
          if (candidate == null) candidate = nil;
          return candidate.$instance()['$handles?'](expanded_target);})))))) {
          
          self.$shift();
          ext.$process_method()['$[]'](doc, self, expanded_target, doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true})));
          return true;
        } else if ($truthy($rb_ge(doc.$safe(), $$$($$('SafeMode'), 'SECURE')))) {
          return self.$replace_next_line("link:" + (expanded_target) + "[role=include]")
        } else if ($truthy(self.maxdepth)) {
          
          if ($truthy($rb_ge(self.include_stack.$size(), self.maxdepth['$[]']("curr")))) {
            
            self.$logger().$error(self.$message_with_context("maximum include depth of " + (self.maxdepth['$[]']("rel")) + " exceeded", $hash2(["source_location"], {"source_location": self.$cursor()})));
            return nil;
          }          parsed_attrs = doc.$parse_attributes(attrlist, [], $hash2(["sub_input"], {"sub_input": true}));
          $b = self.$resolve_include_path(expanded_target, attrlist, parsed_attrs), $a = $to_ary($b), (inc_path = ($a[0] == null ? nil : $a[0])), (target_type = ($a[1] == null ? nil : $a[1])), (relpath = ($a[2] == null ? nil : $a[2]));
          
          switch (target_type) {
            case "file":
              
              reader = $$$('File').$method("open");
              read_mode = $$('FILE_READ_MODE');
              break;
            case "uri":
              
              reader = $$$('OpenURI').$method("open_uri");
              read_mode = $$('URI_READ_MODE');
              break;
            default:
              return inc_path
          }          if (!$truthy($$('RUBY_ENGINE_OPAL'))) {
            if (($truthy((enc = parsed_attrs['$[]']("encoding"))) && ($truthy((function() { try {
              return $$$('Encoding').$find(enc)
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  return nil
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }})())))) {
              
              (read_mode_params = read_mode.$split(":"))['$[]='](1, enc);
              read_mode = read_mode_params.$join(":");
            }
          }          inc_linenos = (inc_tags = nil);
          if ($truthy(attrlist)) {
            if ($truthy(parsed_attrs['$key?']("lines"))) {
              
              inc_linenos = [];
              $send(self.$split_delimited_value(parsed_attrs['$[]']("lines")), 'each', [], function $$21(linedef){var $c, $d, from = nil, to = nil;

                
                if (linedef == null) linedef = nil;
                if ($truthy(linedef['$include?'](".."))) {
                  
                  $d = linedef.$partition(".."), $c = $to_ary($d), (from = ($c[0] == null ? nil : $c[0])), (($c[1] == null ? nil : $c[1])), (to = ($c[2] == null ? nil : $c[2]));
                  return (inc_linenos = $rb_plus(inc_linenos, (($truthy(to['$empty?']()) || ($truthy($rb_lt((to = to.$to_i()), 0)))) ? ([from.$to_i(), $$$($$$('Float'), 'INFINITY')]) : (Opal.Range.$new(from.$to_i(), to, false).$to_a()))));
                } else {
                  return inc_linenos['$<<'](linedef.$to_i())
                }});
              inc_linenos = ($truthy(inc_linenos['$empty?']()) ? (nil) : (inc_linenos.$sort().$uniq()));
            } else if ($truthy(parsed_attrs['$key?']("tag"))) {
              if (!($truthy((tag = parsed_attrs['$[]']("tag"))['$empty?']()) || ($eqeq(tag, "!")))) {
                inc_tags = ($truthy(tag['$start_with?']("!")) ? ($hash(tag.$slice(1, tag.$length()), false)) : ($hash(tag, true)));
              }
            } else if ($truthy(parsed_attrs['$key?']("tags"))) {
              
              inc_tags = $hash2([], {});
              $send(self.$split_delimited_value(parsed_attrs['$[]']("tags")), 'each', [], function $$22(tagdef){var $c;

                
                if (tagdef == null) tagdef = nil;
                if (($truthy(tagdef['$empty?']()) || ($eqeq(tagdef, "!")))) {
                  return nil
                } else if ($truthy(tagdef['$start_with?']("!"))) {
                  return ($c = [tagdef.$slice(1, tagdef.$length()), false], $send(inc_tags, '[]=', $c), $c[$c.length - 1])
                } else {
                  return ($c = [tagdef, true], $send(inc_tags, '[]=', $c), $c[$c.length - 1])
                }});
              if ($truthy(inc_tags['$empty?']())) {
                inc_tags = nil;
              }            }
          }          if ($truthy(inc_linenos)) {
            
            $a = [[], nil, 0], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]);
            
            try {
              $send(reader, 'call', [inc_path, read_mode], function $$23(f){var select_remaining = nil;

                
                if (f == null) f = nil;
                select_remaining = nil;
                return (function(){try { var $t_break = $thrower('break'); return $send(f, 'each_line', [], function $$24(l){var select = nil;

                  
                  if (l == null) l = nil;
                  inc_lineno = $rb_plus(inc_lineno, 1);
                  if (($truthy(select_remaining) || (($eqeqeq($$$('Float'), (select = inc_linenos['$[]'](0))) && ($truthy((select_remaining = select['$infinite?']()))))))) {
                    
                    inc_offset = ($truthy(($ret_or_1 = inc_offset)) ? ($ret_or_1) : (inc_lineno));
                    return inc_lines['$<<'](l);
                  } else {
                    
                    if ($eqeq(select, inc_lineno)) {
                      
                      inc_offset = ($truthy(($ret_or_1 = inc_offset)) ? ($ret_or_1) : (inc_lineno));
                      inc_lines['$<<'](l);
                      inc_linenos.$shift();
                    };
                    if ($truthy(inc_linenos['$empty?']())) {
                      $t_break.$throw();
                    } else {
                      return nil
                    };
                  };})} catch($e) {
                  if ($e === $t_break) return $e.$v;
                  throw $e;
                }})();});
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }            self.$shift();
            if ($truthy(inc_offset)) {
              
              parsed_attrs['$[]=']("partial-option", "");
              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);
            }          } else if ($truthy(inc_tags)) {
            
            $a = [[], nil, 0, [], $$$('Set').$new(), nil], (inc_lines = $a[0]), (inc_offset = $a[1]), (inc_lineno = $a[2]), (tag_stack = $a[3]), (tags_selected = $a[4]), (active_tag = $a[5]);
            if ($truthy(inc_tags['$key?']("**"))) {
              
              select = (base_select = inc_tags.$delete("**"));
              if ($truthy(inc_tags['$key?']("*"))) {
                wildcard = inc_tags.$delete("*");
              } else if (($not(select) && ($eqeq(inc_tags.$values().$first(), false)))) {
                wildcard = true;
              }            } else if ($truthy(inc_tags['$key?']("*"))) {
              if ($eqeq(inc_tags.$keys().$first(), "*")) {
                select = (base_select = (wildcard = inc_tags.$delete("*"))['$!']());
              } else {
                
                select = (base_select = false);
                wildcard = inc_tags.$delete("*");
              }
            } else {
              select = (base_select = inc_tags['$value?'](true)['$!']());
            }            
            try {
              $send(reader, 'call', [inc_path, read_mode], function $$25(f){var $c, self = $$25.$$s == null ? this : $$25.$$s, dbl_co = nil, dbl_sb = nil;

                
                if (f == null) f = nil;
                $c = ["::", "[]"], (dbl_co = $c[0]), (dbl_sb = $c[1]), $c;
                return $send(f, 'each_line', [], function $$26(l){var $d, $e, self = $$26.$$s == null ? this : $$26.$$s, this_tag = nil, include_cursor = nil, idx = nil;

                  
                  if (l == null) l = nil;
                  inc_lineno = $rb_plus(inc_lineno, 1);
                  if ((($truthy(l['$include?'](dbl_co)) && ($truthy(l['$include?'](dbl_sb)))) && ($truthy($$('TagDirectiveRx')['$=~'](l))))) {
                    
                    this_tag = (($d = $gvars['~']) === nil ? nil : $d['$[]'](2));
                    if ($truthy((($d = $gvars['~']) === nil ? nil : $d['$[]'](1)))) {
                      if ($eqeq(this_tag, active_tag)) {
                        
                        tag_stack.$pop();
                        return $e = ($truthy(tag_stack['$empty?']()) ? ([nil, base_select]) : (tag_stack['$[]'](-1))), $d = $to_ary($e), (active_tag = ($d[0] == null ? nil : $d[0])), (select = ($d[1] == null ? nil : $d[1])), $e;
                      } else if ($truthy(inc_tags['$key?'](this_tag))) {
                        
                        include_cursor = self.$create_include_cursor(inc_path, expanded_target, inc_lineno);
                        if ($truthy((idx = $send(tag_stack, 'rindex', [], function $$27(key){
                          
                          if (key == null) key = nil;
                          return key['$=='](this_tag);}, {$$has_trailing_comma_in_args: true})))) {
                          
                          if ($eqeq(idx, 0)) {
                            tag_stack.$shift();
                          } else {
                            
                            tag_stack.$delete_at(idx);
                          };
                          return self.$logger().$warn(self.$message_with_context("mismatched end tag (expected '" + (active_tag) + "' but found '" + (this_tag) + "') at line " + (inc_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": include_cursor})));
                        } else {
                          return self.$logger().$warn(self.$message_with_context("unexpected end tag '" + (this_tag) + "' at line " + (inc_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": include_cursor})))
                        };
                      } else {
                        return nil
                      }
                    } else if ($truthy(inc_tags['$key?'](this_tag))) {
                      
                      if ($truthy((select = inc_tags['$[]'](this_tag)))) {
                        tags_selected['$<<'](this_tag);
                      };
                      return tag_stack['$<<']([(active_tag = this_tag), select, inc_lineno]);
                    } else if ($not(wildcard['$nil?']())) {
                      
                      select = (($truthy(active_tag) && ($not(select))) ? (false) : (wildcard));
                      return tag_stack['$<<']([(active_tag = this_tag), select, inc_lineno]);
                    } else {
                      return nil
                    };
                  } else if ($truthy(select)) {
                    
                    inc_offset = ($truthy(($ret_or_1 = inc_offset)) ? ($ret_or_1) : (inc_lineno));
                    return inc_lines['$<<'](l);
                  } else {
                    return nil
                  };}, {$$s: self});}, {$$s: self});
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }            if (!$truthy(tag_stack['$empty?']())) {
              $send(tag_stack, 'each', [], function $$28(tag_name, _, tag_lineno){var self = $$28.$$s == null ? this : $$28.$$s;

                
                if (tag_name == null) tag_name = nil;
                if (tag_lineno == null) tag_lineno = nil;
                return self.$logger().$warn(self.$message_with_context("detected unclosed tag '" + (tag_name) + "' starting at line " + (tag_lineno) + " of include " + (target_type) + ": " + (inc_path), $hash2(["source_location", "include_location"], {"source_location": self.$cursor(), "include_location": self.$create_include_cursor(inc_path, expanded_target, tag_lineno)})));}, {$$s: self});
            }            if (!$truthy((missing_tags = $rb_minus($send(inc_tags, 'keep_if', [], function $$29(_, v){
              if (v == null) v = nil;
              return v;}).$keys(), tags_selected.$to_a()))['$empty?']())) {
              self.$logger().$warn(self.$message_with_context("tag" + (($truthy($rb_gt(missing_tags.$size(), 1)) ? ("s") : (""))) + " '" + (missing_tags.$join(", ")) + "' not found in include " + (target_type) + ": " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
            }            self.$shift();
            if ($truthy(inc_offset)) {
              
              if (!(($truthy(base_select) && ($neqeq(wildcard, false))) && ($truthy(inc_tags['$empty?']())))) {
                parsed_attrs['$[]=']("partial-option", "");
              }              self.$push_include(inc_lines, inc_path, relpath, inc_offset, parsed_attrs);
            }          } else {
            
            inc_content = nil;
            
            try {
              
              inc_content = $send(reader, 'call', [inc_path, read_mode], function $$30(f){
                
                if (f == null) f = nil;
                return f.$read();});
              self.$shift();
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  
                  self.$logger().$error(self.$message_with_context("include " + (target_type) + " not readable: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
                  return self.$replace_next_line("Unresolved directive in " + (self.path) + " - include::" + (expanded_target) + "[" + (attrlist) + "]");
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            }            self.$push_include(inc_content, inc_path, relpath, 1, parsed_attrs);
          }          return true;
        } else {
          return nil
        }      });
      
      $def(self, '$resolve_include_path', function $$resolve_include_path(target, attrlist, attributes) {
        var $b, self = this, doc = nil, inc_path = nil, relpath = nil;

        
        doc = self.document;
        if (($truthy($$('Helpers')['$uriish?'](target)) || ($truthy(($eqeqeq($$$('String'), self.dir) ? (nil) : ((target = "" + (self.dir) + "/" + (target)))))))) {
          
          if (!$truthy(doc['$attr?']("allow-uri-read"))) {
            return self.$replace_next_line("link:" + (target) + "[role=include]")
          }          if ($truthy(doc['$attr?']("cache-uri"))) {
            if (!$truthy((($b = $$$('::', 'OpenURI', 'skip_raise')) && ($$$($b, 'Cache', 'skip_raise')) ? 'constant' : nil))) {
              $$('Helpers').$require_library("open-uri/cached", "open-uri-cached");
            }
          } else if ($not($$('RUBY_ENGINE_OPAL'))) {
            $$$('OpenURI');
          }          return [$$$('URI').$parse(target), "uri", target];
        } else {
          
          inc_path = doc.$normalize_system_path(target, self.dir, nil, $hash2(["target_name"], {"target_name": "include file"}));
          if (!$truthy($$$('File')['$file?'](inc_path))) {
            if ($truthy(attributes['$[]']("optional-option"))) {
              
              $send(self.$logger(), 'info', [], function $$31(){var self = $$31.$$s == null ? this : $$31.$$s;

                return self.$message_with_context("optional include dropped because include file not found: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()}))}, {$$s: self});
              self.$shift();
              return true;
            } else {
              
              self.$logger().$error(self.$message_with_context("include file not found: " + (inc_path), $hash2(["source_location"], {"source_location": self.$cursor()})));
              return self.$replace_next_line("Unresolved directive in " + (self.path) + " - include::" + (target) + "[" + (attrlist) + "]");
            }
          }          relpath = doc.$path_resolver().$relative_path(inc_path, doc.$base_dir());
          return [inc_path, "file", relpath];
        }      });
      
      $def(self, '$pop_include', function $$pop_include() {
        var $a, $b, self = this;

        if ($truthy(self.include_stack['$empty?']())) {
          return nil
        } else {
          
          $b = self.include_stack.$pop(), $a = $to_ary($b), (self.lines = ($a[0] == null ? nil : $a[0])), (self.file = ($a[1] == null ? nil : $a[1])), (self.dir = ($a[2] == null ? nil : $a[2])), (self.path = ($a[3] == null ? nil : $a[3])), (self.lineno = ($a[4] == null ? nil : $a[4])), (self.maxdepth = ($a[5] == null ? nil : $a[5])), (self.process_lines = ($a[6] == null ? nil : $a[6]));
          self.look_ahead = 0;
          return nil;
        }
      });
      
      $def(self, '$split_delimited_value', function $$split_delimited_value(val) {
        
        if ($truthy(val['$include?'](","))) {
          
          return val.$split(",");
        } else {
          
          return val.$split(";");
        }
      });
      
      $def(self, '$skip_front_matter!', function $PreprocessorReader_skip_front_matter$excl$32(data, increment_linenos) {
        var self = this, delim = nil, original_data = nil, front_matter = nil, $ret_or_1 = nil, eof = nil;

        
        if (increment_linenos == null) increment_linenos = true;
        if (!$eqeq((delim = data['$[]'](0)), "---")) {
          return nil
        }        original_data = data.$drop(0);
        data.$shift();
        front_matter = [];
        if ($truthy(increment_linenos)) {
          self.lineno = $rb_plus(self.lineno, 1);
        }        while (!($truthy(($truthy(($ret_or_1 = (eof = data['$empty?']()))) ? ($ret_or_1) : (data['$[]'](0)['$=='](delim)))))) {
        
          front_matter['$<<'](data.$shift());
          if ($truthy(increment_linenos)) {
            self.lineno = $rb_plus(self.lineno, 1);
          }        }        if ($truthy(eof)) {
          
          $send(data, 'unshift', $to_a(original_data));
          if ($truthy(increment_linenos)) {
            self.lineno = $rb_minus(self.lineno, original_data.$size());
          }          return nil;
        }        data.$shift();
        if ($truthy(increment_linenos)) {
          self.lineno = $rb_plus(self.lineno, 1);
        }        return front_matter;
      }, -2);
      return $def(self, '$resolve_expr_val', function $$resolve_expr_val(val) {
        var self = this, quoted = nil;

        
        if ((($truthy(val['$start_with?']("\"")) && ($truthy(val['$end_with?']("\"")))) || (($truthy(val['$start_with?']("'")) && ($truthy(val['$end_with?']("'"))))))) {
          
          quoted = true;
          val = val.$slice(1, $rb_minus(val.$length(), 1));
        } else {
          quoted = false;
        }        if ($truthy(val['$include?']($$('ATTR_REF_HEAD')))) {
          val = self.document.$sub_attributes(val, $hash2(["attribute_missing"], {"attribute_missing": "drop"}));
        }        if ($truthy(quoted)) {
          return val
        } else if ($truthy(val['$empty?']())) {
          return nil
        } else if ($eqeq(val, "true")) {
          return true
        } else if ($eqeq(val, "false")) {
          return false
        } else if ($truthy(val.$rstrip()['$empty?']())) {
          return " "
        } else if ($truthy(val['$include?']("."))) {
          return val.$to_f()
        } else {
          return val.$to_i()
        }      });
    })($nesting[0], $$('Reader'), $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/section"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $def = Opal.def, $alias = Opal.alias, $rb_gt = Opal.rb_gt, $eqeq = Opal.eqeq, $not = Opal.not, $send = Opal.send, $defs = Opal.defs, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('attr_accessor,attr_reader,===,+,level,special,title,generate_id,>,==,sectnum,!,empty?,reftext,sub_placeholder,sub_quotes,compat_mode,[],attributes,context,assign_numeral,class,object_id,inspect,size,[]=,chr,length,gsub,downcase,delete,tr_s,end_with?,chop,start_with?,slice,key?,catalog,unique_id_start_index');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Section');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.document = $proto.next_section_index = $proto.parent = $proto.level = $proto.numeral = $proto.numbered = $proto.sectname = $proto.title = $proto.blocks = nil;
      
      self.$attr_accessor("index");
      self.$attr_accessor("sectname");
      self.$attr_accessor("special");
      self.$attr_accessor("numbered");
      self.$attr_reader("caption");
      
      $def(self, '$initialize', function $$initialize(parent, level, numbered, opts) {
        var $a; $$initialize.$$p || nil; var self = this, $ret_or_1 = nil;

        $$initialize.$$p = null;
        
        if (parent == null) parent = nil;
        if (level == null) level = nil;
        if (numbered == null) numbered = false;
        if (opts == null) opts = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, "section", opts], null);
        if ($eqeqeq($$('Section'), parent)) {
          $a = [($truthy(($ret_or_1 = level)) ? ($ret_or_1) : ($rb_plus(parent.$level(), 1))), parent.$special()], (self.level = $a[0]), (self.special = $a[1]);
        } else {
          $a = [($truthy(($ret_or_1 = level)) ? ($ret_or_1) : (1)), false], (self.level = $a[0]), (self.special = $a[1]);
        }        self.numbered = numbered;
        return (self.index = 0);
      }, -1);
      $alias(self, "name", "title");
      
      $def(self, '$generate_id', function $$generate_id() {
        var self = this;

        return $$('Section').$generate_id(self.$title(), self.document)
      });
      
      $def(self, '$sections?', function $Section_sections$ques$1() {
        var self = this;

        return $rb_gt(self.next_section_index, 0)
      });
      
      $def(self, '$sectnum', function $$sectnum(delimiter, append) {
        var self = this, $ret_or_1 = nil;

        
        if (delimiter == null) delimiter = ".";
        if (append == null) append = nil;
        append = ($truthy(($ret_or_1 = append)) ? ($ret_or_1) : (($eqeq(append, false) ? ("") : (delimiter))));
        if (($truthy($rb_gt(self.level, 1)) && ($eqeqeq($$('Section'), self.parent)))) {
          return "" + (self.parent.$sectnum(delimiter, delimiter)) + (self.numeral) + (append)
        } else {
          return "" + (self.numeral) + (append)
        }      }, -1);
      
      $def(self, '$xreftext', function $$xreftext(xrefstyle) {
        var self = this, val = nil, type = nil, quoted_title = nil, signifier = nil;

        
        if (xrefstyle == null) xrefstyle = nil;
        if (($truthy((val = self.$reftext())) && ($not(val['$empty?']())))) {
          return val
        } else if ($truthy(xrefstyle)) {
          if ($truthy(self.numbered)) {
            
            switch (xrefstyle) {
              case "full":
                
                if (($eqeq((type = self.sectname), "chapter") || ($eqeq(type, "appendix")))) {
                  quoted_title = self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title());
                } else {
                  quoted_title = self.$sub_placeholder(self.$sub_quotes(($truthy(self.document.$compat_mode()) ? ("``%s''") : ("\"`%s`\""))), self.$title());
                }                if ($truthy((signifier = self.document.$attributes()['$[]']("" + (type) + "-refsig")))) {
                  return "" + (signifier) + " " + (self.$sectnum(".", ",")) + " " + (quoted_title)
                } else {
                  return "" + (self.$sectnum(".", ",")) + " " + (quoted_title)
                }              case "short":
                if ($truthy((signifier = self.document.$attributes()['$[]']("" + (self.sectname) + "-refsig")))) {
                  return "" + (signifier) + " " + (self.$sectnum(".", ""))
                } else {
                  return self.$sectnum(".", "")
                }
              default:
                if (($eqeq((type = self.sectname), "chapter") || ($eqeq(type, "appendix")))) {
                  
                  return self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title());
                } else {
                  return self.$title()
                }
            }
          } else if (($eqeq((type = self.sectname), "chapter") || ($eqeq(type, "appendix")))) {
            
            return self.$sub_placeholder(self.$sub_quotes("_%s_"), self.$title());
          } else {
            return self.$title()
          }
        } else {
          return self.$title()
        }      }, -1);
      
      $def(self, '$<<', function $Section_$lt$lt$2(block) {
        var $yield = $Section_$lt$lt$2.$$p || nil, self = this;

        $Section_$lt$lt$2.$$p = null;
        
        if ($eqeq(block.$context(), "section")) {
          self.$assign_numeral(block);
        }        return $send2(self, $find_super(self, '<<', $Section_$lt$lt$2, false, true), '<<', [block], $yield);
      });
      
      $def(self, '$to_s', function $$to_s() {
        var $yield = $$to_s.$$p || nil, self = this, formal_title = nil;

        $$to_s.$$p = null;
        if ($truthy(self.title)) {
          
          formal_title = ($truthy(self.numbered) ? ("" + (self.$sectnum()) + " " + (self.title)) : (self.title));
          return "#<" + (self.$class()) + "@" + (self.$object_id()) + " {level: " + (self.level) + ", title: " + (formal_title.$inspect()) + ", blocks: " + (self.blocks.$size()) + "}>";
        } else {
          return $send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], $yield)
        }
      });
      return $defs(self, '$generate_id', function $$generate_id(title, document) {
        var $a, attrs = nil, pre = nil, $ret_or_1 = nil, sep = nil, no_sep = nil, sep_sub = nil, gen_id = nil, ids = nil, cnt = nil, candidate_id = nil;

        
        attrs = document.$attributes();
        pre = ($truthy(($ret_or_1 = attrs['$[]']("idprefix"))) ? ($ret_or_1) : ("_"));
        if ($truthy((sep = attrs['$[]']("idseparator")))) {
          if (($eqeq(sep.$length(), 1) || (($not((no_sep = sep['$empty?']())) && ($truthy((sep = ($a = ["idseparator", sep.$chr()], $send(attrs, '[]=', $a), $a[$a.length - 1])))))))) {
            sep_sub = (($eqeq(sep, "-") || ($eqeq(sep, "."))) ? (" .-") : (" " + (sep) + ".-"));
          }
        } else {
          $a = ["_", " _.-"], (sep = $a[0]), (sep_sub = $a[1]);
        }        gen_id = "" + (pre) + (title.$downcase().$gsub($$('InvalidSectionIdCharsRx'), ""));
        if ($truthy(no_sep)) {
          gen_id = gen_id.$delete(" ");
        } else {
          
          gen_id = gen_id.$tr_s(sep_sub, sep);
          if ($truthy(gen_id['$end_with?'](sep))) {
            gen_id = gen_id.$chop();
          }          if (($truthy(pre['$empty?']()) && ($truthy(gen_id['$start_with?'](sep))))) {
            gen_id = gen_id.$slice(1, gen_id.$length());
          }        }        if ($truthy(document.$catalog()['$[]']("refs")['$key?'](gen_id))) {
          
          ids = document.$catalog()['$[]']("refs");
          cnt = $$('Compliance').$unique_id_start_index();
          while ($truthy(ids['$[]']((candidate_id = "" + (gen_id) + (sep) + (cnt))))) {
          cnt = $rb_plus(cnt, 1);
          }          return candidate_id;
        } else {
          return gen_id
        }      });
    })($nesting[0], $$('AbstractBlock'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/stylesheets"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $return_ivar = Opal.return_ivar, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('join,new,rstrip,read,primary_stylesheet_data,write,primary_stylesheet_name,stylesheet_basename,for,read_stylesheet,coderay_stylesheet_data,coderay_stylesheet_name,pygments_stylesheet_data,pygments_stylesheet_name');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Stylesheets');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.primary_stylesheet_data = nil;
      
      $const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', "asciidoctor.css");
      $const_set($nesting[0], 'STYLESHEETS_DIR', $$$('File').$join($$('DATA_DIR'), "stylesheets"));
      self.__instance__ = self.$new();
      $defs(self, '$instance', $return_ivar("__instance__"));
      
      $def(self, '$primary_stylesheet_name', function $$primary_stylesheet_name() {
        
        return $$('DEFAULT_STYLESHEET_NAME')
      });
      
      $def(self, '$primary_stylesheet_data', function $$primary_stylesheet_data() {
        var self = this, $ret_or_1 = nil;

        return (self.primary_stylesheet_data = ($truthy(($ret_or_1 = self.primary_stylesheet_data)) ? ($ret_or_1) : ($$$('File').$read($$$('File').$join($$('STYLESHEETS_DIR'), "asciidoctor-default.css"), $hash2(["mode"], {"mode": $$('FILE_READ_MODE')})).$rstrip())))
      });
      
      $def(self, '$embed_primary_stylesheet', function $$embed_primary_stylesheet() {
        var self = this;

        return "<style>\n" + (self.$primary_stylesheet_data()) + "\n" + "</style>"
      });
      
      $def(self, '$write_primary_stylesheet', function $$write_primary_stylesheet(target_dir) {
        var self = this;

        
        if (target_dir == null) target_dir = ".";
        return $$$('File').$write($$$('File').$join(target_dir, self.$primary_stylesheet_name()), self.$primary_stylesheet_data(), $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
      }, -1);
      
      $def(self, '$coderay_stylesheet_name', function $$coderay_stylesheet_name() {
        
        return $$('SyntaxHighlighter').$for("coderay").$stylesheet_basename()
      });
      
      $def(self, '$coderay_stylesheet_data', function $$coderay_stylesheet_data() {
        
        return $$('SyntaxHighlighter').$for("coderay").$read_stylesheet()
      });
      
      $def(self, '$embed_coderay_stylesheet', function $$embed_coderay_stylesheet() {
        var self = this;

        return "<style>\n" + (self.$coderay_stylesheet_data()) + "\n" + "</style>"
      });
      
      $def(self, '$write_coderay_stylesheet', function $$write_coderay_stylesheet(target_dir) {
        var self = this;

        
        if (target_dir == null) target_dir = ".";
        return $$$('File').$write($$$('File').$join(target_dir, self.$coderay_stylesheet_name()), self.$coderay_stylesheet_data(), $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
      }, -1);
      
      $def(self, '$pygments_stylesheet_name', function $$pygments_stylesheet_name(style) {
        
        
        if (style == null) style = nil;
        return $$('SyntaxHighlighter').$for("pygments").$stylesheet_basename(style);
      }, -1);
      
      $def(self, '$pygments_stylesheet_data', function $$pygments_stylesheet_data(style) {
        
        
        if (style == null) style = nil;
        return $$('SyntaxHighlighter').$for("pygments").$read_stylesheet(style);
      }, -1);
      
      $def(self, '$embed_pygments_stylesheet', function $$embed_pygments_stylesheet(style) {
        var self = this;

        
        if (style == null) style = nil;
        return "<style>\n" + (self.$pygments_stylesheet_data(style)) + "\n" + "</style>";
      }, -1);
      return $def(self, '$write_pygments_stylesheet', function $$write_pygments_stylesheet(target_dir, style) {
        var self = this;

        
        if (target_dir == null) target_dir = ".";
        if (style == null) style = nil;
        return $$$('File').$write($$$('File').$join(target_dir, self.$pygments_stylesheet_name(style)), self.$pygments_stylesheet_data(style), $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
      }, -1);
    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/table"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $def = Opal.def, $alias = Opal.alias, $hash2 = Opal.hash2, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $rb_gt = Opal.rb_gt, $eqeq = Opal.eqeq, $rb_times = Opal.rb_times, $rb_divide = Opal.rb_divide, $send = Opal.send, $rb_plus = Opal.rb_plus, $rb_minus = Opal.rb_minus, $return_val = Opal.return_val, $to_a = Opal.to_a, $gvars = Opal.gvars, $neqeq = Opal.neqeq, $return_ivar = Opal.return_ivar, $to_ary = Opal.to_ary, $regexp = Opal.regexp, $not = Opal.not, $thrower = Opal.thrower, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_accessor,send,attr_reader,new,[],<,>,to_i,==,[]=,attributes,truncate,*,/,to_f,empty?,body,each,<<,size,+,assign_column_widths,warn,logger,-,update_attributes,assign_width,round,head=,map,shift,reinitialize,nil?,unshift,foot=,pop,parent,sourcemap,dup,header_row?,table,style,merge,delete,start_with?,rstrip,slice,length,advance,lstrip,strip,split,include?,readlines,catalog_inline_anchor,=~,apply_subs,attr_writer,convert,text,!=,file,lineno,include,to_set,mark,key?,nested?,document,error,message_with_context,cursor_at_prev_line,nil_or_empty?,escape,columns,match,chop,end_with?,gsub,!,push_cellspec,cell_open?,close_cell,take_cellspec,squeeze,upto,times,cursor_before_mark,rowspan,activate_rowspan,colspan,end_of_row?,close_row,private,rows,effective_column_visits');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Table');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.attributes = $proto.document = $proto.rows = $proto.has_header_option = $proto.columns = nil;
      
      $const_set($nesting[0], 'DEFAULT_PRECISION', 4);
      (function($base, $super) {
        var self = $klass($base, $super, 'Rows');

        var $proto = self.$$prototype;

        $proto.head = $proto.body = $proto.foot = nil;
        
        self.$attr_accessor("head", "foot", "body");
        
        $def(self, '$initialize', function $$initialize(head, foot, body) {
          var self = this;

          
          if (head == null) head = [];
          if (foot == null) foot = [];
          if (body == null) body = [];
          self.head = head;
          self.foot = foot;
          return (self.body = body);
        }, -1);
        $alias(self, "[]", "send");
        
        $def(self, '$by_section', function $$by_section() {
          var self = this;

          return [["head", self.head], ["body", self.body], ["foot", self.foot]]
        });
        return $def(self, '$to_h', function $$to_h() {
          var self = this;

          return $hash2(["head", "body", "foot"], {"head": self.head, "body": self.body, "foot": self.foot})
        });
      })($nesting[0], null);
      self.$attr_accessor("columns");
      self.$attr_accessor("rows");
      self.$attr_accessor("has_header_option");
      self.$attr_reader("caption");
      
      $def(self, '$initialize', function $$initialize(parent, attributes) {
        var $a; $$initialize.$$p || nil; var self = this, pcwidth = nil, pcwidth_intval = nil, abswidth_val = nil;

        $$initialize.$$p = null;
        
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [parent, "table"], null);
        self.rows = $$('Rows').$new();
        self.columns = [];
        self.has_header_option = false;
        if ($truthy((pcwidth = attributes['$[]']("width")))) {
          if (($truthy($rb_gt((pcwidth_intval = pcwidth.$to_i()), 100)) || ($truthy($rb_lt(pcwidth_intval, 1))))) {
            if (!($eqeq(pcwidth_intval, 0) && (($eqeq(pcwidth, "0") || ($eqeq(pcwidth, "0%")))))) {
              pcwidth_intval = 100;
            }
          }
        } else {
          pcwidth_intval = 100;
        }        self.attributes['$[]=']("tablepcwidth", pcwidth_intval);
        if ($truthy(self.document.$attributes()['$[]']("pagewidth"))) {
          self.attributes['$[]=']("tableabswidth", ($eqeq((abswidth_val = $rb_times($rb_divide(pcwidth_intval, 100), self.document.$attributes()['$[]']("pagewidth").$to_f()).$truncate($$('DEFAULT_PRECISION'))), abswidth_val.$to_i()) ? (abswidth_val.$to_i()) : (abswidth_val)));
        }        if ($truthy(attributes['$[]']("rotate-option"))) {
          return ($a = ["orientation", "landscape"], $send(self.attributes, '[]=', $a), $a[$a.length - 1])
        } else {
          return nil
        }      });
      
      $def(self, '$header_row?', function $Table_header_row$ques$1() {
        var self = this, val = nil;

        if (($truthy((val = self.has_header_option)) && ($truthy(self.rows.$body()['$empty?']())))) {
          return val
        } else {
          return nil
        }
      });
      
      $def(self, '$create_columns', function $$create_columns(colspecs) {
        var self = this, cols = nil, autowidth_cols = nil, width_base = nil, num_cols = nil;

        
        cols = [];
        autowidth_cols = nil;
        width_base = 0;
        $send(colspecs, 'each', [], function $$2(colspec){var self = $$2.$$s == null ? this : $$2.$$s, colwidth = nil, $ret_or_1 = nil;

          
          if (colspec == null) colspec = nil;
          colwidth = colspec['$[]']("width");
          cols['$<<']($$('Column').$new(self, cols.$size(), colspec));
          if ($truthy($rb_lt(colwidth, 0))) {
            return (autowidth_cols = ($truthy(($ret_or_1 = autowidth_cols)) ? ($ret_or_1) : ([])))['$<<'](cols['$[]'](-1))
          } else {
            return (width_base = $rb_plus(width_base, colwidth))
          }}, {$$s: self});
        if ($truthy($rb_gt((num_cols = (self.columns = cols).$size()), 0))) {
          
          self.attributes['$[]=']("colcount", num_cols);
          if (!($truthy($rb_gt(width_base, 0)) || ($truthy(autowidth_cols)))) {
            width_base = nil;
          }          self.$assign_column_widths(width_base, autowidth_cols);
        }        return nil;
      });
      
      $def(self, '$assign_column_widths', function $$assign_column_widths(width_base, autowidth_cols) {
        var self = this, precision = nil, total_width = nil, col_pcwidth = nil, autowidth = nil, autowidth_attrs = nil;

        
        if (width_base == null) width_base = nil;
        if (autowidth_cols == null) autowidth_cols = nil;
        precision = $$('DEFAULT_PRECISION');
        total_width = (col_pcwidth = 0);
        if ($truthy(width_base)) {
          
          if ($truthy(autowidth_cols)) {
            
            if ($truthy($rb_gt(width_base, 100))) {
              
              autowidth = 0;
              self.$logger().$warn("total column width must not exceed 100% when using autowidth columns; got " + (width_base) + "%");
            } else {
              
              autowidth = $rb_divide($rb_minus(100, width_base), autowidth_cols.$size()).$truncate(precision);
              if ($eqeq(autowidth.$to_i(), autowidth)) {
                autowidth = autowidth.$to_i();
              }              width_base = 100;
            }            autowidth_attrs = $hash2(["width", "autowidth-option"], {"width": autowidth, "autowidth-option": ""});
            $send(autowidth_cols, 'each', [], function $$3(col){
              
              if (col == null) col = nil;
              return col.$update_attributes(autowidth_attrs);});
          }          $send(self.columns, 'each', [], function $$4(col){
            
            if (col == null) col = nil;
            return (total_width = $rb_plus(total_width, (col_pcwidth = col.$assign_width(nil, width_base, precision))));});
        } else {
          
          col_pcwidth = $rb_divide(100, self.columns.$size()).$truncate(precision);
          if ($eqeq(col_pcwidth.$to_i(), col_pcwidth)) {
            col_pcwidth = col_pcwidth.$to_i();
          }          $send(self.columns, 'each', [], function $$5(col){
            
            if (col == null) col = nil;
            return (total_width = $rb_plus(total_width, col.$assign_width(col_pcwidth, nil, precision)));});
        }        if (!$eqeq(total_width, 100)) {
          self.columns['$[]'](-1).$assign_width($rb_plus($rb_minus(100, total_width), col_pcwidth).$round(precision), nil, precision);
        }        return nil;
      }, -1);
      return $def(self, '$partition_header_footer', function $$partition_header_footer(attrs) {
        var $a, self = this, num_body_rows = nil, body = nil;

        
        num_body_rows = ($a = ["rowcount", (body = self.rows.$body()).$size()], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);
        if ($truthy($rb_gt(num_body_rows, 0))) {
          if ($truthy(self.has_header_option)) {
            
            self.rows['$head=']([$send(body.$shift(), 'map', [], function $$6(cell){
              
              if (cell == null) cell = nil;
              return cell.$reinitialize(true);})]);
            num_body_rows = $rb_minus(num_body_rows, 1);
          } else if ($truthy(self.has_header_option['$nil?']())) {
            
            self.has_header_option = false;
            body.$unshift($send(body.$shift(), 'map', [], function $$7(cell){
              
              if (cell == null) cell = nil;
              return cell.$reinitialize(false);}));
          }
        }        if (($truthy($rb_gt(num_body_rows, 0)) && ($truthy(attrs['$[]']("footer-option"))))) {
          self.rows['$foot=']([body.$pop()]);
        }        return nil;
      });
    })($nesting[0], $$('AbstractBlock'), $nesting);
    (function($base, $super) {
      var self = $klass($base, $super, 'Column');

      var $proto = self.$$prototype;

      $proto.attributes = nil;
      
      self.$attr_accessor("style");
      
      $def(self, '$initialize', function $$initialize(table, index, attributes) {
        $$initialize.$$p || nil; var self = this;

        $$initialize.$$p = null;
        
        if (attributes == null) attributes = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [table, "table_column"], null);
        self.style = attributes['$[]']("style");
        attributes['$[]=']("colnumber", $rb_plus(index, 1));
        if ($truthy((attributes['$[]']("width")))) ; else {
          attributes['$[]=']("width", 1);
        }        if ($truthy((attributes['$[]']("halign")))) ; else {
          attributes['$[]=']("halign", "left");
        }        if ($truthy((attributes['$[]']("valign")))) ; else {
          attributes['$[]=']("valign", "top");
        }        return self.$update_attributes(attributes);
      }, -3);
      $alias(self, "table", "parent");
      
      $def(self, '$assign_width', function $$assign_width(col_pcwidth, width_base, precision) {
        var $a, self = this, col_abswidth = nil;

        
        if ($truthy(width_base)) {
          
          col_pcwidth = $rb_divide($rb_times(self.attributes['$[]']("width").$to_f(), 100), width_base).$truncate(precision);
          if ($eqeq(col_pcwidth.$to_i(), col_pcwidth)) {
            col_pcwidth = col_pcwidth.$to_i();
          }        }        if ($truthy(self.$parent().$attributes()['$[]']("tableabswidth"))) {
          self.attributes['$[]=']("colabswidth", ($eqeq((col_abswidth = $rb_times($rb_divide(col_pcwidth, 100), self.$parent().$attributes()['$[]']("tableabswidth")).$truncate(precision)), col_abswidth.$to_i()) ? (col_abswidth.$to_i()) : (col_abswidth)));
        }        return ($a = ["colpcwidth", col_pcwidth], $send(self.attributes, '[]=', $a), $a[$a.length - 1]);
      });
      
      $def(self, '$block?', $return_val(false));
      return $def(self, '$inline?', $return_val(false));
    })($$('Table'), $$('AbstractNode'));
    (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Cell');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.document = $proto.reinitialize_args = $proto.attributes = $proto.cursor = $proto.text = $proto.subs = $proto.style = $proto.inner_document = $proto.source_location = $proto.colspan = $proto.rowspan = nil;
      
      $const_set($nesting[0], 'DOUBLE_LF', $rb_times($$('LF'), 2));
      self.$attr_accessor("colspan");
      self.$attr_accessor("rowspan");
      $alias(self, "column", "parent");
      self.$attr_reader("inner_document");
      
      $def(self, '$initialize', function $$initialize(column, cell_text, attributes, opts) {
        var $a; $$initialize.$$p || nil; var self = this, in_header_row = nil, cell_style = nil, $ret_or_1 = nil, $ret_or_2 = nil, asciidoc = nil, inner_document_cursor = nil, lines_advanced = nil, literal = nil, normal_psv = nil, parent_doctitle = nil, inner_document_lines = nil, unprocessed_line1 = nil, preprocessed_lines = nil;

        $$initialize.$$p = null;
        
        if (attributes == null) attributes = $hash2([], {});
        if (opts == null) opts = $hash2([], {});
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [column, "table_cell"], null);
        self.cursor = (self.reinitialize_args = nil);
        if ($truthy(self.document.$sourcemap())) {
          self.source_location = opts['$[]']("cursor").$dup();
        }        if ($truthy(column)) {
          
          if ($truthy((in_header_row = column.$table()['$header_row?']()))) {
            if (($eqeq(in_header_row, "implicit") && ($truthy((cell_style = ($truthy(($ret_or_1 = column.$style())) ? ($ret_or_1) : (($truthy(($ret_or_2 = attributes)) ? (attributes['$[]']("style")) : ($ret_or_2))))))))) {
              
              if (($eqeq(cell_style, "asciidoc") || ($eqeq(cell_style, "literal")))) {
                self.reinitialize_args = [column, cell_text, ($truthy(($ret_or_1 = attributes)) ? (attributes.$merge()) : ($ret_or_1)), opts];
              }              cell_style = nil;
            }
          } else {
            cell_style = column.$style();
          }          self.$update_attributes(column.$attributes());
        }        if ($truthy(attributes)) {
          
          if ($truthy(attributes['$empty?']())) {
            self.colspan = (self.rowspan = nil);
          } else {
            
            $a = [attributes.$delete("colspan"), attributes.$delete("rowspan")], (self.colspan = $a[0]), (self.rowspan = $a[1]);
            if (!$truthy(in_header_row)) {
              cell_style = ($truthy(($ret_or_1 = attributes['$[]']("style"))) ? ($ret_or_1) : (cell_style));
            }            self.$update_attributes(attributes);
          }          
          switch (cell_style) {
            case "asciidoc":
              
              asciidoc = true;
              inner_document_cursor = opts['$[]']("cursor");
              if ($truthy((cell_text = cell_text.$rstrip())['$start_with?']($$('LF')))) {
                
                lines_advanced = 1;
                while ($truthy((cell_text = cell_text.$slice(1, cell_text.$length()))['$start_with?']($$('LF')))) {
                lines_advanced = $rb_plus(lines_advanced, 1);
                }                inner_document_cursor.$advance(lines_advanced);
              } else {
                cell_text = cell_text.$lstrip();
              }              break;
            case "literal":
              
              literal = true;
              cell_text = cell_text.$rstrip();
              while ($truthy(cell_text['$start_with?']($$('LF')))) {
              cell_text = cell_text.$slice(1, cell_text.$length());
              }              break;
            default:
              
              normal_psv = true;
              cell_text = ($truthy(cell_text) ? (cell_text.$strip()) : (""));
          }        } else {
          
          self.colspan = (self.rowspan = nil);
          if ($eqeq(cell_style, "asciidoc")) {
            
            asciidoc = true;
            inner_document_cursor = opts['$[]']("cursor");
          }        }        if ($truthy(asciidoc)) {
          
          parent_doctitle = self.document.$attributes().$delete("doctitle");
          inner_document_lines = cell_text.$split($$('LF'), -1);
          if (!$truthy(inner_document_lines['$empty?']())) {
            if ($truthy((unprocessed_line1 = inner_document_lines['$[]'](0))['$include?']("::"))) {
              
              preprocessed_lines = $$('PreprocessorReader').$new(self.document, [unprocessed_line1]).$readlines();
              if (!($eqeq(unprocessed_line1, preprocessed_lines['$[]'](0)) && ($truthy($rb_lt(preprocessed_lines.$size(), 2))))) {
                
                inner_document_lines.$shift();
                if (!$truthy(preprocessed_lines['$empty?']())) {
                  $send(inner_document_lines, 'unshift', $to_a(preprocessed_lines));
                }              }            }
          }          self.inner_document = $$('Document').$new(inner_document_lines, $hash2(["standalone", "parent", "cursor"], {"standalone": false, "parent": self.document, "cursor": inner_document_cursor}));
          if (!$truthy(parent_doctitle['$nil?']())) {
            self.document.$attributes()['$[]=']("doctitle", parent_doctitle);
          }          self.subs = nil;
        } else if ($truthy(literal)) {
          
          self.content_model = "verbatim";
          self.subs = $$('BASIC_SUBS');
        } else {
          
          if ($truthy(normal_psv)) {
            if ($truthy(in_header_row)) {
              self.cursor = opts['$[]']("cursor");
            } else {
              self.$catalog_inline_anchor(cell_text, opts['$[]']("cursor"));
            }
          }          self.content_model = "simple";
          self.subs = $$('NORMAL_SUBS');
        }        self.text = cell_text;
        return (self.style = cell_style);
      }, -3);
      
      $def(self, '$reinitialize', function $$reinitialize(has_header) {
        var self = this;

        
        if ($truthy(has_header)) {
          self.reinitialize_args = nil;
        } else if ($truthy(self.reinitialize_args)) {
          return $send($$$($$('Table'), 'Cell'), 'new', $to_a(self.reinitialize_args))
        } else {
          self.style = self.attributes['$[]']("style");
        }        if ($truthy(self.cursor)) {
          self.$catalog_inline_anchor();
        }        return self;
      });
      
      $def(self, '$catalog_inline_anchor', function $$catalog_inline_anchor(cell_text, cursor) {
        var $a, self = this;

        
        if (cell_text == null) cell_text = self.text;
        if (cursor == null) cursor = nil;
        if (!$truthy(cursor)) {
          $a = [self.cursor, nil], (cursor = $a[0]), (self.cursor = $a[1]);
        }        if (($truthy(cell_text['$start_with?']("[[")) && ($truthy($$('LeadingInlineAnchorRx')['$=~'](cell_text))))) {
          return $$('Parser').$catalog_inline_anchor((($a = $gvars['~']) === nil ? nil : $a['$[]'](1)), (($a = $gvars['~']) === nil ? nil : $a['$[]'](2)), self, cursor, self.document)
        } else {
          return nil
        }      }, -1);
      
      $def(self, '$text', function $$text() {
        var self = this;

        return self.$apply_subs(self.text, self.subs)
      });
      self.$attr_writer("text");
      
      $def(self, '$content', function $$content() {
        var self = this, cell_style = nil, subbed_text = nil;

        if ($eqeq((cell_style = self.style), "asciidoc")) {
          return self.inner_document.$convert()
        } else if ($truthy(self.text['$include?']($$('DOUBLE_LF')))) {
          return $send(self.$text().$split($$('BlankLineRx')), 'map', [], function $$8(para){var self = $$8.$$s == null ? this : $$8.$$s;

            
            if (para == null) para = nil;
            if (($truthy(cell_style) && ($neqeq(cell_style, "header")))) {
              return $$('Inline').$new(self.$parent(), "quoted", para, $hash2(["type"], {"type": cell_style})).$convert()
            } else {
              return para
            }}, {$$s: self})
        } else if ($truthy((subbed_text = self.$text())['$empty?']())) {
          return []
        } else if (($truthy(cell_style) && ($neqeq(cell_style, "header")))) {
          return [$$('Inline').$new(self.$parent(), "quoted", subbed_text, $hash2(["type"], {"type": cell_style})).$convert()]
        } else {
          return [subbed_text]
        }
      });
      
      $def(self, '$lines', function $$lines() {
        var self = this;

        return self.text.$split($$('LF'))
      });
      
      $def(self, '$source', $return_ivar("text"));
      
      $def(self, '$file', function $$file() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_location))) {
          return self.source_location.$file()
        } else {
          return $ret_or_1
        }
      });
      
      $def(self, '$lineno', function $$lineno() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.source_location))) {
          return self.source_location.$lineno()
        } else {
          return $ret_or_1
        }
      });
      return $def(self, '$to_s', function $$to_s() {
        var $yield = $$to_s.$$p || nil, self = this, $ret_or_1 = nil;

        $$to_s.$$p = null;
        return "" + ($send2(self, $find_super(self, 'to_s', $$to_s, false, true), 'to_s', [], $yield)) + " - [text: " + (self.text) + ", colspan: " + (($truthy(($ret_or_1 = self.colspan)) ? ($ret_or_1) : (1))) + ", rowspan: " + (($truthy(($ret_or_1 = self.rowspan)) ? ($ret_or_1) : (1))) + ", attributes: " + (self.attributes) + "]"
      });
    })($$('Table'), $$('AbstractBlock'), $nesting);
    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'ParserContext');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.delimiter = $proto.delimiter_rx = $proto.buffer = $proto.cellspecs = $proto.cell_open = $proto.format = $proto.start_cursor_data = $proto.reader = $proto.table = $proto.current_row = $proto.colcount = $proto.column_visits = $proto.active_rowspans = $proto.linenum = nil;
      
      self.$include($$('Logging'));
      $const_set($nesting[0], 'FORMATS', ["psv", "csv", "dsv", "tsv"].$to_set());
      $const_set($nesting[0], 'DELIMITERS', $hash2(["psv", "csv", "dsv", "tsv", "!sv"], {"psv": ["|", /\|/], "csv": [",", /,/], "dsv": [":", /:/], "tsv": ["\t", /\t/], "!sv": ["!", /!/]}));
      self.$attr_accessor("table");
      self.$attr_accessor("format");
      self.$attr_reader("colcount");
      self.$attr_accessor("buffer");
      self.$attr_reader("delimiter");
      self.$attr_reader("delimiter_re");
      
      $def(self, '$initialize', function $$initialize(reader, table, attributes) {
        var $a, $b, self = this, xsv = nil, sep = nil;

        
        if (attributes == null) attributes = $hash2([], {});
        self.start_cursor_data = (self.reader = reader).$mark();
        self.table = table;
        if ($truthy(attributes['$key?']("format"))) {
          if ($truthy($$('FORMATS')['$include?']((xsv = attributes['$[]']("format"))))) {
            if ($eqeq(xsv, "tsv")) {
              self.format = "csv";
            } else if (($eqeq((self.format = xsv), "psv") && ($truthy(table.$document()['$nested?']())))) {
              xsv = "!sv";
            }
          } else {
            
            self.$logger().$error(self.$message_with_context("illegal table format: " + (xsv), $hash2(["source_location"], {"source_location": reader.$cursor_at_prev_line()})));
            $a = ["psv", ($truthy(table.$document()['$nested?']()) ? ("!sv") : ("psv"))], (self.format = $a[0]), (xsv = $a[1]);
          }
        } else {
          $a = ["psv", ($truthy(table.$document()['$nested?']()) ? ("!sv") : ("psv"))], (self.format = $a[0]), (xsv = $a[1]);
        }        if ($truthy(attributes['$key?']("separator"))) {
          if ($truthy((sep = attributes['$[]']("separator"))['$nil_or_empty?']())) {
            $b = $$('DELIMITERS')['$[]'](xsv), $a = $to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1]));
          } else if ($eqeq(sep, "\\t")) {
            $b = $$('DELIMITERS')['$[]']("tsv"), $a = $to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1]));
          } else {
            $a = [sep, $regexp([$$$('Regexp').$escape(sep)])], (self.delimiter = $a[0]), (self.delimiter_rx = $a[1]);
          }
        } else {
          $b = $$('DELIMITERS')['$[]'](xsv), $a = $to_ary($b), (self.delimiter = ($a[0] == null ? nil : $a[0])), (self.delimiter_rx = ($a[1] == null ? nil : $a[1]));
        }        self.colcount = ($truthy(table.$columns()['$empty?']()) ? (-1) : (table.$columns().$size()));
        self.buffer = "";
        self.cellspecs = [];
        self.cell_open = false;
        self.active_rowspans = [0];
        self.column_visits = 0;
        self.current_row = [];
        return (self.linenum = -1);
      }, -3);
      
      $def(self, '$starts_with_delimiter?', function $ParserContext_starts_with_delimiter$ques$9(line) {
        var self = this;

        return line['$start_with?'](self.delimiter)
      });
      
      $def(self, '$match_delimiter', function $$match_delimiter(line) {
        var self = this;

        return self.delimiter_rx.$match(line)
      });
      
      $def(self, '$skip_past_delimiter', function $$skip_past_delimiter(pre) {
        var self = this;

        
        self.buffer = "" + (self.buffer) + (pre) + (self.delimiter);
        return nil;
      });
      
      $def(self, '$skip_past_escaped_delimiter', function $$skip_past_escaped_delimiter(pre) {
        var self = this;

        
        self.buffer = "" + (self.buffer) + (pre.$chop()) + (self.delimiter);
        return nil;
      });
      
      $def(self, '$buffer_has_unclosed_quotes?', function $ParserContext_buffer_has_unclosed_quotes$ques$10(append, q) {
        var self = this, record = nil, qq = nil, trailing_quote = nil, $ret_or_1 = nil;

        
        if (append == null) append = nil;
        if (q == null) q = "\"";
        if ($eqeq((record = ($truthy(append) ? ($rb_plus(self.buffer, append).$strip()) : (self.buffer.$strip()))), q)) {
          return true
        } else if ($truthy(record['$start_with?'](q))) {
          
          qq = $rb_plus(q, q);
          if ((($truthy((trailing_quote = record['$end_with?'](q))) && ($truthy(record['$end_with?'](qq)))) || ($truthy(record['$start_with?'](qq))))) {
            if ($truthy(($ret_or_1 = (record = record.$gsub(qq, ""))['$start_with?'](q)))) {
              return record['$end_with?'](q)['$!']()
            } else {
              return $ret_or_1
            }
          } else {
            return trailing_quote['$!']()
          }        } else {
          return false
        }      }, -1);
      
      $def(self, '$take_cellspec', function $$take_cellspec() {
        var self = this;

        return self.cellspecs.$shift()
      });
      
      $def(self, '$push_cellspec', function $$push_cellspec(cellspec) {
        var self = this, $ret_or_1 = nil;

        
        if (cellspec == null) cellspec = $hash2([], {});
        self.cellspecs['$<<'](($truthy(($ret_or_1 = cellspec)) ? ($ret_or_1) : ($hash2([], {}))));
        return nil;
      }, -1);
      
      $def(self, '$keep_cell_open', function $$keep_cell_open() {
        var self = this;

        
        self.cell_open = true;
        return nil;
      });
      
      $def(self, '$mark_cell_closed', function $$mark_cell_closed() {
        var self = this;

        
        self.cell_open = false;
        return nil;
      });
      
      $def(self, '$cell_open?', $return_ivar("cell_open"));
      
      $def(self, '$cell_closed?', function $ParserContext_cell_closed$ques$11() {
        var self = this;

        return self.cell_open['$!']()
      });
      
      $def(self, '$close_open_cell', function $$close_open_cell(next_cellspec) {
        var self = this;

        
        if (next_cellspec == null) next_cellspec = $hash2([], {});
        self.$push_cellspec(next_cellspec);
        if ($truthy(self['$cell_open?']())) {
          self.$close_cell(true);
        }        self.$advance();
        return nil;
      }, -1);
      
      $def(self, '$close_cell', function $$close_cell(eol) {try { var $t_return = $thrower('return'); 
        var self = this, cell_text = nil, cellspec = nil, repeat = nil, $ret_or_1 = nil, q = nil;

        
        if (eol == null) eol = false;
        if ($eqeq(self.format, "psv")) {
          
          cell_text = self.buffer;
          self.buffer = "";
          if ($truthy((cellspec = self.$take_cellspec()))) {
            repeat = ($truthy(($ret_or_1 = cellspec.$delete("repeatcol"))) ? ($ret_or_1) : (1));
          } else {
            
            self.$logger().$error(self.$message_with_context("table missing leading separator; recovering automatically", $hash2(["source_location"], {"source_location": $send($$$($$('Reader'), 'Cursor'), 'new', $to_a(self.start_cursor_data))})));
            cellspec = $hash2([], {});
            repeat = 1;
          };
        } else {
          
          cell_text = self.buffer.$strip();
          self.buffer = "";
          cellspec = nil;
          repeat = 1;
          if ((($eqeq(self.format, "csv") && ($not(cell_text['$empty?']()))) && ($truthy(cell_text['$include?']((q = "\"")))))) {
            if (($truthy(cell_text['$start_with?'](q)) && ($truthy(cell_text['$end_with?'](q))))) {
              if ($truthy((cell_text = cell_text.$slice(1, $rb_minus(cell_text.$length(), 2))))) {
                cell_text = cell_text.$strip().$squeeze(q);
              } else {
                
                self.$logger().$error(self.$message_with_context("unclosed quote in CSV data; setting cell to empty", $hash2(["source_location"], {"source_location": self.reader.$cursor_at_prev_line()})));
                cell_text = "";
              }
            } else {
              cell_text = cell_text.$squeeze(q);
            }
          };
        };
        $send((1), 'upto', [repeat], function $$12(i){var self = $$12.$$s == null ? this : $$12.$$s, column = nil, extra_cols = nil, offset = nil, cell = nil;
          if (self.colcount == null) self.colcount = nil;
          if (self.table == null) self.table = nil;
          if (self.current_row == null) self.current_row = nil;
          if (self.reader == null) self.reader = nil;
          if (self.column_visits == null) self.column_visits = nil;
          if (self.linenum == null) self.linenum = nil;

          
          if (i == null) i = nil;
          if ($eqeq(self.colcount, -1)) {
            
            self.table.$columns()['$<<']((column = $$$($$('Table'), 'Column').$new(self.table, $rb_minus($rb_plus(self.table.$columns().$size(), i), 1))));
            if ((($truthy(cellspec) && ($truthy(cellspec['$key?']("colspan")))) && ($truthy($rb_gt((extra_cols = $rb_minus(cellspec['$[]']("colspan").$to_i(), 1)), 0))))) {
              
              offset = self.table.$columns().$size();
              $send(extra_cols, 'times', [], function $$13(j){var self = $$13.$$s == null ? this : $$13.$$s;
                if (self.table == null) self.table = nil;

                
                if (j == null) j = nil;
                return self.table.$columns()['$<<']($$$($$('Table'), 'Column').$new(self.table, $rb_plus(offset, j)));}, {$$s: self});
            };
          } else if (!$truthy((column = self.table.$columns()['$[]'](self.current_row.$size())))) {
            
            self.$logger().$error(self.$message_with_context("dropping cell because it exceeds specified number of columns", $hash2(["source_location"], {"source_location": self.reader.$cursor_before_mark()})));
            $t_return.$throw();
          };
          cell = $$$($$('Table'), 'Cell').$new(column, cell_text, cellspec, $hash2(["cursor"], {"cursor": self.reader.$cursor_before_mark()}));
          self.reader.$mark();
          if (!($not(cell.$rowspan()) || ($eqeq(cell.$rowspan(), 1)))) {
            self.$activate_rowspan(cell.$rowspan(), ($truthy(($ret_or_1 = cell.$colspan())) ? ($ret_or_1) : (1)));
          };
          self.column_visits = $rb_plus(self.column_visits, ($truthy(($ret_or_1 = cell.$colspan())) ? ($ret_or_1) : (1)));
          self.current_row['$<<'](cell);
          if (($truthy(self['$end_of_row?']()) && ((($neqeq(self.colcount, -1) || ($truthy($rb_gt(self.linenum, 0)))) || (($truthy(eol) && ($eqeq(i, repeat)))))))) {
            return self.$close_row()
          } else {
            return nil
          };}, {$$s: self, $$ret: $t_return});
        self.cell_open = false;
        return nil;} catch($e) {
          if ($e === $t_return) return $e.$v;
          throw $e;
        }
      }, -1);
      self.$private();
      
      $def(self, '$close_row', function $$close_row() {
        var self = this;

        
        self.table.$rows().$body()['$<<'](self.current_row);
        if ($eqeq(self.colcount, -1)) {
          self.colcount = self.column_visits;
        }        self.column_visits = 0;
        self.current_row = [];
        self.active_rowspans.$shift();
        if ($truthy((self.active_rowspans['$[]'](0)))) ; else {
          self.active_rowspans['$[]='](0, 0);
        }        return nil;
      });
      
      $def(self, '$activate_rowspan', function $$activate_rowspan(rowspan, colspan) {
        var self = this;

        
        $send((1), 'upto', [$rb_minus(rowspan, 1)], function $$14(i){var $a, self = $$14.$$s == null ? this : $$14.$$s, $ret_or_1 = nil;
          if (self.active_rowspans == null) self.active_rowspans = nil;

          
          if (i == null) i = nil;
          return ($a = [i, $rb_plus(($truthy(($ret_or_1 = self.active_rowspans['$[]'](i))) ? ($ret_or_1) : (0)), colspan)], $send(self.active_rowspans, '[]=', $a), $a[$a.length - 1]);}, {$$s: self});
        return nil;
      });
      
      $def(self, '$end_of_row?', function $ParserContext_end_of_row$ques$15() {
        var self = this, $ret_or_1 = nil;

        if ($truthy(($ret_or_1 = self.colcount['$=='](-1)))) {
          return $ret_or_1
        } else {
          return self.$effective_column_visits()['$=='](self.colcount)
        }
      });
      
      $def(self, '$effective_column_visits', function $$effective_column_visits() {
        var self = this;

        return $rb_plus(self.column_visits, self.active_rowspans['$[]'](0))
      });
      return $def(self, '$advance', function $$advance() {
        var self = this;

        return (self.linenum = $rb_plus(self.linenum, 1))
      });
    })($$('Table'), null, $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/writer"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $rb_plus = Opal.rb_plus, $hash2 = Opal.hash2, $def = Opal.def, $return_val = Opal.return_val, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('respond_to?,write,+,chomp,include');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    
    (function($base, $parent_nesting) {
      var self = $module($base, 'Writer');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      return $def(self, '$write', function $$write(output, target) {
        
        
        if ($truthy(target['$respond_to?']("write"))) {
          target.$write($rb_plus(output.$chomp(), $$('LF')));
        } else {
          $$$('File').$write(target, output, $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
        }        return nil;
      })
    })($nesting[0], $nesting);
    return (function($base, $parent_nesting) {
      var self = $module($base, 'VoidWriter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$include($$('Writer'));
      return $def(self, '$write', $return_val(nil));
    })($nesting[0], $nesting);
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/load"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $hash2 = Opal.hash2, $truthy = Opal.truthy, $neqeq = Opal.neqeq, $not = Opal.not, $eqeqeq = Opal.eqeqeq, $send = Opal.send, $to_ary = Opal.to_ary, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('merge,[],start,!=,logger,key?,logger=,new,!,===,dup,tap,each,partition,[]=,split,gsub,+,respond_to?,keys,raise,join,ancestors,class,==,at,to_i,mtime,absolute_path,path,dirname,basename,extname,read,rewind,drop,record,parse,exception,message,set_backtrace,backtrace,stack_trace=,stack_trace,open,load');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$load', function $$load(input, options) {
        var $a, $b, $c, $d, self = this, timings = nil, logger = nil, $ret_or_1 = nil, attrs = nil, input_path = nil, source = nil, doc = nil, e = nil, context = nil, wrapped_e = nil;

        
        if (options == null) options = $hash2([], {});
        try {
          
          options = options.$merge();
          if ($truthy((timings = options['$[]']("timings")))) {
            timings.$start("read");
          };
          if (($truthy(options['$key?']("logger")) && ($neqeq((logger = options['$[]']("logger")), $$('LoggerManager').$logger())))) {
            $$('LoggerManager')['$logger='](($truthy(($ret_or_1 = logger)) ? ($ret_or_1) : ($$('NullLogger').$new())));
          };
          if ($not((attrs = options['$[]']("attributes")))) {
            attrs = $hash2([], {});
          } else if ($eqeqeq($$$('Hash'), attrs)) {
            attrs = attrs.$merge();
          } else if (($truthy((($c = $$$('::', 'Java', 'skip_raise')) && ($b = $$$($c, 'JavaUtil', 'skip_raise')) && ($a = $$$($b, 'Map', 'skip_raise')) ? 'constant' : nil)) && ($eqeqeq($$$($$$($$$('Java'), 'JavaUtil'), 'Map'), attrs)))) {
            attrs = attrs.$dup();
          } else if ($eqeqeq($$$('Array'), attrs)) {
            attrs = $send($hash2([], {}), 'tap', [], function $$1(accum){
              
              if (accum == null) accum = nil;
              return $send(attrs, 'each', [], function $$2(entry){var $d, $e, k = nil, _ = nil, v = nil;

                
                if (entry == null) entry = nil;
                $e = entry.$partition("="), $d = $to_ary($e), (k = ($d[0] == null ? nil : $d[0])), (_ = ($d[1] == null ? nil : $d[1])), (v = ($d[2] == null ? nil : $d[2])), $e;
                return ($d = [k, v], $send(accum, '[]=', $d), $d[$d.length - 1]);});});
          } else if ($eqeqeq($$$('String'), attrs)) {
            attrs = $send($hash2([], {}), 'tap', [], function $$3(accum){
              
              if (accum == null) accum = nil;
              return $send(attrs.$gsub($$('SpaceDelimiterRx'), $rb_plus("\\1", $$('NULL'))).$gsub($$('EscapedSpaceRx'), "\\1").$split($$('NULL')), 'each', [], function $$4(entry){var $d, $e, k = nil, _ = nil, v = nil;

                
                if (entry == null) entry = nil;
                $e = entry.$partition("="), $d = $to_ary($e), (k = ($d[0] == null ? nil : $d[0])), (_ = ($d[1] == null ? nil : $d[1])), (v = ($d[2] == null ? nil : $d[2])), $e;
                return ($d = [k, v], $send(accum, '[]=', $d), $d[$d.length - 1]);});});
          } else if (($truthy(attrs['$respond_to?']("keys")) && ($truthy(attrs['$respond_to?']("[]"))))) {
            attrs = $send($hash2([], {}), 'tap', [], function $$5(accum){
              
              if (accum == null) accum = nil;
              return $send(attrs.$keys(), 'each', [], function $$6(k){var $d;

                
                if (k == null) k = nil;
                return ($d = [k, attrs['$[]'](k)], $send(accum, '[]=', $d), $d[$d.length - 1]);});});
          } else {
            self.$raise($$$('ArgumentError'), "illegal type for attributes option: " + (attrs.$class().$ancestors().$join(" < ")));
          };
          if ($eqeqeq($$$('File'), input)) {
            
            options['$[]=']("input_mtime", ($eqeq($$('RUBY_ENGINE'), "jruby") ? ($$$('Time').$at(input.$mtime().$to_i())) : (input.$mtime())));
            attrs['$[]=']("docfile", (input_path = $$$('File').$absolute_path(input.$path())));
            attrs['$[]=']("docdir", $$$('File').$dirname(input_path));
            attrs['$[]=']("docname", $$('Helpers').$basename(input_path, ($d = ["docfilesuffix", $$('Helpers').$extname(input_path)], $send(attrs, '[]=', $d), $d[$d.length - 1])));
            source = input.$read();
          } else if ($truthy(input['$respond_to?']("read"))) {
            
            try {
              input.$rewind();
            } catch ($err) {
              if (Opal.rescue($err, [$$('StandardError')])) {
                try {
                  nil;
                } finally { Opal.pop_exception(); }
              } else { throw $err; }
            };
            source = input.$read();
          } else if ($eqeqeq($$$('String'), input)) {
            source = input;
          } else if ($eqeqeq($$$('Array'), input)) {
            source = input.$drop(0);
          } else if ($truthy(input)) {
            self.$raise($$$('ArgumentError'), "unsupported input type: " + (input.$class()));
          };
          if ($truthy(timings)) {
            
            timings.$record("read");
            timings.$start("parse");
          };
          options['$[]=']("attributes", attrs);
          doc = ($eqeq(options['$[]']("parse"), false) ? ($$('Document').$new(source, options)) : ($$('Document').$new(source, options).$parse()));
          if ($truthy(timings)) {
            timings.$record("parse");
          };
          return doc;
        } catch ($err) {
          if (Opal.rescue($err, [$$('StandardError')])) {(e = $err);
            try {
              
              
              try {
                
                context = "asciidoctor: FAILED: " + (($truthy(($ret_or_1 = attrs['$[]']("docfile"))) ? ($ret_or_1) : ("<stdin>"))) + ": Failed to load AsciiDoc document";
                if ($truthy(e['$respond_to?']("exception"))) {
                  
                  wrapped_e = e.$exception("" + (context) + " - " + (e.$message()));
                  wrapped_e.$set_backtrace(e.$backtrace());
                } else {
                  
                  wrapped_e = e.$class().$new(context, e);
                  wrapped_e['$stack_trace='](e.$stack_trace());
                };
              } catch ($err) {
                if (Opal.rescue($err, [$$('StandardError')])) {
                  try {
                    wrapped_e = e;
                  } finally { Opal.pop_exception(); }
                } else { throw $err; }
              };;
              return self.$raise(wrapped_e);
            } finally { Opal.pop_exception(); }
          } else { throw $err; }
        }      }, -2);
      return $def(self, '$load_file', function $$load_file(filename, options) {
        var self = this;

        
        if (options == null) options = $hash2([], {});
        return $send($$$('File'), 'open', [filename, $$('FILE_READ_MODE')], function $$7(file){var self = $$7.$$s == null ? this : $$7.$$s;

          
          if (file == null) file = nil;
          return self.$load(file, options);}, {$$s: self});
      }, -2);
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/convert"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $hash2 = Opal.hash2, $eqeqeq = Opal.eqeqeq, $truthy = Opal.truthy, $eqeq = Opal.eqeq, $rb_ge = Opal.rb_ge, $not = Opal.not, $rb_lt = Opal.rb_lt, $neqeq = Opal.neqeq, $def = Opal.def, $send = Opal.send, $alias = Opal.alias, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('delete,merge,===,absolute_path,path,load,respond_to?,[]=,key?,fetch,[],dirname,expand_path,join,attributes,outfilesuffix,==,raise,pwd,>=,safe,normalize_system_path,mkdir_p,directory?,!,convert,write,attr,uriish?,basebackend?,attr?,<,include?,syntax_highlighter,write_stylesheet?,write_primary_stylesheet,instance,to_s,read_asset,file?,!=,write_stylesheet,open,convert_file');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function(self, $parent_nesting) {
      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      
      $def(self, '$convert', function $$convert(input, options) {
        var self = this, to_dir = nil, mkdirs = nil, $ret_or_1 = nil, to_file = nil, write_to_target = nil, sibling_path = nil, stream_output = nil, outdir = nil, doc = nil, outfile = nil, working_dir = nil, jail = nil, output = nil, stylesdir = nil, stylesheet = nil, copy_asciidoctor_stylesheet = nil, copy_user_stylesheet = nil, copy_syntax_hl_stylesheet = nil, syntax_hl = nil, stylesoutdir = nil, stylesheet_src = nil, stylesheet_dest = nil, stylesheet_data = nil, stylesheet_outdir = nil;

        
        if (options == null) options = $hash2([], {});
        (options = options.$merge()).$delete("parse");
        to_dir = options.$delete("to_dir");
        mkdirs = options.$delete("mkdirs");
        if (($eqeqeq(true, ($ret_or_1 = (to_file = options.$delete("to_file")))) || ($eqeqeq(nil, $ret_or_1)))) {
          
          if (!$truthy((write_to_target = to_dir))) {
            if ($eqeqeq($$$('File'), input)) {
              sibling_path = $$$('File').$absolute_path(input.$path());
            }
          }          to_file = nil;
        } else if ($eqeqeq(false, $ret_or_1)) {
          to_file = nil;
        } else if ($eqeqeq("/dev/null", $ret_or_1)) {
          return self.$load(input, options)
        } else if (!$truthy((stream_output = to_file['$respond_to?']("write")))) {
          options['$[]=']("to_file", (write_to_target = to_file));
        }        if (!$truthy(options['$key?']("standalone"))) {
          if (($truthy(sibling_path) || ($truthy(write_to_target)))) {
            options['$[]=']("standalone", options.$fetch("header_footer", true));
          } else if ($truthy(options['$key?']("header_footer"))) {
            options['$[]=']("standalone", options['$[]']("header_footer"));
          }
        }        if ($truthy(sibling_path)) {
          options['$[]=']("to_dir", (outdir = $$$('File').$dirname(sibling_path)));
        } else if ($truthy(write_to_target)) {
          if ($truthy(to_dir)) {
            if ($truthy(to_file)) {
              options['$[]=']("to_dir", $$$('File').$dirname($$$('File').$expand_path(to_file, to_dir)));
            } else {
              options['$[]=']("to_dir", $$$('File').$expand_path(to_dir));
            }
          } else if ($truthy(to_file)) {
            options['$[]=']("to_dir", $$$('File').$dirname($$$('File').$expand_path(to_file)));
          }
        }        doc = self.$load(input, options);
        if ($truthy(sibling_path)) {
          
          outfile = $$$('File').$join(outdir, "" + (doc.$attributes()['$[]']("docname")) + (doc.$outfilesuffix()));
          if ($eqeq(outfile, sibling_path)) {
            self.$raise($$$('IOError'), "input file and output file cannot be the same: " + (outfile));
          }        } else if ($truthy(write_to_target)) {
          
          working_dir = ($truthy(options['$key?']("base_dir")) ? ($$$('File').$expand_path(options['$[]']("base_dir"))) : ($$$('Dir').$pwd()));
          jail = ($truthy($rb_ge(doc.$safe(), $$$($$('SafeMode'), 'SAFE'))) ? (working_dir) : (nil));
          if ($truthy(to_dir)) {
            
            outdir = doc.$normalize_system_path(to_dir, working_dir, jail, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
            if ($truthy(to_file)) {
              
              outfile = doc.$normalize_system_path(to_file, outdir, nil, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
              outdir = $$$('File').$dirname(outfile);
            } else {
              outfile = $$$('File').$join(outdir, "" + (doc.$attributes()['$[]']("docname")) + (doc.$outfilesuffix()));
            }          } else if ($truthy(to_file)) {
            
            outfile = doc.$normalize_system_path(to_file, working_dir, jail, $hash2(["target_name", "recover"], {"target_name": "to_dir", "recover": false}));
            outdir = $$$('File').$dirname(outfile);
          }          if (($eqeqeq($$$('File'), input) && ($eqeq(outfile, $$$('File').$absolute_path(input.$path()))))) {
            self.$raise($$$('IOError'), "input file and output file cannot be the same: " + (outfile));
          }          if ($truthy(mkdirs)) {
            $$('Helpers').$mkdir_p(outdir);
          } else if (!$truthy($$$('File')['$directory?'](outdir))) {
            self.$raise($$$('IOError'), "target directory does not exist: " + (to_dir) + " (hint: set :mkdirs option)");
          }        } else {
          
          outfile = to_file;
          outdir = nil;
        }        if (($truthy(outfile) && ($not(stream_output)))) {
          output = doc.$convert($hash2(["outfile", "outdir"], {"outfile": outfile, "outdir": outdir}));
        } else {
          output = doc.$convert();
        }        if ($truthy(outfile)) {
          
          doc.$write(output, outfile);
          if (((((($not(stream_output) && ($truthy($rb_lt(doc.$safe(), $$$($$('SafeMode'), 'SECURE'))))) && ($truthy(doc['$attr?']("linkcss")))) && ($truthy(doc['$attr?']("copycss")))) && ($truthy(doc['$basebackend?']("html")))) && ($not(($truthy(($ret_or_1 = (stylesdir = doc.$attr("stylesdir")))) ? ($$('Helpers')['$uriish?'](stylesdir)) : ($ret_or_1)))))) {
            
            if ($truthy((stylesheet = doc.$attr("stylesheet")))) {
              if ($truthy($$('DEFAULT_STYLESHEET_KEYS')['$include?'](stylesheet))) {
                copy_asciidoctor_stylesheet = true;
              } else if ($not($$('Helpers')['$uriish?'](stylesheet))) {
                copy_user_stylesheet = true;
              }
            }            copy_syntax_hl_stylesheet = ($truthy(($ret_or_1 = (syntax_hl = doc.$syntax_highlighter()))) ? (syntax_hl['$write_stylesheet?'](doc)) : ($ret_or_1));
            if ((($truthy(copy_asciidoctor_stylesheet) || ($truthy(copy_user_stylesheet))) || ($truthy(copy_syntax_hl_stylesheet)))) {
              
              stylesoutdir = doc.$normalize_system_path(stylesdir, outdir, ($truthy($rb_ge(doc.$safe(), $$$($$('SafeMode'), 'SAFE'))) ? (outdir) : (nil)));
              if ($truthy(mkdirs)) {
                $$('Helpers').$mkdir_p(stylesoutdir);
              } else if (!$truthy($$$('File')['$directory?'](stylesoutdir))) {
                self.$raise($$$('IOError'), "target stylesheet directory does not exist: " + (stylesoutdir) + " (hint: set :mkdirs option)");
              }              if ($truthy(copy_asciidoctor_stylesheet)) {
                $$('Stylesheets').$instance().$write_primary_stylesheet(stylesoutdir);
              } else if ($truthy(copy_user_stylesheet)) {
                
                if (($eqeq((stylesheet_src = doc.$attr("copycss")), "") || ($eqeq(stylesheet_src, true)))) {
                  stylesheet_src = doc.$normalize_system_path(stylesheet);
                } else {
                  stylesheet_src = doc.$normalize_system_path(stylesheet_src.$to_s());
                }                stylesheet_dest = doc.$normalize_system_path(stylesheet, stylesoutdir, ($truthy($rb_ge(doc.$safe(), $$$($$('SafeMode'), 'SAFE'))) ? (outdir) : (nil)));
                if (($neqeq(stylesheet_src, stylesheet_dest) && ($truthy((stylesheet_data = doc.$read_asset(stylesheet_src, $hash2(["warn_on_failure", "label"], {"warn_on_failure": $$$('File')['$file?'](stylesheet_dest)['$!'](), "label": "stylesheet"}))))))) {
                  
                  if (($neqeq((stylesheet_outdir = $$$('File').$dirname(stylesheet_dest)), stylesoutdir) && ($not($$$('File')['$directory?'](stylesheet_outdir))))) {
                    if ($truthy(mkdirs)) {
                      $$('Helpers').$mkdir_p(stylesheet_outdir);
                    } else {
                      self.$raise($$$('IOError'), "target stylesheet directory does not exist: " + (stylesheet_outdir) + " (hint: set :mkdirs option)");
                    }
                  }                  $$$('File').$write(stylesheet_dest, stylesheet_data, $hash2(["mode"], {"mode": $$('FILE_WRITE_MODE')}));
                }              }              if ($truthy(copy_syntax_hl_stylesheet)) {
                syntax_hl.$write_stylesheet(doc, stylesoutdir);
              }            }          }          return doc;
        } else {
          return output
        }      }, -2);
      
      $def(self, '$convert_file', function $$convert_file(filename, options) {
        var self = this;

        
        if (options == null) options = $hash2([], {});
        return $send($$$('File'), 'open', [filename, $$('FILE_READ_MODE')], function $$1(file){var self = $$1.$$s == null ? this : $$1.$$s;

          
          if (file == null) file = nil;
          return self.$convert(file, options);}, {$$s: self});
      }, -2);
      $alias(self, "render", "convert");
      return $alias(self, "render_file", "convert_file");
    })(Opal.get_singleton_class(self), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/syntax_highlighter/highlightjs"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $slice = Opal.slice, $send2 = Opal.send2, $find_super = Opal.find_super, $to_a = Opal.to_a, $def = Opal.def, $hash2 = Opal.hash2, $send = Opal.send, $truthy = Opal.truthy, $return_val = Opal.return_val, $eqeq = Opal.eqeq, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('register_for,merge,proc,[]=,attr,[],==,attr?,join,map,split,lstrip');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'HighlightJsAdapter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$register_for("highlightjs", "highlight.js");
      
      $def(self, '$initialize', function $$initialize($a) {
        var $post_args, args, $yield = $$initialize.$$p || nil, self = this;

        $$initialize.$$p = null;
        
        $post_args = $slice(arguments);
        args = $post_args;
        $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', $to_a(args), $yield);
        return (self.name = (self.pre_class = "highlightjs"));
      }, -1);
      
      $def(self, '$format', function $$format(node, lang, opts) {
        $$format.$$p || nil; var self = this;

        $$format.$$p = null;
        return $send2(self, $find_super(self, 'format', $$format, false, true), 'format', [node, lang, opts.$merge($hash2(["transform"], {"transform": $send(self, 'proc', [], function $$1(_, code){var $a, $ret_or_1 = nil;
          if (code == null) code = nil;
          return ($a = ["class", "language-" + (($truthy(($ret_or_1 = lang)) ? ($ret_or_1) : ("none"))) + " hljs"], $send(code, '[]=', $a), $a[$a.length - 1]);})}))], null)
      });
      
      $def(self, '$docinfo?', $return_val(true));
      return $def(self, '$docinfo', function $$docinfo(location, doc, opts) {
        var base_url = nil;

        
        base_url = doc.$attr("highlightjsdir", "" + (opts['$[]']("cdn_base_url")) + "/highlight.js/" + ($$('HIGHLIGHT_JS_VERSION')));
        if ($eqeq(location, "head")) {
          return "<link rel=\"stylesheet\" href=\"" + (base_url) + "/styles/" + (doc.$attr("highlightjs-theme", "github")) + ".min.css\"" + (opts['$[]']("self_closing_tag_slash")) + ">"
        } else {
          return "<script src=\"" + (base_url) + "/highlight.min.js\"></script>\n" + (($truthy(doc['$attr?']("highlightjs-languages")) ? ($send(doc.$attr("highlightjs-languages").$split(","), 'map', [], function $$2(lang){
            
            if (lang == null) lang = nil;
            return "<script src=\"" + (base_url) + "/languages/" + (lang.$lstrip()) + ".min.js\"></script>\n";}).$join()) : (""))) + "<script>\n" + "if (!hljs.initHighlighting.called) {\n" + "  hljs.initHighlighting.called = true\n" + "  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })\n" + "}\n" + "</script>"
        }      });
    })($$('SyntaxHighlighter'), $$$($$('SyntaxHighlighter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/syntax_highlighter"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $hash2 = Opal.hash2, $def = Opal.def, $return_val = Opal.return_val, $defs = Opal.defs, $slice = Opal.slice, $send = Opal.send, $to_a = Opal.to_a, $truthy = Opal.truthy, $eqeqeq = Opal.eqeqeq, $Class = Opal.Class, $klass = Opal.klass, $class_variable_set = Opal.class_variable_set, $class_variable_get = Opal.class_variable_get, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('attr_reader,raise,class,extend,private_class_method,register,map,to_s,each,[]=,registry,[],for,===,new,name,private,include,delete,join,content');
  
  (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'SyntaxHighlighter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      self.$attr_reader("name");
      
      $def(self, '$initialize', function $$initialize(name, backend, opts) {
        var self = this;
        if (opts == null) opts = $hash2([], {});
        return (self.name = (self.pre_class = name));
      }, -2);
      
      $def(self, '$docinfo?', $return_val(nil));
      
      $def(self, '$docinfo', function $$docinfo(location, doc, opts) {
        var self = this;

        return self.$raise($$$('NotImplementedError'), "" + ($$('SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("docinfo") + " method since #docinfo? returns true")
      });
      
      $def(self, '$highlight?', $return_val(nil));
      
      $def(self, '$highlight', function $$highlight(node, source, lang, opts) {
        var self = this;

        return self.$raise($$$('NotImplementedError'), "" + ($$('SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("highlight") + " method since #highlight? returns true")
      });
      
      $def(self, '$format', function $$format(node, lang, opts) {
        var self = this;

        return self.$raise($$$('NotImplementedError'), "" + ($$('SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("format") + " method")
      });
      
      $def(self, '$write_stylesheet?', $return_val(nil));
      
      $def(self, '$write_stylesheet', function $$write_stylesheet(doc, to_dir) {
        var self = this;

        return self.$raise($$$('NotImplementedError'), "" + ($$('SyntaxHighlighter')) + " subclass " + (self.$class()) + " must implement the #" + ("write_stylesheet") + " method since #write_stylesheet? returns true")
      });
      $defs(self, '$included', function $$included(into) {
        
        return into.$extend($$('Config'))
      });
      self.$private_class_method("included");
      (function($base, $parent_nesting) {
        var self = $module($base, 'Config');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$register_for', function $$register_for($a) {
          var $post_args, names, self = this;

          
          $post_args = $slice(arguments);
          names = $post_args;
          return $send($$('SyntaxHighlighter'), 'register', [self].concat($to_a($send(names, 'map', [], function $$1(name){
            
            if (name == null) name = nil;
            return name.$to_s();}))));
        }, -1)
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$register', function $$register(syntax_highlighter, $a) {
          var $post_args, names, self = this;

          
          $post_args = $slice(arguments, 1);
          names = $post_args;
          return $send(names, 'each', [], function $$2(name){var $b, self = $$2.$$s == null ? this : $$2.$$s;

            
            if (name == null) name = nil;
            return ($b = [name, syntax_highlighter], $send(self.$registry(), '[]=', $b), $b[$b.length - 1]);}, {$$s: self});
        }, -2);
        
        $def(self, '$for', function $Factory_for$3(name) {
          var self = this;

          return self.$registry()['$[]'](name)
        });
        
        $def(self, '$create', function $$create(name, backend, opts) {
          var self = this, syntax_hl = nil;

          
          if (backend == null) backend = "html5";
          if (opts == null) opts = $hash2([], {});
          if ($truthy((syntax_hl = self.$for(name)))) {
            
            if ($eqeqeq($Class, syntax_hl)) {
              syntax_hl = syntax_hl.$new(name, backend, opts);
            }            if (!$truthy(syntax_hl.$name())) {
              self.$raise($$$('NameError'), "" + (syntax_hl.$class()) + " must specify a value for `name'");
            }            return syntax_hl;
          } else {
            return nil
          }        }, -2);
        self.$private();
        return $def(self, '$registry', function $$registry() {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('Factory')) + " subclass " + (self.$class()) + " must implement the #" + ("registry") + " method")
        });
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'CustomFactory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('Factory'));
        
        $def(self, '$initialize', function $$initialize(seed_registry) {
          var self = this, $ret_or_1 = nil;

          
          if (seed_registry == null) seed_registry = nil;
          return (self.registry = ($truthy(($ret_or_1 = seed_registry)) ? ($ret_or_1) : ($hash2([], {}))));
        }, -1);
        self.$private();
        return self.$attr_reader("registry");
      })($nesting[0], null, $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DefaultFactory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('Factory'));
        $class_variable_set($nesting[0], '@@registry', $hash2([], {}));
        self.$private();
        
        $def(self, '$registry', function $$registry() {
          
          return $class_variable_get($nesting[0], '@@registry', false)
        });
        return nil;
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DefaultFactoryProxy');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DefaultFactory'));
        return nil;
      })($nesting[0], $$('CustomFactory'), $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Base');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.pre_class = nil;
        
        self.$include($$('SyntaxHighlighter'));
        return $def(self, '$format', function $$format(node, lang, opts) {
          var self = this, class_attr_val = nil, transform = nil, pre = nil, code = nil;

          
          class_attr_val = ($truthy(opts['$[]']("nowrap")) ? ("" + (self.pre_class) + " highlight nowrap") : ("" + (self.pre_class) + " highlight"));
          if ($truthy((transform = opts['$[]']("transform")))) {
            
            transform['$[]']((pre = $hash2(["class"], {"class": class_attr_val})), (code = ($truthy(lang) ? ($hash2(["data-lang"], {"data-lang": lang})) : ($hash2([], {})))));
            if ($truthy((lang = code.$delete("data-lang")))) {
              code['$[]=']("data-lang", lang);
            }            return "<pre" + ($send(pre, 'map', [], function $$4(k, v){
              
              if (k == null) k = nil;
              if (v == null) v = nil;
              return " " + (k) + "=\"" + (v) + "\"";}).$join()) + "><code" + ($send(code, 'map', [], function $$5(k, v){
              
              if (k == null) k = nil;
              if (v == null) v = nil;
              return " " + (k) + "=\"" + (v) + "\"";}).$join()) + ">" + (node.$content()) + "</code></pre>";
          } else {
            return "<pre class=\"" + (class_attr_val) + "\"><code" + (($truthy(lang) ? (" data-lang=\"" + (lang) + "\"") : (""))) + ">" + (node.$content()) + "</code></pre>"
          }        });
      })($nesting[0], null, $nesting);
      return self.$extend($$('DefaultFactory'));
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
  self.$require("asciidoctor/syntax_highlighter.rb"+ '/../' + "syntax_highlighter/highlightjs");
  return nil;
};

Opal.modules["asciidoctor/timings"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $rb_minus = Opal.rb_minus, $slice = Opal.slice, $rb_plus = Opal.rb_plus, $truthy = Opal.truthy, $rb_gt = Opal.rb_gt, $gvars = Opal.gvars, $eqeq = Opal.eqeq, $const_set = Opal.const_set, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[]=,now,-,delete,reduce,+,[],>,time,puts,sprintf,to_f,read_parse,convert,read_parse_convert,private,==,const_defined?,clock_gettime');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Timings');

      var $a, $b, $c, $d, $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.timers = $proto.log = nil;
      
      
      $def(self, '$initialize', function $$initialize() {
        var self = this;

        
        self.log = $hash2([], {});
        return (self.timers = $hash2([], {}));
      });
      
      $def(self, '$start', function $$start(key) {
        var $a, self = this;

        return ($a = [key, self.$now()], $send(self.timers, '[]=', $a), $a[$a.length - 1])
      });
      
      $def(self, '$record', function $$record(key) {
        var $a, self = this;

        return ($a = [key, $rb_minus(self.$now(), self.timers.$delete(key))], $send(self.log, '[]=', $a), $a[$a.length - 1])
      });
      
      $def(self, '$time', function $$time($a) {
        var $post_args, keys, self = this, time = nil;

        
        $post_args = $slice(arguments);
        keys = $post_args;
        time = $send(keys, 'reduce', [0], function $$1(sum, key){var self = $$1.$$s == null ? this : $$1.$$s, $ret_or_1 = nil;
          if (self.log == null) self.log = nil;

          
          if (sum == null) sum = nil;
          if (key == null) key = nil;
          return $rb_plus(sum, ($truthy(($ret_or_1 = self.log['$[]'](key))) ? ($ret_or_1) : (0)));}, {$$s: self});
        if ($truthy($rb_gt(time, 0))) {
          return time
        } else {
          return nil
        }      }, -1);
      
      $def(self, '$read', function $$read() {
        var self = this;

        return self.$time("read")
      });
      
      $def(self, '$parse', function $$parse() {
        var self = this;

        return self.$time("parse")
      });
      
      $def(self, '$read_parse', function $$read_parse() {
        var self = this;

        return self.$time("read", "parse")
      });
      
      $def(self, '$convert', function $$convert() {
        var self = this;

        return self.$time("convert")
      });
      
      $def(self, '$read_parse_convert', function $$read_parse_convert() {
        var self = this;

        return self.$time("read", "parse", "convert")
      });
      
      $def(self, '$write', function $$write() {
        var self = this;

        return self.$time("write")
      });
      
      $def(self, '$total', function $$total() {
        var self = this;

        return self.$time("read", "parse", "convert", "write")
      });
      
      $def(self, '$print_report', function $$print_report(to, subject) {
        var self = this;
        if ($gvars.stdout == null) $gvars.stdout = nil;

        
        if (to == null) to = $gvars.stdout;
        if (subject == null) subject = nil;
        if ($truthy(subject)) {
          to.$puts("Input file: " + (subject));
        }        to.$puts("  Time to read and parse source: " + (self.$sprintf("%05.5f", self.$read_parse().$to_f())));
        to.$puts("  Time to convert document: " + (self.$sprintf("%05.5f", self.$convert().$to_f())));
        return to.$puts("  Total time (read, parse and convert): " + (self.$sprintf("%05.5f", self.$read_parse_convert().$to_f())));
      }, -1);
      self.$private();
      if (($truthy($$$('Process')['$const_defined?']("CLOCK_MONOTONIC", false)) && ($eqeq(((($a = $$$('::', 'Process', 'skip_raise')) && ($b = $a, $b) && ($c = $b) && ((($d = $c.$clock_gettime) && !$d.$$stub) || $c['$respond_to_missing?']('clock_gettime'))) ? 'method' : nil), "method")))) {
        
        $const_set($nesting[0], 'CLOCK_ID', $$$($$$('Process'), 'CLOCK_MONOTONIC'));
        return $def(self, '$now', function $$now() {
          
          return $$$('Process').$clock_gettime($$('CLOCK_ID'))
        });
      } else {
        return $def(self, '$now', function $$now() {
          
          return $$$('Time').$now()
        })
      }    })($nesting[0], null, $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/converter/html5"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $const_set = Opal.const_set, $hash2 = Opal.hash2, $regexp = Opal.regexp, $eqeq = Opal.eqeq, $def = Opal.def, $send2 = Opal.send2, $find_super = Opal.find_super, $truthy = Opal.truthy, $send = Opal.send, $rb_gt = Opal.rb_gt, $rb_plus = Opal.rb_plus, $not = Opal.not, $neqeq = Opal.neqeq, $rb_le = Opal.rb_le, $rb_lt = Opal.rb_lt, $to_ary = Opal.to_ary, $rb_times = Opal.rb_times, $rb_minus = Opal.rb_minus, $gvars = Opal.gvars, $return_val = Opal.return_val, $alias = Opal.alias, $eqeqeq = Opal.eqeqeq, $slice = Opal.slice, $to_a = Opal.to_a, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('register_for,default=,==,[],init_backend_traits,node_name,convert_inline_quoted,convert_paragraph,convert_inline_anchor,convert_section,convert_listing,convert_literal,convert_ulist,convert_olist,convert_dlist,convert_admonition,convert_colist,convert_embedded,convert_example,convert_floating_title,convert_image,convert_inline_break,convert_inline_button,convert_inline_callout,convert_inline_footnote,convert_inline_image,convert_inline_indexterm,convert_inline_kbd,convert_inline_menu,convert_open,convert_page_break,convert_preamble,convert_quote,convert_sidebar,convert_stem,convert_table,convert_thematic_break,convert_verse,convert_video,convert_document,convert_toc,convert_pass,convert_audio,empty?,attr,attr?,<<,include?,sub_replacements,gsub,extname,slice,length,doctitle,normalize_web_path,primary_stylesheet_data,instance,read_contents,syntax_highlighter,size,docinfo,id,sections?,doctype,role?,role,join,noheader,convert,converter,generate_manname_section,header?,notitle,title,header,each,authors,>,name,email,sub_macros,+,downcase,concat,content,!,footnotes?,footnotes,index,text,nofooter,docinfo?,[]=,delete_at,inspect,!=,to_i,attributes,document,sections,level,caption,captioned_title,<=,numbered,<,sectname,sectnum,convert_outline,title?,icon_uri,compact,media_uri,option?,append_boolean_attribute,style,items,blocks?,text?,chomp,safe,read_svg_contents,alt,image_uri,encode_attribute_value,append_link_constraint_attrs,highlight?,to_sym,format,*,-,count,end_with?,start_with?,list_marker_keyword,parent,warn,logger,context,error,content_only,new,columns,to_h,rows,colspan,rowspan,unshift,shift,split,pop,nil_or_empty?,type,===,catalog,get_root_document,xreftext,target,reftext,chop,sub,match,private,upcase,nested?,parent_document,handles?,to_s,send');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super, $parent_nesting) {
      var self = $klass($base, $super, 'Html5Converter');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

      $proto.void_element_slash = $proto.xml_mode = $proto.refs = $proto.resolving_xref = nil;
      
      self.$register_for("html5");
      $const_set($nesting[0], 'QUOTE_TAGS', $hash2(["monospaced", "emphasis", "strong", "double", "single", "mark", "superscript", "subscript", "asciimath", "latexmath"], {"monospaced": ["<code>", "</code>", true], "emphasis": ["<em>", "</em>", true], "strong": ["<strong>", "</strong>", true], "double": ["&#8220;", "&#8221;"], "single": ["&#8216;", "&#8217;"], "mark": ["<mark>", "</mark>", true], "superscript": ["<sup>", "</sup>", true], "subscript": ["<sub>", "</sub>", true], "asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"]}))['$default='](["", ""]);
      $const_set($nesting[0], 'DropAnchorRx', /<(?:a\b[^>]*|\/a)>/);
      $const_set($nesting[0], 'StemBreakRx', / *\\\n(?:\\?\n)*|\n\n+/);
      
      $const_set($nesting[0], 'SvgPreambleRx', $regexp(["^", $$('CC_ALL'), "*?(?=<svg[\\s>])"]));
      $const_set($nesting[0], 'SvgStartTagRx', /^<svg(?:\s[^>]*)?>/);      $const_set($nesting[0], 'DimensionAttributeRx', $regexp(["\\s(?:width|height|style)=([\"'])", $$('CC_ANY'), "*?\\1"]));
      
      $def(self, '$initialize', function $$initialize(backend, opts) {
        var self = this, syntax = nil;

        
        if (opts == null) opts = $hash2([], {});
        self.backend = backend;
        if ($eqeq(opts['$[]']("htmlsyntax"), "xml")) {
          
          syntax = "xml";
          self.xml_mode = true;
          self.void_element_slash = "/";
        } else {
          
          syntax = "html";
          self.xml_mode = nil;
          self.void_element_slash = "";
        }        return self.$init_backend_traits($hash2(["basebackend", "filetype", "htmlsyntax", "outfilesuffix", "supports_templates"], {"basebackend": "html", "filetype": "html", "htmlsyntax": syntax, "outfilesuffix": ".html", "supports_templates": true}));
      }, -2);
      
      $def(self, '$convert', function $$convert(node, transform, opts) {
        var $yield = $$convert.$$p || nil, self = this;

        $$convert.$$p = null;
        
        if (transform == null) transform = node.$node_name();
        if (opts == null) opts = nil;
        
        switch (transform) {
          case "inline_quoted":
            return self.$convert_inline_quoted(node)
          case "paragraph":
            return self.$convert_paragraph(node)
          case "inline_anchor":
            return self.$convert_inline_anchor(node)
          case "section":
            return self.$convert_section(node)
          case "listing":
            return self.$convert_listing(node)
          case "literal":
            return self.$convert_literal(node)
          case "ulist":
            return self.$convert_ulist(node)
          case "olist":
            return self.$convert_olist(node)
          case "dlist":
            return self.$convert_dlist(node)
          case "admonition":
            return self.$convert_admonition(node)
          case "colist":
            return self.$convert_colist(node)
          case "embedded":
            return self.$convert_embedded(node)
          case "example":
            return self.$convert_example(node)
          case "floating_title":
            return self.$convert_floating_title(node)
          case "image":
            return self.$convert_image(node)
          case "inline_break":
            return self.$convert_inline_break(node)
          case "inline_button":
            return self.$convert_inline_button(node)
          case "inline_callout":
            return self.$convert_inline_callout(node)
          case "inline_footnote":
            return self.$convert_inline_footnote(node)
          case "inline_image":
            return self.$convert_inline_image(node)
          case "inline_indexterm":
            return self.$convert_inline_indexterm(node)
          case "inline_kbd":
            return self.$convert_inline_kbd(node)
          case "inline_menu":
            return self.$convert_inline_menu(node)
          case "open":
            return self.$convert_open(node)
          case "page_break":
            return self.$convert_page_break(node)
          case "preamble":
            return self.$convert_preamble(node)
          case "quote":
            return self.$convert_quote(node)
          case "sidebar":
            return self.$convert_sidebar(node)
          case "stem":
            return self.$convert_stem(node)
          case "table":
            return self.$convert_table(node)
          case "thematic_break":
            return self.$convert_thematic_break(node)
          case "verse":
            return self.$convert_verse(node)
          case "video":
            return self.$convert_video(node)
          case "document":
            return self.$convert_document(node)
          case "toc":
            return self.$convert_toc(node)
          case "pass":
            return self.$convert_pass(node)
          case "audio":
            return self.$convert_audio(node)
          default:
            return $send2(self, $find_super(self, 'convert', $$convert, false, true), 'convert', [node, transform, opts], $yield)
        }      }, -2);
      
      $def(self, '$convert_document', function $$convert_document(node) {
        var self = this, br = nil, slash = nil, asset_uri_scheme = nil, cdn_base_url = nil, linkcss = nil, max_width_attr = nil, result = nil, lang_attribute = nil, authors = nil, icon_href = nil, icon_type = nil, icon_ext = nil, webfonts = nil, iconfont_stylesheet = nil, syntax_hl = nil, syntax_hl_docinfo_head_idx = nil, docinfo_content = nil, id_attr = nil, sectioned = nil, classes = nil, details = nil, idx = nil, $ret_or_1 = nil, eqnums_val = nil, eqnums_opt = nil;

        
        br = "<br" + ((slash = self.void_element_slash)) + ">";
        if (!$truthy((asset_uri_scheme = node.$attr("asset-uri-scheme", "https"))['$empty?']())) {
          asset_uri_scheme = "" + (asset_uri_scheme) + ":";
        }        cdn_base_url = "" + (asset_uri_scheme) + "//cdnjs.cloudflare.com/ajax/libs";
        linkcss = node['$attr?']("linkcss");
        max_width_attr = ($truthy(node['$attr?']("max-width")) ? (" style=\"max-width: " + (node.$attr("max-width")) + ";\"") : (""));
        result = ["<!DOCTYPE html>"];
        lang_attribute = ($truthy(node['$attr?']("nolang")) ? ("") : (" lang=\"" + (node.$attr("lang", "en")) + "\""));
        result['$<<']("<html" + (($truthy(self.xml_mode) ? (" xmlns=\"http://www.w3.org/1999/xhtml\"") : (""))) + (lang_attribute) + ">");
        result['$<<']("<head>\n" + "<meta charset=\"" + (node.$attr("encoding", "UTF-8")) + "\"" + (slash) + ">\n" + "<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"" + (slash) + ">\n" + "<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"" + (slash) + ">\n" + "<meta name=\"generator\" content=\"Asciidoctor " + (node.$attr("asciidoctor-version")) + "\"" + (slash) + ">");
        if ($truthy(node['$attr?']("app-name"))) {
          result['$<<']("<meta name=\"application-name\" content=\"" + (node.$attr("app-name")) + "\"" + (slash) + ">");
        }        if ($truthy(node['$attr?']("description"))) {
          result['$<<']("<meta name=\"description\" content=\"" + (node.$attr("description")) + "\"" + (slash) + ">");
        }        if ($truthy(node['$attr?']("keywords"))) {
          result['$<<']("<meta name=\"keywords\" content=\"" + (node.$attr("keywords")) + "\"" + (slash) + ">");
        }        if ($truthy(node['$attr?']("authors"))) {
          result['$<<']("<meta name=\"author\" content=\"" + (($truthy((authors = node.$sub_replacements(node.$attr("authors")))['$include?']("<")) ? (authors.$gsub($$('XmlSanitizeRx'), "")) : (authors))) + "\"" + (slash) + ">");
        }        if ($truthy(node['$attr?']("copyright"))) {
          result['$<<']("<meta name=\"copyright\" content=\"" + (node.$attr("copyright")) + "\"" + (slash) + ">");
        }        if ($truthy(node['$attr?']("favicon"))) {
          
          if ($truthy((icon_href = node.$attr("favicon"))['$empty?']())) {
            
            icon_href = "favicon.ico";
            icon_type = "image/x-icon";
          } else if ($truthy((icon_ext = $$('Helpers').$extname(icon_href, nil)))) {
            icon_type = ($eqeq(icon_ext, ".ico") ? ("image/x-icon") : ("image/" + (icon_ext.$slice(1, icon_ext.$length()))));
          } else {
            icon_type = "image/x-icon";
          }          result['$<<']("<link rel=\"icon\" type=\"" + (icon_type) + "\" href=\"" + (icon_href) + "\"" + (slash) + ">");
        }        result['$<<']("<title>" + (node.$doctitle($hash2(["sanitize", "use_fallback"], {"sanitize": true, "use_fallback": true}))) + "</title>");
        if ($truthy($$('DEFAULT_STYLESHEET_KEYS')['$include?'](node.$attr("stylesheet")))) {
          
          if ($truthy((webfonts = node.$attr("webfonts")))) {
            result['$<<']("<link rel=\"stylesheet\" href=\"" + (asset_uri_scheme) + "//fonts.googleapis.com/css?family=" + (($truthy(webfonts['$empty?']()) ? ("Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700") : (webfonts))) + "\"" + (slash) + ">");
          }          if ($truthy(linkcss)) {
            result['$<<']("<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path($$('DEFAULT_STYLESHEET_NAME'), node.$attr("stylesdir", ""), false)) + "\"" + (slash) + ">");
          } else {
            result['$<<']("<style>\n" + ($$('Stylesheets').$instance().$primary_stylesheet_data()) + "\n" + "</style>");
          }        } else if ($truthy(node['$attr?']("stylesheet"))) {
          if ($truthy(linkcss)) {
            result['$<<']("<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path(node.$attr("stylesheet"), node.$attr("stylesdir", ""))) + "\"" + (slash) + ">");
          } else {
            result['$<<']("<style>\n" + (node.$read_contents(node.$attr("stylesheet"), $hash2(["start", "warn_on_failure", "label"], {"start": node.$attr("stylesdir"), "warn_on_failure": true, "label": "stylesheet"}))) + "\n" + "</style>");
          }
        }        if ($truthy(node['$attr?']("icons", "font"))) {
          if ($truthy(node['$attr?']("iconfont-remote"))) {
            result['$<<']("<link rel=\"stylesheet\" href=\"" + (node.$attr("iconfont-cdn", "" + (cdn_base_url) + "/font-awesome/" + ($$('FONT_AWESOME_VERSION')) + "/css/font-awesome.min.css")) + "\"" + (slash) + ">");
          } else {
            
            iconfont_stylesheet = "" + (node.$attr("iconfont-name", "font-awesome")) + ".css";
            result['$<<']("<link rel=\"stylesheet\" href=\"" + (node.$normalize_web_path(iconfont_stylesheet, node.$attr("stylesdir", ""), false)) + "\"" + (slash) + ">");
          }
        }        if ($truthy((syntax_hl = node.$syntax_highlighter()))) {
          result['$<<']((syntax_hl_docinfo_head_idx = result.$size()));
        }        if (!$truthy((docinfo_content = node.$docinfo())['$empty?']())) {
          result['$<<'](docinfo_content);
        }        result['$<<']("</head>");
        id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        if (((($truthy((sectioned = node['$sections?']())) && ($truthy(node['$attr?']("toc-class")))) && ($truthy(node['$attr?']("toc")))) && ($truthy(node['$attr?']("toc-placement", "auto"))))) {
          classes = [node.$doctype(), node.$attr("toc-class"), "toc-" + (node.$attr("toc-position", "header"))];
        } else {
          classes = [node.$doctype()];
        }        if ($truthy(node['$role?']())) {
          classes['$<<'](node.$role());
        }        result['$<<']("<body" + (id_attr) + " class=\"" + (classes.$join(" ")) + "\">");
        if (!$truthy((docinfo_content = node.$docinfo("header"))['$empty?']())) {
          result['$<<'](docinfo_content);
        }        if (!$truthy(node.$noheader())) {
          
          result['$<<']("<div id=\"header\"" + (max_width_attr) + ">");
          if ($eqeq(node.$doctype(), "manpage")) {
            
            result['$<<']("<h1>" + (node.$doctitle()) + " Manual Page</h1>");
            if ((($truthy(sectioned) && ($truthy(node['$attr?']("toc")))) && ($truthy(node['$attr?']("toc-placement", "auto"))))) {
              result['$<<']("<div id=\"toc\" class=\"" + (node.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>");
            }            if ($truthy(node['$attr?']("manpurpose"))) {
              result['$<<'](self.$generate_manname_section(node));
            }          } else {
            
            if ($truthy(node['$header?']())) {
              
              if (!$truthy(node.$notitle())) {
                result['$<<']("<h1>" + (node.$header().$title()) + "</h1>");
              }              details = [];
              idx = 1;
              $send(node.$authors(), 'each', [], function $$1(author){
                
                if (author == null) author = nil;
                details['$<<']("<span id=\"author" + (($truthy($rb_gt(idx, 1)) ? (idx) : (""))) + "\" class=\"author\">" + (node.$sub_replacements(author.$name())) + "</span>" + (br));
                if ($truthy(author.$email())) {
                  details['$<<']("<span id=\"email" + (($truthy($rb_gt(idx, 1)) ? (idx) : (""))) + "\" class=\"email\">" + (node.$sub_macros(author.$email())) + "</span>" + (br));
                }                return (idx = $rb_plus(idx, 1));});
              if ($truthy(node['$attr?']("revnumber"))) {
                details['$<<']("<span id=\"revnumber\">" + (($truthy(($ret_or_1 = node.$attr("version-label"))) ? ($ret_or_1) : ("")).$downcase()) + " " + (node.$attr("revnumber")) + (($truthy(node['$attr?']("revdate")) ? (",") : (""))) + "</span>");
              }              if ($truthy(node['$attr?']("revdate"))) {
                details['$<<']("<span id=\"revdate\">" + (node.$attr("revdate")) + "</span>");
              }              if ($truthy(node['$attr?']("revremark"))) {
                details['$<<']("" + (br) + "<span id=\"revremark\">" + (node.$attr("revremark")) + "</span>");
              }              if (!$truthy(details['$empty?']())) {
                
                result['$<<']("<div class=\"details\">");
                result.$concat(details);
                result['$<<']("</div>");
              }            }            if ((($truthy(sectioned) && ($truthy(node['$attr?']("toc")))) && ($truthy(node['$attr?']("toc-placement", "auto"))))) {
              result['$<<']("<div id=\"toc\" class=\"" + (node.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>");
            }          }          result['$<<']("</div>");
        }        result['$<<']("<div id=\"content\"" + (max_width_attr) + ">\n" + (node.$content()) + "\n" + "</div>");
        if (($truthy(node['$footnotes?']()) && ($not(node['$attr?']("nofootnotes"))))) {
          
          result['$<<']("<div id=\"footnotes\"" + (max_width_attr) + ">\n" + "<hr" + (slash) + ">");
          $send(node.$footnotes(), 'each', [], function $$2(footnote){
            
            if (footnote == null) footnote = nil;
            return result['$<<']("<div class=\"footnote\" id=\"_footnotedef_" + (footnote.$index()) + "\">\n" + "<a href=\"#_footnoteref_" + (footnote.$index()) + "\">" + (footnote.$index()) + "</a>. " + (footnote.$text()) + "\n" + "</div>");});
          result['$<<']("</div>");
        }        if (!$truthy(node.$nofooter())) {
          
          result['$<<']("<div id=\"footer\"" + (max_width_attr) + ">");
          result['$<<']("<div id=\"footer-text\">");
          if ($truthy(node['$attr?']("revnumber"))) {
            result['$<<']("" + (node.$attr("version-label")) + " " + (node.$attr("revnumber")) + (br));
          }          if (($truthy(node['$attr?']("last-update-label")) && ($not(node['$attr?']("reproducible"))))) {
            result['$<<']("" + (node.$attr("last-update-label")) + " " + (node.$attr("docdatetime")));
          }          result['$<<']("</div>");
          result['$<<']("</div>");
        }        if ($truthy(syntax_hl)) {
          
          if ($truthy(syntax_hl['$docinfo?']("head"))) {
            result['$[]='](syntax_hl_docinfo_head_idx, syntax_hl.$docinfo("head", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], {"cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash})));
          } else {
            result.$delete_at(syntax_hl_docinfo_head_idx);
          }          if ($truthy(syntax_hl['$docinfo?']("footer"))) {
            result['$<<'](syntax_hl.$docinfo("footer", node, $hash2(["cdn_base_url", "linkcss", "self_closing_tag_slash"], {"cdn_base_url": cdn_base_url, "linkcss": linkcss, "self_closing_tag_slash": slash})));
          }        }        if ($truthy(node['$attr?']("stem"))) {
          
          eqnums_val = node.$attr("eqnums", "none");
          if ($truthy(eqnums_val['$empty?']())) {
            eqnums_val = "AMS";
          }          eqnums_opt = " equationNumbers: { autoNumber: \"" + (eqnums_val) + "\" } ";
          result['$<<']("<script type=\"text/x-mathjax-config\">\n" + "MathJax.Hub.Config({\n" + "  messageStyle: \"none\",\n" + "  tex2jax: {\n" + "    inlineMath: [" + ($$('INLINE_MATH_DELIMITERS')['$[]']("latexmath").$inspect()) + "],\n" + "    displayMath: [" + ($$('BLOCK_MATH_DELIMITERS')['$[]']("latexmath").$inspect()) + "],\n" + "    ignoreClass: \"nostem|nolatexmath\"\n" + "  },\n" + "  asciimath2jax: {\n" + "    delimiters: [" + ($$('BLOCK_MATH_DELIMITERS')['$[]']("asciimath").$inspect()) + "],\n" + "    ignoreClass: \"nostem|noasciimath\"\n" + "  },\n" + "  TeX: {" + (eqnums_opt) + "}\n" + "})\n" + "MathJax.Hub.Register.StartupHook(\"AsciiMath Jax Ready\", function () {\n" + "  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {\n" + "    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains(\"stemblock\")) {\n" + "      data.math.root.display = \"block\"\n" + "    }\n" + "    return data\n" + "  })\n" + "})\n" + "</script>\n" + "<script src=\"" + (cdn_base_url) + "/mathjax/" + ($$('MATHJAX_VERSION')) + "/MathJax.js?config=TeX-MML-AM_HTMLorMML\"></script>");
        }        if (!$truthy((docinfo_content = node.$docinfo("footer"))['$empty?']())) {
          result['$<<'](docinfo_content);
        }        result['$<<']("</body>");
        result['$<<']("</html>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_embedded', function $$convert_embedded(node) {
        var self = this, result = nil, id_attr = nil, toc_p = nil;

        
        result = [];
        if ($eqeq(node.$doctype(), "manpage")) {
          
          if (!$truthy(node.$notitle())) {
            
            id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
            result['$<<']("<h1" + (id_attr) + ">" + (node.$doctitle()) + " Manual Page</h1>");
          }          if ($truthy(node['$attr?']("manpurpose"))) {
            result['$<<'](self.$generate_manname_section(node));
          }        } else if (($truthy(node['$header?']()) && ($not(node.$notitle())))) {
          
          id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
          result['$<<']("<h1" + (id_attr) + ">" + (node.$header().$title()) + "</h1>");
        }        if (((($truthy(node['$sections?']()) && ($truthy(node['$attr?']("toc")))) && ($neqeq((toc_p = node.$attr("toc-placement")), "macro"))) && ($neqeq(toc_p, "preamble")))) {
          result['$<<']("<div id=\"toc\" class=\"toc\">\n" + "<div id=\"toctitle\">" + (node.$attr("toc-title")) + "</div>\n" + (node.$converter().$convert(node, "outline")) + "\n" + "</div>");
        }        result['$<<'](node.$content());
        if (($truthy(node['$footnotes?']()) && ($not(node['$attr?']("nofootnotes"))))) {
          
          result['$<<']("<div id=\"footnotes\">\n" + "<hr" + (self.void_element_slash) + ">");
          $send(node.$footnotes(), 'each', [], function $$3(footnote){
            
            if (footnote == null) footnote = nil;
            return result['$<<']("<div class=\"footnote\" id=\"_footnotedef_" + (footnote.$index()) + "\">\n" + "<a href=\"#_footnoteref_" + (footnote.$index()) + "\">" + (footnote.$index()) + "</a>. " + (footnote.$text()) + "\n" + "</div>");});
          result['$<<']("</div>");
        }        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_outline', function $$convert_outline(node, opts) {
        var self = this, sectnumlevels = nil, $ret_or_1 = nil, $ret_or_2 = nil, toclevels = nil, sections = nil, result = nil;

        
        if (opts == null) opts = $hash2([], {});
        if (!$truthy(node['$sections?']())) {
          return nil
        }        sectnumlevels = ($truthy(($ret_or_1 = opts['$[]']("sectnumlevels"))) ? ($ret_or_1) : (($truthy(($ret_or_2 = node.$document().$attributes()['$[]']("sectnumlevels"))) ? ($ret_or_2) : (3)).$to_i()));
        toclevels = ($truthy(($ret_or_1 = opts['$[]']("toclevels"))) ? ($ret_or_1) : (($truthy(($ret_or_2 = node.$document().$attributes()['$[]']("toclevels"))) ? ($ret_or_2) : (2)).$to_i()));
        sections = node.$sections();
        result = ["<ul class=\"sectlevel" + (sections['$[]'](0).$level()) + "\">"];
        $send(sections, 'each', [], function $$4(section){var self = $$4.$$s == null ? this : $$4.$$s, slevel = nil, stitle = nil, signifier = nil, child_toc_level = nil;

          
          if (section == null) section = nil;
          slevel = section.$level();
          if ($truthy(section.$caption())) {
            stitle = section.$captioned_title();
          } else if (($truthy(section.$numbered()) && ($truthy($rb_le(slevel, sectnumlevels))))) {
            if (($truthy($rb_lt(slevel, 2)) && ($eqeq(node.$document().$doctype(), "book")))) {
              
              switch (section.$sectname()) {
                case "chapter":
                  stitle = "" + (($truthy((signifier = node.$document().$attributes()['$[]']("chapter-signifier"))) ? ("" + (signifier) + " ") : (""))) + (section.$sectnum()) + " " + (section.$title());
                  break;
                case "part":
                  stitle = "" + (($truthy((signifier = node.$document().$attributes()['$[]']("part-signifier"))) ? ("" + (signifier) + " ") : (""))) + (section.$sectnum(nil, ":")) + " " + (section.$title());
                  break;
                default:
                  stitle = "" + (section.$sectnum()) + " " + (section.$title());
              }
            } else {
              stitle = "" + (section.$sectnum()) + " " + (section.$title());
            }
          } else {
            stitle = section.$title();
          }          if ($truthy(stitle['$include?']("<a"))) {
            stitle = stitle.$gsub($$('DropAnchorRx'), "");
          }          if (($truthy($rb_lt(slevel, toclevels)) && ($truthy((child_toc_level = self.$convert_outline(section, $hash2(["toclevels", "sectnumlevels"], {"toclevels": toclevels, "sectnumlevels": sectnumlevels}))))))) {
            
            result['$<<']("<li><a href=\"#" + (section.$id()) + "\">" + (stitle) + "</a>");
            result['$<<'](child_toc_level);
            return result['$<<']("</li>");
          } else {
            return result['$<<']("<li><a href=\"#" + (section.$id()) + "\">" + (stitle) + "</a></li>")
          }}, {$$s: self});
        result['$<<']("</ul>");
        return result.$join($$('LF'));
      }, -2);
      
      $def(self, '$convert_section', function $$convert_section(node) {
        var doc_attrs = nil, level = nil, title = nil, $ret_or_1 = nil, signifier = nil, id_attr = nil, id = nil, role = nil;

        
        doc_attrs = node.$document().$attributes();
        level = node.$level();
        if ($truthy(node.$caption())) {
          title = node.$captioned_title();
        } else if (($truthy(node.$numbered()) && ($truthy($rb_le(level, ($truthy(($ret_or_1 = doc_attrs['$[]']("sectnumlevels"))) ? ($ret_or_1) : (3)).$to_i()))))) {
          if (($truthy($rb_lt(level, 2)) && ($eqeq(node.$document().$doctype(), "book")))) {
            
            switch (node.$sectname()) {
              case "chapter":
                title = "" + (($truthy((signifier = doc_attrs['$[]']("chapter-signifier"))) ? ("" + (signifier) + " ") : (""))) + (node.$sectnum()) + " " + (node.$title());
                break;
              case "part":
                title = "" + (($truthy((signifier = doc_attrs['$[]']("part-signifier"))) ? ("" + (signifier) + " ") : (""))) + (node.$sectnum(nil, ":")) + " " + (node.$title());
                break;
              default:
                title = "" + (node.$sectnum()) + " " + (node.$title());
            }
          } else {
            title = "" + (node.$sectnum()) + " " + (node.$title());
          }
        } else {
          title = node.$title();
        }        if ($truthy(node.$id())) {
          
          id_attr = " id=\"" + ((id = node.$id())) + "\"";
          if ($truthy(doc_attrs['$[]']("sectlinks"))) {
            title = "<a class=\"link\" href=\"#" + (id) + "\">" + (title) + "</a>";
          }          if ($truthy(doc_attrs['$[]']("sectanchors"))) {
            if ($eqeq(doc_attrs['$[]']("sectanchors"), "after")) {
              title = "" + (title) + "<a class=\"anchor\" href=\"#" + (id) + "\"></a>";
            } else {
              title = "<a class=\"anchor\" href=\"#" + (id) + "\"></a>" + (title);
            }
          }        } else {
          id_attr = "";
        }        if ($eqeq(level, 0)) {
          return "<h1" + (id_attr) + " class=\"sect0" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">" + (title) + "</h1>\n" + (node.$content())
        } else {
          return "<div class=\"sect" + (level) + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + "<h" + ($rb_plus(level, 1)) + (id_attr) + ">" + (title) + "</h" + ($rb_plus(level, 1)) + ">\n" + (($eqeq(level, 1) ? ("<div class=\"sectionbody\">\n" + (node.$content()) + "\n" + "</div>") : (node.$content()))) + "\n" + "</div>"
        }      });
      
      $def(self, '$convert_admonition', function $$convert_admonition(node) {
        var self = this, id_attr = nil, name = nil, title_element = nil, label = nil, role = nil;

        
        id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        name = node.$attr("name");
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
        if ($truthy(node.$document()['$attr?']("icons"))) {
          if (($truthy(node.$document()['$attr?']("icons", "font")) && ($not(node['$attr?']("icon"))))) {
            label = "<i class=\"fa icon-" + (name) + "\" title=\"" + (node.$attr("textlabel")) + "\"></i>";
          } else {
            label = "<img src=\"" + (node.$icon_uri(name)) + "\" alt=\"" + (node.$attr("textlabel")) + "\"" + (self.void_element_slash) + ">";
          }
        } else {
          label = "<div class=\"title\">" + (node.$attr("textlabel")) + "</div>";
        }        return "<div" + (id_attr) + " class=\"admonitionblock " + (name) + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + "<table>\n" + "<tr>\n" + "<td class=\"icon\">\n" + (label) + "\n" + "</td>\n" + "<td class=\"content\">\n" + (title_element) + (node.$content()) + "\n" + "</td>\n" + "</tr>\n" + "</table>\n" + "</div>";
      });
      
      $def(self, '$convert_audio', function $$convert_audio(node) {
        var self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, start_t = nil, end_t = nil, time_anchor = nil, $ret_or_1 = nil;

        
        xml = self.xml_mode;
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["audioblock", node.$role()].$compact();
        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
        start_t = node.$attr("start");
        end_t = node.$attr("end");
        time_anchor = (($truthy(start_t) || ($truthy(end_t))) ? ("#t=" + (($truthy(($ret_or_1 = start_t)) ? ($ret_or_1) : (""))) + (($truthy(end_t) ? ("," + (end_t)) : ("")))) : (""));
        return "<div" + (id_attribute) + (class_attribute) + ">\n" + (title_element) + "<div class=\"content\">\n" + "<audio src=\"" + (node.$media_uri(node.$attr("target"))) + (time_anchor) + "\"" + (($truthy(node['$option?']("autoplay")) ? (self.$append_boolean_attribute("autoplay", xml)) : (""))) + (($truthy(node['$option?']("nocontrols")) ? ("") : (self.$append_boolean_attribute("controls", xml)))) + (($truthy(node['$option?']("loop")) ? (self.$append_boolean_attribute("loop", xml)) : (""))) + ">\n" + "Your browser does not support the audio tag.\n" + "</audio>\n" + "</div>\n" + "</div>";
      });
      
      $def(self, '$convert_colist', function $$convert_colist(node) {
        var $a, self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, font_icons = nil, num = nil;

        
        result = [];
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["colist", node.$style(), node.$role()].$compact();
        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("<div class=\"title\">" + (node.$title()) + "</div>");
        }        if ($truthy(node.$document()['$attr?']("icons"))) {
          
          result['$<<']("<table>");
          $a = [node.$document()['$attr?']("icons", "font"), 0], (font_icons = $a[0]), (num = $a[1]);
          $send(node.$items(), 'each', [], function $$5(item){var self = $$5.$$s == null ? this : $$5.$$s, num_label = nil;
            if (self.void_element_slash == null) self.void_element_slash = nil;

            
            if (item == null) item = nil;
            num = $rb_plus(num, 1);
            if ($truthy(font_icons)) {
              num_label = "<i class=\"conum\" data-value=\"" + (num) + "\"></i><b>" + (num) + "</b>";
            } else {
              num_label = "<img src=\"" + (node.$icon_uri("callouts/" + (num))) + "\" alt=\"" + (num) + "\"" + (self.void_element_slash) + ">";
            }            return result['$<<']("<tr>\n" + "<td>" + (num_label) + "</td>\n" + "<td>" + (item.$text()) + (($truthy(item['$blocks?']()) ? ($rb_plus($$('LF'), item.$content())) : (""))) + "</td>\n" + "</tr>");}, {$$s: self});
          result['$<<']("</table>");
        } else {
          
          result['$<<']("<ol>");
          $send(node.$items(), 'each', [], function $$6(item){
            
            if (item == null) item = nil;
            return result['$<<']("<li>\n" + "<p>" + (item.$text()) + "</p>" + (($truthy(item['$blocks?']()) ? ($rb_plus($$('LF'), item.$content())) : (""))) + "\n" + "</li>");});
          result['$<<']("</ol>");
        }        result['$<<']("</div>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_dlist', function $$convert_dlist(node) {
        var self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, slash = nil, col_style_attribute = nil, dt_style_attribute = nil;

        
        result = [];
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        
        switch (node.$style()) {
          case "qanda":
            classes = ["qlist", "qanda", node.$role()];
            break;
          case "horizontal":
            classes = ["hdlist", node.$role()];
            break;
          default:
            classes = ["dlist", node.$style(), node.$role()];
        }        class_attribute = " class=\"" + (classes.$compact().$join(" ")) + "\"";
        result['$<<']("<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("<div class=\"title\">" + (node.$title()) + "</div>");
        }        
        switch (node.$style()) {
          case "qanda":
            
            result['$<<']("<ol>");
            $send(node.$items(), 'each', [], function $$7(terms, dd){
              
              if (terms == null) terms = nil;
              if (dd == null) dd = nil;
              result['$<<']("<li>");
              $send(terms, 'each', [], function $$8(dt){
                
                if (dt == null) dt = nil;
                return result['$<<']("<p><em>" + (dt.$text()) + "</em></p>");});
              if ($truthy(dd)) {
                
                if ($truthy(dd['$text?']())) {
                  result['$<<']("<p>" + (dd.$text()) + "</p>");
                }                if ($truthy(dd['$blocks?']())) {
                  result['$<<'](dd.$content());
                }              }              return result['$<<']("</li>");});
            result['$<<']("</ol>");
            break;
          case "horizontal":
            
            slash = self.void_element_slash;
            result['$<<']("<table>");
            if (($truthy(node['$attr?']("labelwidth")) || ($truthy(node['$attr?']("itemwidth"))))) {
              
              result['$<<']("<colgroup>");
              col_style_attribute = ($truthy(node['$attr?']("labelwidth")) ? (" style=\"width: " + (node.$attr("labelwidth").$chomp("%")) + "%;\"") : (""));
              result['$<<']("<col" + (col_style_attribute) + (slash) + ">");
              col_style_attribute = ($truthy(node['$attr?']("itemwidth")) ? (" style=\"width: " + (node.$attr("itemwidth").$chomp("%")) + "%;\"") : (""));
              result['$<<']("<col" + (col_style_attribute) + (slash) + ">");
              result['$<<']("</colgroup>");
            }            $send(node.$items(), 'each', [], function $$9(terms, dd){var first_term = nil;

              
              if (terms == null) terms = nil;
              if (dd == null) dd = nil;
              result['$<<']("<tr>");
              result['$<<']("<td class=\"hdlist1" + (($truthy(node['$option?']("strong")) ? (" strong") : (""))) + "\">");
              first_term = true;
              $send(terms, 'each', [], function $$10(dt){
                
                if (dt == null) dt = nil;
                if (!$truthy(first_term)) {
                  result['$<<']("<br" + (slash) + ">");
                }                result['$<<'](dt.$text());
                return (first_term = nil);});
              result['$<<']("</td>");
              result['$<<']("<td class=\"hdlist2\">");
              if ($truthy(dd)) {
                
                if ($truthy(dd['$text?']())) {
                  result['$<<']("<p>" + (dd.$text()) + "</p>");
                }                if ($truthy(dd['$blocks?']())) {
                  result['$<<'](dd.$content());
                }              }              result['$<<']("</td>");
              return result['$<<']("</tr>");});
            result['$<<']("</table>");
            break;
          default:
            
            result['$<<']("<dl>");
            dt_style_attribute = ($truthy(node.$style()) ? ("") : (" class=\"hdlist1\""));
            $send(node.$items(), 'each', [], function $$11(terms, dd){
              
              if (terms == null) terms = nil;
              if (dd == null) dd = nil;
              $send(terms, 'each', [], function $$12(dt){
                
                if (dt == null) dt = nil;
                return result['$<<']("<dt" + (dt_style_attribute) + ">" + (dt.$text()) + "</dt>");});
              if (!$truthy(dd)) {
                return nil
              }              result['$<<']("<dd>");
              if ($truthy(dd['$text?']())) {
                result['$<<']("<p>" + (dd.$text()) + "</p>");
              }              if ($truthy(dd['$blocks?']())) {
                result['$<<'](dd.$content());
              }              return result['$<<']("</dd>");});
            result['$<<']("</dl>");
        }        result['$<<']("</div>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_example', function $$convert_example(node) {
        var id_attribute = nil, class_attribute = nil, summary_element = nil, title_element = nil, role = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        if ($truthy(node['$option?']("collapsible"))) {
          
          class_attribute = ($truthy(node.$role()) ? (" class=\"" + (node.$role()) + "\"") : (""));
          summary_element = ($truthy(node['$title?']()) ? ("<summary class=\"title\">" + (node.$title()) + "</summary>") : ("<summary class=\"title\">Details</summary>"));
          return "<details" + (id_attribute) + (class_attribute) + (($truthy(node['$option?']("open")) ? (" open") : (""))) + ">\n" + (summary_element) + "\n" + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</details>";
        } else {
          
          title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$captioned_title()) + "</div>\n") : (""));
          return "<div" + (id_attribute) + " class=\"exampleblock" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_element) + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</div>";
        }      });
      
      $def(self, '$convert_floating_title', function $$convert_floating_title(node) {
        var tag_name = nil, id_attribute = nil, classes = nil;

        
        tag_name = "h" + ($rb_plus(node.$level(), 1));
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = [node.$style(), node.$role()].$compact();
        return "<" + (tag_name) + (id_attribute) + " class=\"" + (classes.$join(" ")) + "\">" + (node.$title()) + "</" + (tag_name) + ">";
      });
      
      $def(self, '$convert_image', function $$convert_image(node) {
        var self = this, target = nil, width_attr = nil, height_attr = nil, img = nil, $ret_or_1 = nil, fallback = nil, id_attr = nil, classes = nil, class_attr = nil, title_el = nil;

        
        target = node.$attr("target");
        width_attr = ($truthy(node['$attr?']("width")) ? (" width=\"" + (node.$attr("width")) + "\"") : (""));
        height_attr = ($truthy(node['$attr?']("height")) ? (" height=\"" + (node.$attr("height")) + "\"") : (""));
        if ((($truthy(node['$attr?']("format", "svg")) || ($truthy(target['$include?'](".svg")))) && ($truthy($rb_lt(node.$document().$safe(), $$$($$('SafeMode'), 'SECURE')))))) {
          if ($truthy(node['$option?']("inline"))) {
            img = ($truthy(($ret_or_1 = self.$read_svg_contents(node, target))) ? ($ret_or_1) : ("<span class=\"alt\">" + (node.$alt()) + "</span>"));
          } else if ($truthy(node['$option?']("interactive"))) {
            
            fallback = ($truthy(node['$attr?']("fallback")) ? ("<img src=\"" + (node.$image_uri(node.$attr("fallback"))) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">") : ("<span class=\"alt\">" + (node.$alt()) + "</span>"));
            img = "<object type=\"image/svg+xml\" data=\"" + (node.$image_uri(target)) + "\"" + (width_attr) + (height_attr) + ">" + (fallback) + "</object>";
          } else {
            img = "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">";
          }
        } else {
          img = "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (width_attr) + (height_attr) + (self.void_element_slash) + ">";
        }        if ($truthy(node['$attr?']("link"))) {
          img = "<a class=\"image\" href=\"" + (node.$attr("link")) + "\"" + (self.$append_link_constraint_attrs(node).$join()) + ">" + (img) + "</a>";
        }        id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["imageblock"];
        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"));
        }        if ($truthy(node['$attr?']("align"))) {
          classes['$<<']("text-" + (node.$attr("align")));
        }        if ($truthy(node.$role())) {
          classes['$<<'](node.$role());
        }        class_attr = " class=\"" + (classes.$join(" ")) + "\"";
        title_el = ($truthy(node['$title?']()) ? ("\n<div class=\"title\">" + (node.$captioned_title()) + "</div>") : (""));
        return "<div" + (id_attr) + (class_attr) + ">\n" + "<div class=\"content\">\n" + (img) + "\n" + "</div>" + (title_el) + "\n" + "</div>";
      });
      
      $def(self, '$convert_listing', function $$convert_listing(node) {
        var nowrap = nil, $ret_or_1 = nil, lang = nil, syntax_hl = nil, opts = nil, doc_attrs = nil, pre_open = nil, pre_close = nil, id_attribute = nil, title_element = nil, role = nil;

        
        nowrap = ($truthy(($ret_or_1 = node['$option?']("nowrap"))) ? ($ret_or_1) : (node.$document()['$attr?']("prewrap")['$!']()));
        if ($eqeq(node.$style(), "source")) {
          
          lang = node.$attr("language");
          if ($truthy((syntax_hl = node.$document().$syntax_highlighter()))) {
            
            opts = ($truthy(syntax_hl['$highlight?']()) ? ($hash2(["css_mode", "style"], {"css_mode": ($truthy(($ret_or_1 = (doc_attrs = node.$document().$attributes())['$[]']("" + (syntax_hl.$name()) + "-css"))) ? ($ret_or_1) : ("class")).$to_sym(), "style": doc_attrs['$[]']("" + (syntax_hl.$name()) + "-style")})) : ($hash2([], {})));
            opts['$[]=']("nowrap", nowrap);
          } else {
            
            pre_open = "<pre class=\"highlight" + (($truthy(nowrap) ? (" nowrap") : (""))) + "\"><code" + (($truthy(lang) ? (" class=\"language-" + (lang) + "\" data-lang=\"" + (lang) + "\"") : (""))) + ">";
            pre_close = "</code></pre>";
          }        } else {
          
          pre_open = "<pre" + (($truthy(nowrap) ? (" class=\"nowrap\"") : (""))) + ">";
          pre_close = "</pre>";
        }        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$captioned_title()) + "</div>\n") : (""));
        return "<div" + (id_attribute) + " class=\"listingblock" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_element) + "<div class=\"content\">\n" + (($truthy(syntax_hl) ? (syntax_hl.$format(node, lang, opts)) : ($rb_plus($rb_plus(pre_open, node.$content()), pre_close)))) + "\n" + "</div>\n" + "</div>";
      });
      
      $def(self, '$convert_literal', function $$convert_literal(node) {
        var id_attribute = nil, title_element = nil, nowrap = nil, $ret_or_1 = nil, role = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
        nowrap = ($truthy(($ret_or_1 = node.$document()['$attr?']("prewrap")['$!']())) ? ($ret_or_1) : (node['$option?']("nowrap")));
        return "<div" + (id_attribute) + " class=\"literalblock" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_element) + "<div class=\"content\">\n" + "<pre" + (($truthy(nowrap) ? (" class=\"nowrap\"") : (""))) + ">" + (node.$content()) + "</pre>\n" + "</div>\n" + "</div>";
      });
      
      $def(self, '$convert_stem', function $$convert_stem(node) {
        var $a, $b, self = this, id_attribute = nil, title_element = nil, style = nil, open = nil, close = nil, equation = nil, br = nil, role = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
        $b = $$('BLOCK_MATH_DELIMITERS')['$[]']((style = node.$style().$to_sym())), $a = $to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1]));
        if ($truthy((equation = node.$content()))) {
          
          if (($eqeq(style, "asciimath") && ($truthy(equation['$include?']($$('LF')))))) {
            
            br = "" + ($$('LF')) + "<br" + (self.void_element_slash) + ">";
            equation = $send(equation, 'gsub', [$$('StemBreakRx')], function $$13(){var $c;

              return "" + (close) + ($rb_times(br, $rb_minus((($c = $gvars['~']) === nil ? nil : $c['$[]'](0)).$count($$('LF')), 1))) + ($$('LF')) + (open)});
          }          if (!($truthy(equation['$start_with?'](open)) && ($truthy(equation['$end_with?'](close))))) {
            equation = "" + (open) + (equation) + (close);
          }        } else {
          equation = "";
        }        return "<div" + (id_attribute) + " class=\"stemblock" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_element) + "<div class=\"content\">\n" + (equation) + "\n" + "</div>\n" + "</div>";
      });
      
      $def(self, '$convert_olist', function $$convert_olist(node) {
        var self = this, result = nil, id_attribute = nil, classes = nil, class_attribute = nil, type_attribute = nil, keyword = nil, start_attribute = nil, reversed_attribute = nil;

        
        result = [];
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["olist", node.$style(), node.$role()].$compact();
        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("<div" + (id_attribute) + (class_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("<div class=\"title\">" + (node.$title()) + "</div>");
        }        type_attribute = ($truthy((keyword = node.$list_marker_keyword())) ? (" type=\"" + (keyword) + "\"") : (""));
        start_attribute = ($truthy(node['$attr?']("start")) ? (" start=\"" + (node.$attr("start")) + "\"") : (""));
        reversed_attribute = ($truthy(node['$option?']("reversed")) ? (self.$append_boolean_attribute("reversed", self.xml_mode)) : (""));
        result['$<<']("<ol class=\"" + (node.$style()) + "\"" + (type_attribute) + (start_attribute) + (reversed_attribute) + ">");
        $send(node.$items(), 'each', [], function $$14(item){
          
          if (item == null) item = nil;
          if ($truthy(item.$id())) {
            result['$<<']("<li id=\"" + (item.$id()) + "\"" + (($truthy(item.$role()) ? (" class=\"" + (item.$role()) + "\"") : (""))) + ">");
          } else if ($truthy(item.$role())) {
            result['$<<']("<li class=\"" + (item.$role()) + "\">");
          } else {
            result['$<<']("<li>");
          }          result['$<<']("<p>" + (item.$text()) + "</p>");
          if ($truthy(item['$blocks?']())) {
            result['$<<'](item.$content());
          }          return result['$<<']("</li>");});
        result['$<<']("</ol>");
        result['$<<']("</div>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_open', function $$convert_open(node) {
        var self = this, style = nil, id_attr = nil, title_el = nil, role = nil;

        if ($eqeq((style = node.$style()), "abstract")) {
          if (($eqeq(node.$parent(), node.$document()) && ($eqeq(node.$document().$doctype(), "book")))) {
            
            self.$logger().$warn("abstract block cannot be used in a document without a title when doctype is book. Excluding block content.");
            return "";
          } else {
            
            id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
            title_el = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
            return "<div" + (id_attr) + " class=\"quoteblock abstract" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_el) + "<blockquote>\n" + (node.$content()) + "\n" + "</blockquote>\n" + "</div>";
          }
        } else if (($eqeq(style, "partintro") && ((($truthy($rb_gt(node.$level(), 0)) || ($neqeq(node.$parent().$context(), "section"))) || ($neqeq(node.$document().$doctype(), "book")))))) {
          
          self.$logger().$error("partintro block can only be used when doctype is book and must be a child of a book part. Excluding block content.");
          return "";
        } else {
          
          id_attr = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
          title_el = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
          return "<div" + (id_attr) + " class=\"openblock" + ((($truthy(style) && ($neqeq(style, "open"))) ? (" " + (style)) : (""))) + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + (title_el) + "<div class=\"content\">\n" + (node.$content()) + "\n" + "</div>\n" + "</div>";
        }
      });
      
      $def(self, '$convert_page_break', $return_val("<div style=\"page-break-after: always;\"></div>"));
      
      $def(self, '$convert_paragraph', function $$convert_paragraph(node) {
        var attributes = nil;

        
        if ($truthy(node.$role())) {
          attributes = "" + (($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""))) + " class=\"paragraph " + (node.$role()) + "\"";
        } else if ($truthy(node.$id())) {
          attributes = " id=\"" + (node.$id()) + "\" class=\"paragraph\"";
        } else {
          attributes = " class=\"paragraph\"";
        }        if ($truthy(node['$title?']())) {
          return "<div" + (attributes) + ">\n" + "<div class=\"title\">" + (node.$title()) + "</div>\n" + "<p>" + (node.$content()) + "</p>\n" + "</div>"
        } else {
          return "<div" + (attributes) + ">\n" + "<p>" + (node.$content()) + "</p>\n" + "</div>"
        }      });
      $alias(self, "convert_pass", "content_only");
      
      $def(self, '$convert_preamble', function $$convert_preamble(node) {
        var doc = nil, toc = nil;

        
        if ((($truthy((doc = node.$document())['$attr?']("toc-placement", "preamble")) && ($truthy(doc['$sections?']()))) && ($truthy(doc['$attr?']("toc"))))) {
          toc = "\n" + "<div id=\"toc\" class=\"" + (doc.$attr("toc-class", "toc")) + "\">\n" + "<div id=\"toctitle\">" + (doc.$attr("toc-title")) + "</div>\n" + (doc.$converter().$convert(doc, "outline")) + "\n" + "</div>";
        } else {
          toc = "";
        }        return "<div id=\"preamble\">\n" + "<div class=\"sectionbody\">\n" + (node.$content()) + "\n" + "</div>" + (toc) + "\n" + "</div>";
      });
      
      $def(self, '$convert_quote', function $$convert_quote(node) {
        var self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["quoteblock", node.$role()].$compact();
        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        title_element = ($truthy(node['$title?']()) ? ("\n<div class=\"title\">" + (node.$title()) + "</div>") : (""));
        attribution = ($truthy(node['$attr?']("attribution")) ? (node.$attr("attribution")) : (nil));
        citetitle = ($truthy(node['$attr?']("citetitle")) ? (node.$attr("citetitle")) : (nil));
        if (($truthy(attribution) || ($truthy(citetitle)))) {
          
          cite_element = ($truthy(citetitle) ? ("<cite>" + (citetitle) + "</cite>") : (""));
          attribution_text = ($truthy(attribution) ? ("&#8212; " + (attribution) + (($truthy(citetitle) ? ("<br" + (self.void_element_slash) + ">\n") : ("")))) : (""));
          attribution_element = "\n<div class=\"attribution\">\n" + (attribution_text) + (cite_element) + "\n</div>";
        } else {
          attribution_element = "";
        }        return "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<blockquote>\n" + (node.$content()) + "\n" + "</blockquote>" + (attribution_element) + "\n" + "</div>";
      });
      
      $def(self, '$convert_thematic_break', function $$convert_thematic_break(node) {
        var self = this;

        return "<hr" + (self.void_element_slash) + ">"
      });
      
      $def(self, '$convert_sidebar', function $$convert_sidebar(node) {
        var id_attribute = nil, title_element = nil, role = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        title_element = ($truthy(node['$title?']()) ? ("<div class=\"title\">" + (node.$title()) + "</div>\n") : (""));
        return "<div" + (id_attribute) + " class=\"sidebarblock" + (($truthy((role = node.$role())) ? (" " + (role)) : (""))) + "\">\n" + "<div class=\"content\">\n" + (title_element) + (node.$content()) + "\n" + "</div>\n" + "</div>";
      });
      
      $def(self, '$convert_table', function $$convert_table(node) {
        var self = this, result = nil, id_attribute = nil, frame = nil, classes = nil, stripes = nil, style_attribute = nil, autowidth = nil, tablewidth = nil, role = nil, class_attribute = nil, slash = nil;

        
        result = [];
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        if ($eqeq((frame = node.$attr("frame", "all", "table-frame")), "topbot")) {
          frame = "ends";
        }        classes = ["tableblock", "frame-" + (frame), "grid-" + (node.$attr("grid", "all", "table-grid"))];
        if ($truthy((stripes = node.$attr("stripes", nil, "table-stripes")))) {
          classes['$<<']("stripes-" + (stripes));
        }        style_attribute = "";
        if (($truthy((autowidth = node['$option?']("autowidth"))) && ($not(node['$attr?']("width"))))) {
          classes['$<<']("fit-content");
        } else if ($eqeq((tablewidth = node.$attr("tablepcwidth")), 100)) {
          classes['$<<']("stretch");
        } else {
          style_attribute = " style=\"width: " + (tablewidth) + "%;\"";
        }        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"));
        }        if ($truthy((role = node.$role()))) {
          classes['$<<'](role);
        }        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        result['$<<']("<table" + (id_attribute) + (class_attribute) + (style_attribute) + ">");
        if ($truthy(node['$title?']())) {
          result['$<<']("<caption class=\"title\">" + (node.$captioned_title()) + "</caption>");
        }        if ($truthy($rb_gt(node.$attr("rowcount"), 0))) {
          
          slash = self.void_element_slash;
          result['$<<']("<colgroup>");
          if ($truthy(autowidth)) {
            result = $rb_plus(result, $$('Array').$new(node.$columns().$size(), "<col" + (slash) + ">"));
          } else {
            $send(node.$columns(), 'each', [], function $$15(col){
              
              if (col == null) col = nil;
              return result['$<<'](($truthy(col['$option?']("autowidth")) ? ("<col" + (slash) + ">") : ("<col style=\"width: " + (col.$attr("colpcwidth")) + "%;\"" + (slash) + ">")));});
          }          result['$<<']("</colgroup>");
          $send(node.$rows().$to_h(), 'each', [], function $$16(tsec, rows){
            
            if (tsec == null) tsec = nil;
            if (rows == null) rows = nil;
            if ($truthy(rows['$empty?']())) {
              return nil
            }            result['$<<']("<t" + (tsec) + ">");
            $send(rows, 'each', [], function $$17(row){
              
              if (row == null) row = nil;
              result['$<<']("<tr>");
              $send(row, 'each', [], function $$18(cell){var cell_content = nil, cell_tag_name = nil, cell_class_attribute = nil, cell_colspan_attribute = nil, cell_rowspan_attribute = nil, cell_style_attribute = nil;

                
                if (cell == null) cell = nil;
                if ($eqeq(tsec, "head")) {
                  cell_content = cell.$text();
                } else 
                switch (cell.$style()) {
                  case "asciidoc":
                    cell_content = "<div class=\"content\">" + (cell.$content()) + "</div>";
                    break;
                  case "literal":
                    cell_content = "<div class=\"literal\"><pre>" + (cell.$text()) + "</pre></div>";
                    break;
                  default:
                    cell_content = ($truthy((cell_content = cell.$content())['$empty?']()) ? ("") : ("<p class=\"tableblock\">" + (cell_content.$join("</p>\n" + "<p class=\"tableblock\">")) + "</p>"));
                }                cell_tag_name = (($eqeq(tsec, "head") || ($eqeq(cell.$style(), "header"))) ? ("th") : ("td"));
                cell_class_attribute = " class=\"tableblock halign-" + (cell.$attr("halign")) + " valign-" + (cell.$attr("valign")) + "\"";
                cell_colspan_attribute = ($truthy(cell.$colspan()) ? (" colspan=\"" + (cell.$colspan()) + "\"") : (""));
                cell_rowspan_attribute = ($truthy(cell.$rowspan()) ? (" rowspan=\"" + (cell.$rowspan()) + "\"") : (""));
                cell_style_attribute = ($truthy(node.$document()['$attr?']("cellbgcolor")) ? (" style=\"background-color: " + (node.$document().$attr("cellbgcolor")) + ";\"") : (""));
                return result['$<<']("<" + (cell_tag_name) + (cell_class_attribute) + (cell_colspan_attribute) + (cell_rowspan_attribute) + (cell_style_attribute) + ">" + (cell_content) + "</" + (cell_tag_name) + ">");});
              return result['$<<']("</tr>");});
            return result['$<<']("</t" + (tsec) + ">");});
        }        result['$<<']("</table>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_toc', function $$convert_toc(node) {
        var doc = nil, id_attr = nil, title_id_attr = nil, title = nil, levels = nil, role = nil;

        
        if (!(($truthy((doc = node.$document())['$attr?']("toc-placement", "macro")) && ($truthy(doc['$sections?']()))) && ($truthy(doc['$attr?']("toc"))))) {
          return "<!-- toc disabled -->"
        }        if ($truthy(node.$id())) {
          
          id_attr = " id=\"" + (node.$id()) + "\"";
          title_id_attr = " id=\"" + (node.$id()) + "title\"";
        } else {
          
          id_attr = " id=\"toc\"";
          title_id_attr = " id=\"toctitle\"";
        }        title = ($truthy(node['$title?']()) ? (node.$title()) : (doc.$attr("toc-title")));
        levels = ($truthy(node['$attr?']("levels")) ? (node.$attr("levels").$to_i()) : (nil));
        role = ($truthy(node['$role?']()) ? (node.$role()) : (doc.$attr("toc-class", "toc")));
        return "<div" + (id_attr) + " class=\"" + (role) + "\">\n" + "<div" + (title_id_attr) + " class=\"title\">" + (title) + "</div>\n" + (doc.$converter().$convert(doc, "outline", $hash2(["toclevels"], {"toclevels": levels}))) + "\n" + "</div>";
      });
      
      $def(self, '$convert_ulist', function $$convert_ulist(node) {
        var self = this, result = nil, id_attribute = nil, div_classes = nil, marker_checked = nil, marker_unchecked = nil, checklist = nil, ul_class_attribute = nil;

        
        result = [];
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        div_classes = ["ulist", node.$style(), node.$role()].$compact();
        marker_checked = (marker_unchecked = "");
        if ($truthy((checklist = node['$option?']("checklist")))) {
          
          div_classes.$unshift(div_classes.$shift(), "checklist");
          ul_class_attribute = " class=\"checklist\"";
          if ($truthy(node['$option?']("interactive"))) {
            if ($truthy(self.xml_mode)) {
              
              marker_checked = "<input type=\"checkbox\" data-item-complete=\"1\" checked=\"checked\"/> ";
              marker_unchecked = "<input type=\"checkbox\" data-item-complete=\"0\"/> ";
            } else {
              
              marker_checked = "<input type=\"checkbox\" data-item-complete=\"1\" checked> ";
              marker_unchecked = "<input type=\"checkbox\" data-item-complete=\"0\"> ";
            }
          } else if ($truthy(node.$document()['$attr?']("icons", "font"))) {
            
            marker_checked = "<i class=\"fa fa-check-square-o\"></i> ";
            marker_unchecked = "<i class=\"fa fa-square-o\"></i> ";
          } else {
            
            marker_checked = "&#10003; ";
            marker_unchecked = "&#10063; ";
          }        } else {
          ul_class_attribute = ($truthy(node.$style()) ? (" class=\"" + (node.$style()) + "\"") : (""));
        }        result['$<<']("<div" + (id_attribute) + " class=\"" + (div_classes.$join(" ")) + "\">");
        if ($truthy(node['$title?']())) {
          result['$<<']("<div class=\"title\">" + (node.$title()) + "</div>");
        }        result['$<<']("<ul" + (ul_class_attribute) + ">");
        $send(node.$items(), 'each', [], function $$19(item){
          
          if (item == null) item = nil;
          if ($truthy(item.$id())) {
            result['$<<']("<li id=\"" + (item.$id()) + "\"" + (($truthy(item.$role()) ? (" class=\"" + (item.$role()) + "\"") : (""))) + ">");
          } else if ($truthy(item.$role())) {
            result['$<<']("<li class=\"" + (item.$role()) + "\">");
          } else {
            result['$<<']("<li>");
          }          if (($truthy(checklist) && ($truthy(item['$attr?']("checkbox"))))) {
            result['$<<']("<p>" + (($truthy(item['$attr?']("checked")) ? (marker_checked) : (marker_unchecked))) + (item.$text()) + "</p>");
          } else {
            result['$<<']("<p>" + (item.$text()) + "</p>");
          }          if ($truthy(item['$blocks?']())) {
            result['$<<'](item.$content());
          }          return result['$<<']("</li>");});
        result['$<<']("</ul>");
        result['$<<']("</div>");
        return result.$join($$('LF'));
      });
      
      $def(self, '$convert_verse', function $$convert_verse(node) {
        var self = this, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, attribution = nil, citetitle = nil, cite_element = nil, attribution_text = nil, attribution_element = nil;

        
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["verseblock", node.$role()].$compact();
        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        title_element = ($truthy(node['$title?']()) ? ("\n<div class=\"title\">" + (node.$title()) + "</div>") : (""));
        attribution = ($truthy(node['$attr?']("attribution")) ? (node.$attr("attribution")) : (nil));
        citetitle = ($truthy(node['$attr?']("citetitle")) ? (node.$attr("citetitle")) : (nil));
        if (($truthy(attribution) || ($truthy(citetitle)))) {
          
          cite_element = ($truthy(citetitle) ? ("<cite>" + (citetitle) + "</cite>") : (""));
          attribution_text = ($truthy(attribution) ? ("&#8212; " + (attribution) + (($truthy(citetitle) ? ("<br" + (self.void_element_slash) + ">\n") : ("")))) : (""));
          attribution_element = "\n<div class=\"attribution\">\n" + (attribution_text) + (cite_element) + "\n</div>";
        } else {
          attribution_element = "";
        }        return "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<pre class=\"content\">" + (node.$content()) + "</pre>" + (attribution_element) + "\n" + "</div>";
      });
      
      $def(self, '$convert_video', function $$convert_video(node) {
        var $a, $b, self = this, xml = nil, id_attribute = nil, classes = nil, class_attribute = nil, title_element = nil, width_attribute = nil, height_attribute = nil, asset_uri_scheme = nil, start_anchor = nil, delimiter = nil, target = nil, hash = nil, hash_param = nil, $ret_or_2 = nil, autoplay_param = nil, loop_param = nil, muted_param = nil, rel_param_val = nil, start_param = nil, end_param = nil, has_loop_param = nil, mute_param = nil, controls_param = nil, fs_param = nil, fs_attribute = nil, modest_param = nil, theme_param = nil, hl_param = nil, list = nil, list_param = nil, playlist = nil, poster_attribute = nil, val = nil, preload_attribute = nil, start_t = nil, end_t = nil, time_anchor = nil;

        
        xml = self.xml_mode;
        id_attribute = ($truthy(node.$id()) ? (" id=\"" + (node.$id()) + "\"") : (""));
        classes = ["videoblock"];
        if ($truthy(node['$attr?']("float"))) {
          classes['$<<'](node.$attr("float"));
        }        if ($truthy(node['$attr?']("align"))) {
          classes['$<<']("text-" + (node.$attr("align")));
        }        if ($truthy(node.$role())) {
          classes['$<<'](node.$role());
        }        class_attribute = " class=\"" + (classes.$join(" ")) + "\"";
        title_element = ($truthy(node['$title?']()) ? ("\n<div class=\"title\">" + (node.$title()) + "</div>") : (""));
        width_attribute = ($truthy(node['$attr?']("width")) ? (" width=\"" + (node.$attr("width")) + "\"") : (""));
        height_attribute = ($truthy(node['$attr?']("height")) ? (" height=\"" + (node.$attr("height")) + "\"") : (""));
        
        switch (node.$attr("poster")) {
          case "vimeo":
            
            if (!$truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))['$empty?']())) {
              asset_uri_scheme = "" + (asset_uri_scheme) + ":";
            }            start_anchor = ($truthy(node['$attr?']("start")) ? ("#at=" + (node.$attr("start"))) : (""));
            delimiter = ["?"];
            $b = node.$attr("target").$split("/", 2), $a = $to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (hash = ($a[1] == null ? nil : $a[1]));
            hash_param = ($truthy((hash = ($truthy(($ret_or_2 = hash)) ? ($ret_or_2) : (node.$attr("hash"))))) ? ("" + (($truthy(($ret_or_2 = delimiter.$pop())) ? ($ret_or_2) : ("&amp;"))) + "h=" + (hash)) : (""));
            autoplay_param = ($truthy(node['$option?']("autoplay")) ? ("" + (($truthy(($ret_or_2 = delimiter.$pop())) ? ($ret_or_2) : ("&amp;"))) + "autoplay=1") : (""));
            loop_param = ($truthy(node['$option?']("loop")) ? ("" + (($truthy(($ret_or_2 = delimiter.$pop())) ? ($ret_or_2) : ("&amp;"))) + "loop=1") : (""));
            muted_param = ($truthy(node['$option?']("muted")) ? ("" + (($truthy(($ret_or_2 = delimiter.$pop())) ? ($ret_or_2) : ("&amp;"))) + "muted=1") : (""));
            return "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<iframe" + (width_attribute) + (height_attribute) + " src=\"" + (asset_uri_scheme) + "//player.vimeo.com/video/" + (target) + (hash_param) + (autoplay_param) + (loop_param) + (muted_param) + (start_anchor) + "\" frameborder=\"0\"" + (($truthy(node['$option?']("nofullscreen")) ? ("") : (self.$append_boolean_attribute("allowfullscreen", xml)))) + "></iframe>\n" + "</div>\n" + "</div>";
          case "youtube":
            
            if (!$truthy((asset_uri_scheme = node.$document().$attr("asset-uri-scheme", "https"))['$empty?']())) {
              asset_uri_scheme = "" + (asset_uri_scheme) + ":";
            }            rel_param_val = ($truthy(node['$option?']("related")) ? (1) : (0));
            start_param = ($truthy(node['$attr?']("start")) ? ("&amp;start=" + (node.$attr("start"))) : (""));
            end_param = ($truthy(node['$attr?']("end")) ? ("&amp;end=" + (node.$attr("end"))) : (""));
            autoplay_param = ($truthy(node['$option?']("autoplay")) ? ("&amp;autoplay=1") : (""));
            loop_param = ($truthy((has_loop_param = node['$option?']("loop"))) ? ("&amp;loop=1") : (""));
            mute_param = ($truthy(node['$option?']("muted")) ? ("&amp;mute=1") : (""));
            controls_param = ($truthy(node['$option?']("nocontrols")) ? ("&amp;controls=0") : (""));
            if ($truthy(node['$option?']("nofullscreen"))) {
              
              fs_param = "&amp;fs=0";
              fs_attribute = "";
            } else {
              
              fs_param = "";
              fs_attribute = self.$append_boolean_attribute("allowfullscreen", xml);
            }            modest_param = ($truthy(node['$option?']("modest")) ? ("&amp;modestbranding=1") : (""));
            theme_param = ($truthy(node['$attr?']("theme")) ? ("&amp;theme=" + (node.$attr("theme"))) : (""));
            hl_param = ($truthy(node['$attr?']("lang")) ? ("&amp;hl=" + (node.$attr("lang"))) : (""));
            $b = node.$attr("target").$split("/", 2), $a = $to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (list = ($a[1] == null ? nil : $a[1]));
            if ($truthy((list = ($truthy(($ret_or_2 = list)) ? ($ret_or_2) : (node.$attr("list")))))) {
              list_param = "&amp;list=" + (list);
            } else {
              
              $b = target.$split(",", 2), $a = $to_ary($b), (target = ($a[0] == null ? nil : $a[0])), (playlist = ($a[1] == null ? nil : $a[1]));
              if ($truthy((playlist = ($truthy(($ret_or_2 = playlist)) ? ($ret_or_2) : (node.$attr("playlist")))))) {
                list_param = "&amp;playlist=" + (target) + "," + (playlist);
              } else {
                list_param = ($truthy(has_loop_param) ? ("&amp;playlist=" + (target)) : (""));
              }            }            return "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<iframe" + (width_attribute) + (height_attribute) + " src=\"" + (asset_uri_scheme) + "//www.youtube.com/embed/" + (target) + "?rel=" + (rel_param_val) + (start_param) + (end_param) + (autoplay_param) + (loop_param) + (mute_param) + (controls_param) + (list_param) + (fs_param) + (modest_param) + (theme_param) + (hl_param) + "\" frameborder=\"0\"" + (fs_attribute) + "></iframe>\n" + "</div>\n" + "</div>";
          default:
            
            poster_attribute = ($truthy((val = node.$attr("poster"))['$nil_or_empty?']()) ? ("") : (" poster=\"" + (node.$media_uri(val)) + "\""));
            preload_attribute = ($truthy((val = node.$attr("preload"))['$nil_or_empty?']()) ? ("") : (" preload=\"" + (val) + "\""));
            start_t = node.$attr("start");
            end_t = node.$attr("end");
            time_anchor = (($truthy(start_t) || ($truthy(end_t))) ? ("#t=" + (($truthy(($ret_or_2 = start_t)) ? ($ret_or_2) : (""))) + (($truthy(end_t) ? ("," + (end_t)) : ("")))) : (""));
            return "<div" + (id_attribute) + (class_attribute) + ">" + (title_element) + "\n" + "<div class=\"content\">\n" + "<video src=\"" + (node.$media_uri(node.$attr("target"))) + (time_anchor) + "\"" + (width_attribute) + (height_attribute) + (poster_attribute) + (($truthy(node['$option?']("autoplay")) ? (self.$append_boolean_attribute("autoplay", xml)) : (""))) + (($truthy(node['$option?']("muted")) ? (self.$append_boolean_attribute("muted", xml)) : (""))) + (($truthy(node['$option?']("nocontrols")) ? ("") : (self.$append_boolean_attribute("controls", xml)))) + (($truthy(node['$option?']("loop")) ? (self.$append_boolean_attribute("loop", xml)) : (""))) + (preload_attribute) + ">\n" + "Your browser does not support the video tag.\n" + "</video>\n" + "</div>\n" + "</div>";
        }      });
      
      $def(self, '$convert_inline_anchor', function $$convert_inline_anchor(node) {
        var self = this, path = nil, attrs = nil, text = nil, $ret_or_2 = nil, ref = nil, $ret_or_3 = nil, refid = nil, top = nil, outer = nil;

        
        switch (node.$type()) {
          case "xref":
            
            if ($truthy((path = node.$attributes()['$[]']("path")))) {
              
              attrs = self.$append_link_constraint_attrs(node, ($truthy(node.$role()) ? ([" class=\"" + (node.$role()) + "\""]) : ([]))).$join();
              text = ($truthy(($ret_or_2 = node.$text())) ? ($ret_or_2) : (path));
            } else {
              
              attrs = ($truthy(node.$role()) ? (" class=\"" + (node.$role()) + "\"") : (""));
              if (!$truthy((text = node.$text()))) {
                if ($eqeqeq($$('AbstractNode'), (ref = ($truthy(($ret_or_2 = (self.refs = ($truthy(($ret_or_3 = self.refs)) ? ($ret_or_3) : (node.$document().$catalog()['$[]']("refs"))))['$[]']((refid = node.$attributes()['$[]']("refid"))))) ? ($ret_or_2) : (($truthy(refid['$nil_or_empty?']()) ? ((top = self.$get_root_document(node))) : (nil))))))) {
                  if (($truthy((self.resolving_xref = ($truthy(($ret_or_2 = self.resolving_xref)) ? ($ret_or_2) : ((outer = true))))) && ($truthy(outer)))) {
                    
                    if ($truthy((text = ref.$xreftext(node.$attr("xrefstyle", nil, true))))) {
                      if ($truthy(text['$include?']("<a"))) {
                        text = text.$gsub($$('DropAnchorRx'), "");
                      }
                    } else {
                      text = ($truthy(top) ? ("[^top]") : ("[" + (refid) + "]"));
                    }                    self.resolving_xref = nil;
                  } else {
                    text = ($truthy(top) ? ("[^top]") : ("[" + (refid) + "]"));
                  }
                } else {
                  text = "[" + (refid) + "]";
                }
              }            }            return "<a href=\"" + (node.$target()) + "\"" + (attrs) + ">" + (text) + "</a>";
          case "ref":
            return "<a id=\"" + (node.$id()) + "\"></a>"
          case "link":
            
            attrs = ($truthy(node.$id()) ? ([" id=\"" + (node.$id()) + "\""]) : ([]));
            if ($truthy(node.$role())) {
              attrs['$<<'](" class=\"" + (node.$role()) + "\"");
            }            if ($truthy(node['$attr?']("title"))) {
              attrs['$<<'](" title=\"" + (node.$attr("title")) + "\"");
            }            return "<a href=\"" + (node.$target()) + "\"" + (self.$append_link_constraint_attrs(node, attrs).$join()) + ">" + (node.$text()) + "</a>";
          case "bibref":
            return "<a id=\"" + (node.$id()) + "\"></a>[" + (($truthy(($ret_or_2 = node.$reftext())) ? ($ret_or_2) : (node.$id()))) + "]"
          default:
            
            self.$logger().$warn("unknown anchor type: " + (node.$type().$inspect()));
            return nil;
        }
      });
      
      $def(self, '$convert_inline_break', function $$convert_inline_break(node) {
        var self = this;

        return "" + (node.$text()) + "<br" + (self.void_element_slash) + ">"
      });
      
      $def(self, '$convert_inline_button', function $$convert_inline_button(node) {
        
        return "<b class=\"button\">" + (node.$text()) + "</b>"
      });
      
      $def(self, '$convert_inline_callout', function $$convert_inline_callout(node) {
        var self = this, src = nil, guard = nil;

        if ($truthy(node.$document()['$attr?']("icons", "font"))) {
          return "<i class=\"conum\" data-value=\"" + (node.$text()) + "\"></i><b>(" + (node.$text()) + ")</b>"
        } else if ($truthy(node.$document()['$attr?']("icons"))) {
          
          src = node.$icon_uri("callouts/" + (node.$text()));
          return "<img src=\"" + (src) + "\" alt=\"" + (node.$text()) + "\"" + (self.void_element_slash) + ">";
        } else if ($eqeqeq($$$('Array'), (guard = node.$attributes()['$[]']("guard")))) {
          return "&lt;!--<b class=\"conum\">(" + (node.$text()) + ")</b>--&gt;"
        } else {
          return "" + (guard) + "<b class=\"conum\">(" + (node.$text()) + ")</b>"
        }
      });
      
      $def(self, '$convert_inline_footnote', function $$convert_inline_footnote(node) {
        var index = nil, id_attr = nil;

        if ($truthy((index = node.$attr("index")))) {
          if ($eqeq(node.$type(), "xref")) {
            return "<sup class=\"footnoteref\">[<a class=\"footnote\" href=\"#_footnotedef_" + (index) + "\" title=\"View footnote.\">" + (index) + "</a>]</sup>"
          } else {
            
            id_attr = ($truthy(node.$id()) ? (" id=\"_footnote_" + (node.$id()) + "\"") : (""));
            return "<sup class=\"footnote\"" + (id_attr) + ">[<a id=\"_footnoteref_" + (index) + "\" class=\"footnote\" href=\"#_footnotedef_" + (index) + "\" title=\"View footnote.\">" + (index) + "</a>]</sup>";
          }
        } else if ($eqeq(node.$type(), "xref")) {
          return "<sup class=\"footnoteref red\" title=\"Unresolved footnote reference.\">[" + (node.$text()) + "]</sup>"
        } else {
          return nil
        }
      });
      
      $def(self, '$convert_inline_image', function $$convert_inline_image(node) {
        var self = this, target = nil, type = nil, $ret_or_1 = nil, icons = nil, i_class_attr_val = nil, attrs = nil, img = nil, fallback = nil, class_attr_val = nil, role = nil;

        
        target = node.$target();
        if ($eqeq((type = ($truthy(($ret_or_1 = node.$type())) ? ($ret_or_1) : ("image"))), "icon")) {
          if ($eqeq((icons = node.$document().$attr("icons")), "font")) {
            
            i_class_attr_val = "fa fa-" + (target);
            if ($truthy(node['$attr?']("size"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-" + (node.$attr("size"));
            }            if ($truthy(node['$attr?']("flip"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-flip-" + (node.$attr("flip"));
            } else if ($truthy(node['$attr?']("rotate"))) {
              i_class_attr_val = "" + (i_class_attr_val) + " fa-rotate-" + (node.$attr("rotate"));
            }            attrs = ($truthy(node['$attr?']("title")) ? (" title=\"" + (node.$attr("title")) + "\"") : (""));
            img = "<i class=\"" + (i_class_attr_val) + "\"" + (attrs) + "></i>";
          } else if ($truthy(icons)) {
            
            attrs = ($truthy(node['$attr?']("width")) ? (" width=\"" + (node.$attr("width")) + "\"") : (""));
            if ($truthy(node['$attr?']("height"))) {
              attrs = "" + (attrs) + " height=\"" + (node.$attr("height")) + "\"";
            }            if ($truthy(node['$attr?']("title"))) {
              attrs = "" + (attrs) + " title=\"" + (node.$attr("title")) + "\"";
            }            img = "<img src=\"" + (node.$icon_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">";
          } else {
            img = "[" + (node.$alt()) + "&#93;";
          }
        } else {
          
          attrs = ($truthy(node['$attr?']("width")) ? (" width=\"" + (node.$attr("width")) + "\"") : (""));
          if ($truthy(node['$attr?']("height"))) {
            attrs = "" + (attrs) + " height=\"" + (node.$attr("height")) + "\"";
          }          if ($truthy(node['$attr?']("title"))) {
            attrs = "" + (attrs) + " title=\"" + (node.$attr("title")) + "\"";
          }          if ((($truthy(node['$attr?']("format", "svg")) || ($truthy(target['$include?'](".svg")))) && ($truthy($rb_lt(node.$document().$safe(), $$$($$('SafeMode'), 'SECURE')))))) {
            if ($truthy(node['$option?']("inline"))) {
              img = ($truthy(($ret_or_1 = self.$read_svg_contents(node, target))) ? ($ret_or_1) : ("<span class=\"alt\">" + (node.$alt()) + "</span>"));
            } else if ($truthy(node['$option?']("interactive"))) {
              
              fallback = ($truthy(node['$attr?']("fallback")) ? ("<img src=\"" + (node.$image_uri(node.$attr("fallback"))) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">") : ("<span class=\"alt\">" + (node.$alt()) + "</span>"));
              img = "<object type=\"image/svg+xml\" data=\"" + (node.$image_uri(target)) + "\"" + (attrs) + ">" + (fallback) + "</object>";
            } else {
              img = "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">";
            }
          } else {
            img = "<img src=\"" + (node.$image_uri(target)) + "\" alt=\"" + (self.$encode_attribute_value(node.$alt())) + "\"" + (attrs) + (self.void_element_slash) + ">";
          }        }        if ($truthy(node['$attr?']("link"))) {
          img = "<a class=\"image\" href=\"" + (node.$attr("link")) + "\"" + (self.$append_link_constraint_attrs(node).$join()) + ">" + (img) + "</a>";
        }        class_attr_val = type;
        if ($truthy((role = node.$role()))) {
          class_attr_val = ($truthy(node['$attr?']("float")) ? ("" + (class_attr_val) + " " + (node.$attr("float")) + " " + (role)) : ("" + (class_attr_val) + " " + (role)));
        } else if ($truthy(node['$attr?']("float"))) {
          class_attr_val = "" + (class_attr_val) + " " + (node.$attr("float"));
        }        return "<span class=\"" + (class_attr_val) + "\">" + (img) + "</span>";
      });
      
      $def(self, '$convert_inline_indexterm', function $$convert_inline_indexterm(node) {
        
        if ($eqeq(node.$type(), "visible")) {
          return node.$text()
        } else {
          return ""
        }
      });
      
      $def(self, '$convert_inline_kbd', function $$convert_inline_kbd(node) {
        var keys = nil;

        if ($eqeq((keys = node.$attr("keys")).$size(), 1)) {
          return "<kbd>" + (keys['$[]'](0)) + "</kbd>"
        } else {
          return "<span class=\"keyseq\"><kbd>" + (keys.$join("</kbd>+<kbd>")) + "</kbd></span>"
        }
      });
      
      $def(self, '$convert_inline_menu', function $$convert_inline_menu(node) {
        var caret = nil, submenu_joiner = nil, menu = nil, submenus = nil, menuitem = nil;

        
        caret = ($truthy(node.$document()['$attr?']("icons", "font")) ? ("&#160;<i class=\"fa fa-angle-right caret\"></i> ") : ("&#160;<b class=\"caret\">&#8250;</b> "));
        submenu_joiner = "</b>" + (caret) + "<b class=\"submenu\">";
        menu = node.$attr("menu");
        if ($truthy((submenus = node.$attr("submenus"))['$empty?']())) {
          if ($truthy((menuitem = node.$attr("menuitem")))) {
            return "<span class=\"menuseq\"><b class=\"menu\">" + (menu) + "</b>" + (caret) + "<b class=\"menuitem\">" + (menuitem) + "</b></span>"
          } else {
            return "<b class=\"menuref\">" + (menu) + "</b>"
          }
        } else {
          return "<span class=\"menuseq\"><b class=\"menu\">" + (menu) + "</b>" + (caret) + "<b class=\"submenu\">" + (submenus.$join(submenu_joiner)) + "</b>" + (caret) + "<b class=\"menuitem\">" + (node.$attr("menuitem")) + "</b></span>"
        }      });
      
      $def(self, '$convert_inline_quoted', function $$convert_inline_quoted(node) {
        var $a, $b, open = nil, close = nil, tag = nil, class_attr = nil;

        
        $b = $$('QUOTE_TAGS')['$[]'](node.$type()), $a = $to_ary($b), (open = ($a[0] == null ? nil : $a[0])), (close = ($a[1] == null ? nil : $a[1])), (tag = ($a[2] == null ? nil : $a[2]));
        if ($truthy(node.$id())) {
          
          class_attr = ($truthy(node.$role()) ? (" class=\"" + (node.$role()) + "\"") : (""));
          if ($truthy(tag)) {
            return "" + (open.$chop()) + " id=\"" + (node.$id()) + "\"" + (class_attr) + ">" + (node.$text()) + (close)
          } else {
            return "<span id=\"" + (node.$id()) + "\"" + (class_attr) + ">" + (open) + (node.$text()) + (close) + "</span>"
          }        } else if ($truthy(node.$role())) {
          if ($truthy(tag)) {
            return "" + (open.$chop()) + " class=\"" + (node.$role()) + "\">" + (node.$text()) + (close)
          } else {
            return "<span class=\"" + (node.$role()) + "\">" + (open) + (node.$text()) + (close) + "</span>"
          }
        } else {
          return "" + (open) + (node.$text()) + (close)
        }      });
      
      $def(self, '$read_svg_contents', function $$read_svg_contents(node, target) {
        var svg = nil, old_start_tag = nil, new_start_tag = nil, start_tag_match = nil;

        
        if ($truthy((svg = node.$read_contents(target, $hash2(["start", "normalize", "label", "warn_if_empty"], {"start": node.$document().$attr("imagesdir"), "normalize": true, "label": "SVG", "warn_if_empty": true}))))) {
          
          if ($truthy(svg['$empty?']())) {
            return nil
          }          if (!$truthy(svg['$start_with?']("<svg"))) {
            svg = svg.$sub($$('SvgPreambleRx'), "");
          }          old_start_tag = (new_start_tag = (start_tag_match = nil));
          $send(["width", "height"], 'each', [], function $$20(dim){var $ret_or_1 = nil, $ret_or_2 = nil;

            
            if (dim == null) dim = nil;
            if (!$truthy(node['$attr?'](dim))) {
              return nil
            }            if (!$truthy(new_start_tag)) {
              
              if ($eqeq((start_tag_match = ($truthy(($ret_or_1 = start_tag_match)) ? ($ret_or_1) : ($truthy(($ret_or_2 = svg.$match($$('SvgStartTagRx')))) ? ($ret_or_2) : ("no_match")))), "no_match")) {
                return nil
              }              new_start_tag = (old_start_tag = start_tag_match['$[]'](0)).$gsub($$('DimensionAttributeRx'), "");
            }            return (new_start_tag = "" + (new_start_tag.$chop()) + " " + (dim) + "=\"" + (node.$attr(dim)) + "\">");});
          if ($truthy(new_start_tag)) {
            svg = "" + (new_start_tag) + (svg['$[]'](Opal.Range.$new(old_start_tag.$length(), -1, false)));
          }        }        return svg;
      });
      self.$private();
      
      $def(self, '$append_boolean_attribute', function $$append_boolean_attribute(name, xml) {
        
        if ($truthy(xml)) {
          return " " + (name) + "=\"" + (name) + "\""
        } else {
          return " " + (name)
        }
      });
      
      $def(self, '$append_link_constraint_attrs', function $$append_link_constraint_attrs(node, attrs) {
        var rel = nil, window = nil;

        
        if (attrs == null) attrs = [];
        if ($truthy(node['$option?']("nofollow"))) {
          rel = "nofollow";
        }        if ($truthy((window = node.$attributes()['$[]']("window")))) {
          
          attrs['$<<'](" target=\"" + (window) + "\"");
          if (($eqeq(window, "_blank") || ($truthy(node['$option?']("noopener"))))) {
            attrs['$<<'](($truthy(rel) ? (" rel=\"" + (rel) + " noopener\"") : (" rel=\"noopener\"")));
          }        } else if ($truthy(rel)) {
          attrs['$<<'](" rel=\"" + (rel) + "\"");
        }        return attrs;
      }, -2);
      
      $def(self, '$encode_attribute_value', function $$encode_attribute_value(val) {
        
        if ($truthy(val['$include?']("\""))) {
          
          return val.$gsub("\"", "&quot;");
        } else {
          return val
        }
      });
      
      $def(self, '$generate_manname_section', function $$generate_manname_section(node) {
        var manname_title = nil, next_section_title = nil, next_section = nil, manname_id_attr = nil, manname_id = nil;

        
        manname_title = node.$attr("manname-title", "Name");
        if (($truthy((next_section = node.$sections()['$[]'](0))) && ($eqeq((next_section_title = next_section.$title()), next_section_title.$upcase())))) {
          manname_title = manname_title.$upcase();
        }        manname_id_attr = ($truthy((manname_id = node.$attr("manname-id"))) ? (" id=\"" + (manname_id) + "\"") : (""));
        return "<h2" + (manname_id_attr) + ">" + (manname_title) + "</h2>\n" + "<div class=\"sectionbody\">\n" + "<p>" + (node.$attr("mannames").$join(", ")) + " - " + (node.$attr("manpurpose")) + "</p>\n" + "</div>";
      });
      
      $def(self, '$get_root_document', function $$get_root_document(node) {
        
        
        while ($truthy((node = node.$document())['$nested?']())) {
        node = node.$parent_document();
        }        return node;
      });
      
      $def(self, '$method_missing', function $$method_missing(id, $a) {
        var $post_args, args, $yield = $$method_missing.$$p || nil, self = this, name = nil;

        $$method_missing.$$p = null;
        
        $post_args = $slice(arguments, 1);
        args = $post_args;
        if (($not((name = id.$to_s())['$start_with?']("convert_")) && ($truthy(self['$handles?'](name))))) {
          
          return $send(self, 'send', ["convert_" + (name)].concat($to_a(args)));
        } else {
          return $send2(self, $find_super(self, 'method_missing', $$method_missing, false, true), 'method_missing', [id].concat($to_a(args)), $yield)
        }      }, -2);
      return $def(self, '$respond_to_missing?', function $Html5Converter_respond_to_missing$ques$21(id, $a) {
        var self = this, $ret_or_1 = nil, name = nil;

        
        $slice(arguments, 1);
        if ($truthy(($ret_or_1 = (name = id.$to_s())['$start_with?']("convert_")['$!']()))) {
          
          return self['$handles?'](name);
        } else {
          return $ret_or_1
        }      }, -2);
    })($$('Converter'), $$$($$('Converter'), 'Base'), $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/extensions"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $hash2 = Opal.hash2, $def = Opal.def, $send = Opal.send, $alias = Opal.alias, $slice = Opal.slice, $rb_plus = Opal.rb_plus, $eqeq = Opal.eqeq, $rb_gt = Opal.rb_gt, $not = Opal.not, $eqeqeq = Opal.eqeqeq, $to_a = Opal.to_a, $to_ary = Opal.to_ary, $const_set = Opal.const_set, $return_val = Opal.return_val, $send2 = Opal.send2, $find_super = Opal.find_super, $NilClass = Opal.NilClass, $class_variable_set = Opal.class_variable_set, $class_variable_get = Opal.class_variable_get, $regexp = Opal.regexp, $Class = Opal.Class, $return_ivar = Opal.return_ivar, $rb_lt = Opal.rb_lt, $rb_minus = Opal.rb_minus, $hash = Opal.hash, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('[]=,config,const_defined?,singleton_class?,include,const_get,extend,enable_dsl,attr_reader,merge,class,update,raise,document,==,doctype,[],+,level,delete,>,casecmp,new,title=,sectname=,special=,fetch,numbered=,attr?,!,key?,special,numbered,id=,generate_id,title,update_attributes,tr,basename,create_block,assign_caption,===,parse_blocks,empty?,include?,sub_attributes,parse,each,define_method,unshift,shift,send,size,receiver,binding,define_singleton_method,instance_exec,to_proc,call,option,content_model,flatten,positional_attributes,default_attributes,respond_to?,to_s,partition,to_i,<<,compact,inspect,resolve_attributes,attr_accessor,to_set,contexts,match?,resolve_regexp,format,method,register,reset,values,groups,arity,activate,add_document_processor,tree_processor,tree_processors?,tree_processors,any?,select,add_syntax_processor,to_sym,instance_variable_get,kind,private,join,map,split,capitalize,instance_variable_set,resolve_args,singleton_class,process_block_given?,source_location,freeze,resolve_class,<,update_config,as_symbol,name,name=,pop,-,-@,next_auto_id,generate_name,each_with_object');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'Extensions');

      var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

      
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Processor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.config = nil;
        
        (function(self, $parent_nesting) {
          
          
          
          $def(self, '$config', function $$config() {
            var self = this, $ret_or_1 = nil;
            if (self.config == null) self.config = nil;

            return (self.config = ($truthy(($ret_or_1 = self.config)) ? ($ret_or_1) : ($hash2([], {}))))
          });
          
          $def(self, '$option', function $$option(key, default_value) {
            var $a, self = this;

            return ($a = [key, default_value], $send(self.$config(), '[]=', $a), $a[$a.length - 1])
          });
          
          $def(self, '$enable_dsl', function $$enable_dsl() {
            var self = this;

            if ($truthy(self['$const_defined?']("DSL"))) {
              if ($truthy(self['$singleton_class?']())) {
                return self.$include(self.$const_get("DSL"))
              } else {
                return self.$extend(self.$const_get("DSL"))
              }
            } else {
              return nil
            }
          });
          return $alias(self, "use_dsl", "enable_dsl");
        })(Opal.get_singleton_class(self));
        self.$attr_reader("config");
        
        $def(self, '$initialize', function $$initialize(config) {
          var self = this;

          
          if (config == null) config = $hash2([], {});
          return (self.config = self.$class().$config().$merge(config));
        }, -1);
        
        $def(self, '$update_config', function $$update_config(config) {
          var self = this;

          return self.config.$update(config)
        });
        
        $def(self, '$process', function $$process($a) {
          var self = this;

          
          $slice(arguments);
          return self.$raise($$$('NotImplementedError'), "" + ($$('Processor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method");
        }, -1);
        
        $def(self, '$create_section', function $$create_section(parent, title, attrs, opts) {
          var $a, $b, doc = nil, book = nil, doctype = nil, level = nil, $ret_or_1 = nil, style = nil, sectname = nil, special = nil, sect = nil, id = nil;

          
          if (opts == null) opts = $hash2([], {});
          doc = parent.$document();
          book = (doctype = doc.$doctype())['$==']("book");
          level = ($truthy(($ret_or_1 = opts['$[]']("level"))) ? ($ret_or_1) : ($rb_plus(parent.$level(), 1)));
          if ($truthy((style = attrs.$delete("style")))) {
            if (($truthy(book) && ($eqeq(style, "abstract")))) {
              $a = ["chapter", 1], (sectname = $a[0]), (level = $a[1]);
            } else {
              
              $a = [style, true], (sectname = $a[0]), (special = $a[1]);
              if ($eqeq(level, 0)) {
                level = 1;
              }            }
          } else if ($truthy(book)) {
            sectname = ($eqeq(level, 0) ? ("part") : (($truthy($rb_gt(level, 1)) ? ("section") : ("chapter"))));
          } else if (($eqeq(doctype, "manpage") && ($eqeq(title.$casecmp("synopsis"), 0)))) {
            $a = ["synopsis", true], (sectname = $a[0]), (special = $a[1]);
          } else {
            sectname = "section";
          }          sect = $$('Section').$new(parent, level);
          $a = [title, sectname], ($b = [$a[0]], $send(sect, 'title=', $b), $b[$b.length - 1]), ($b = [$a[1]], $send(sect, 'sectname=', $b), $b[$b.length - 1]);
          if ($truthy(special)) {
            
            sect['$special='](true);
            if ($truthy(opts.$fetch("numbered", style['$==']("appendix")))) {
              sect['$numbered='](true);
            } else if (($not(opts['$key?']("numbered")) && ($truthy(doc['$attr?']("sectnums", "all"))))) {
              sect['$numbered=']((($truthy(book) && ($eqeq(level, 1))) ? ("chapter") : (true)));
            }          } else if ($truthy($rb_gt(level, 0))) {
            if ($truthy(opts.$fetch("numbered", doc['$attr?']("sectnums")))) {
              sect['$numbered='](($truthy(sect.$special()) ? (($truthy(($ret_or_1 = parent.$numbered())) || ($ret_or_1))) : (true)));
            }
          } else if ($truthy(opts.$fetch("numbered", ($truthy(($ret_or_1 = book)) ? (doc['$attr?']("partnums")) : ($ret_or_1))))) {
            sect['$numbered='](true);
          }          if ($eqeq((id = attrs['$[]']("id")), false)) {
            attrs.$delete("id");
          } else {
            sect['$id='](($a = ["id", ($truthy(($ret_or_1 = id)) ? ($ret_or_1) : (($truthy(doc['$attr?']("sectids")) ? ($$('Section').$generate_id(sect.$title(), doc)) : (nil))))], $send(attrs, '[]=', $a), $a[$a.length - 1]));
          }          sect.$update_attributes(attrs);
          return sect;
        }, -4);
        
        $def(self, '$create_block', function $$create_block(parent, context, source, attrs, opts) {
          
          
          if (opts == null) opts = $hash2([], {});
          return $$('Block').$new(parent, context, $hash2(["source", "attributes"], {"source": source, "attributes": attrs}).$merge(opts));
        }, -5);
        
        $def(self, '$create_list', function $$create_list(parent, context, attrs) {
          var list = nil;

          
          if (attrs == null) attrs = nil;
          list = $$('List').$new(parent, context);
          if ($truthy(attrs)) {
            list.$update_attributes(attrs);
          }          return list;
        }, -3);
        
        $def(self, '$create_list_item', function $$create_list_item(parent, text) {
          
          
          if (text == null) text = nil;
          return $$('ListItem').$new(parent, text);
        }, -2);
        
        $def(self, '$create_image_block', function $$create_image_block(parent, attrs, opts) {
          var $a, self = this, target = nil, title = nil, block = nil;

          
          if (opts == null) opts = $hash2([], {});
          if (!$truthy((target = attrs['$[]']("target")))) {
            self.$raise($$$('ArgumentError'), "Unable to create an image block, target attribute is required");
          }          if ($truthy((attrs['$[]']("alt")))) ; else {
            attrs['$[]=']("alt", ($a = ["default-alt", $$('Helpers').$basename(target, true).$tr("_-", " ")], $send(attrs, '[]=', $a), $a[$a.length - 1]));
          }          title = ($truthy(attrs['$key?']("title")) ? (attrs.$delete("title")) : (nil));
          block = self.$create_block(parent, "image", nil, attrs, opts);
          if ($truthy(title)) {
            
            block['$title='](title);
            block.$assign_caption(attrs.$delete("caption"), "figure");
          }          return block;
        }, -3);
        
        $def(self, '$create_inline', function $$create_inline(parent, context, text, opts) {
          
          
          if (opts == null) opts = $hash2([], {});
          return $$('Inline').$new(parent, context, text, ($eqeq(context, "quoted") ? ($hash2(["type"], {"type": "unquoted"}).$merge(opts)) : (opts)));
        }, -4);
        
        $def(self, '$parse_content', function $$parse_content(parent, content, attributes) {
          var reader = nil;

          
          if (attributes == null) attributes = nil;
          reader = ($eqeqeq($$('Reader'), content) ? (content) : ($$('Reader').$new(content)));
          $$('Parser').$parse_blocks(reader, parent, attributes);
          return parent;
        }, -3);
        
        $def(self, '$parse_attributes', function $$parse_attributes(block, attrlist, opts) {
          var $ret_or_1 = nil;

          
          if (opts == null) opts = $hash2([], {});
          if ($truthy(($truthy(attrlist) ? (attrlist['$empty?']()) : (true)))) {
            return $hash2([], {})
          }          if (($truthy(opts['$[]']("sub_attributes")) && ($truthy(attrlist['$include?']($$('ATTR_REF_HEAD')))))) {
            attrlist = block.$sub_attributes(attrlist);
          }          return $$('AttributeList').$new(attrlist).$parse(($truthy(($ret_or_1 = opts['$[]']("positional_attributes"))) ? ($ret_or_1) : ([])));
        }, -3);
        return $send([["create_paragraph", "create_block", "paragraph"], ["create_open_block", "create_block", "open"], ["create_example_block", "create_block", "example"], ["create_pass_block", "create_block", "pass"], ["create_listing_block", "create_block", "listing"], ["create_literal_block", "create_block", "literal"], ["create_anchor", "create_inline", "anchor"], ["create_inline_pass", "create_inline", "quoted"]], 'each', [], function $Processor$1(method_name, delegate_method_name, context){var self = $Processor$1.$$s == null ? this : $Processor$1.$$s;

          
          if (method_name == null) method_name = nil;
          if (delegate_method_name == null) delegate_method_name = nil;
          if (context == null) context = nil;
          return $send(self, 'define_method', [method_name], function $$2($a){var $post_args, args, self = $$2.$$s == null ? this : $$2.$$s;

            
            $post_args = $slice(arguments);
            args = $post_args;
            args.$unshift(args.$shift(), context);
            return $send(self, 'send', [delegate_method_name].concat($to_a(args)));}, {$$arity: -1, $$s: self});}, {$$s: self});
      })($nesting[0], null, $nesting);
      (function($base) {
        var self = $module($base, 'ProcessorDsl');

        
        
        
        $def(self, '$option', function $$option(key, value) {
          var $a, self = this;

          return ($a = [key, value], $send(self.$config(), '[]=', $a), $a[$a.length - 1])
        });
        
        $def(self, '$process', function $$process($a) {
          var block = $$process.$$p || nil, $post_args, args, $b, self = this, context = nil;
          if (self.process_block == null) self.process_block = nil;

          $$process.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          if ((block !== nil)) {
            
            if (!$truthy(args['$empty?']())) {
              self.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$size()) + ", expected 0)");
            }            if (!($truthy(block.$binding()) && ($eqeq(self, block.$binding().$receiver())))) {
              
              context = self;
              $send(block, 'define_singleton_method', ["call"], function $$3($b){var $post_args, m_args;

                
                $post_args = $slice(arguments);
                m_args = $post_args;
                return $send(context, 'instance_exec', $to_a(m_args), block.$to_proc());}, -1);
            }            return (self.process_block = block);
          } else if ($truthy((($b = self['process_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            return $send(self.process_block, 'call', $to_a(args))
          } else {
            return self.$raise($$$('NotImplementedError'), "" + (self.$class()) + " #" + ("process") + " method called before being registered")
          }        }, -1);
        return $def(self, '$process_block_given?', function $ProcessorDsl_process_block_given$ques$4() {
          var $a, self = this;

          return (($a = self['process_block'], $a != null && $a !== nil) ? 'instance-variable' : nil)
        });
      })($nesting[0]);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DocumentProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('ProcessorDsl'));
        return $def(self, '$prefer', function $$prefer() {
          var self = this;

          return self.$option("position", ">>")
        });
      })($nesting[0], $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'SyntaxProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('ProcessorDsl'));
        
        $def(self, '$named', function $$named(value) {
          var self = this;

          if ($eqeqeq($$('Processor'), self)) {
            return (self.name = value)
          } else {
            return self.$option("name", value)
          }
        });
        
        $def(self, '$content_model', function $$content_model(value) {
          var self = this;

          return self.$option("content_model", value)
        });
        $alias(self, "parse_content_as", "content_model");
        
        $def(self, '$positional_attributes', function $$positional_attributes($a) {
          var $post_args, value, self = this;

          
          $post_args = $slice(arguments);
          value = $post_args;
          return self.$option("positional_attrs", value.$flatten());
        }, -1);
        $alias(self, "name_positional_attributes", "positional_attributes");
        $alias(self, "positional_attrs", "positional_attributes");
        
        $def(self, '$default_attributes', function $$default_attributes(value) {
          var self = this;

          return self.$option("default_attrs", value)
        });
        $alias(self, "default_attrs", "default_attributes");
        
        $def(self, '$resolve_attributes', function $$resolve_attributes($a) {
          var $post_args, args, $b, self = this, $ret_or_1 = nil, names = nil, defaults = nil;

          
          $post_args = $slice(arguments);
          args = $post_args;
          if (!$truthy($rb_gt(args.$size(), 1))) {
            if ($truthy((args = args.$fetch(0, true))['$respond_to?']("to_sym"))) {
              args = [args];
            }
          }          if ($eqeqeq(true, ($ret_or_1 = args))) {
            
            self.$option("positional_attrs", []);
            return self.$option("default_attrs", $hash2([], {}));
          } else if ($eqeqeq($$$('Array'), $ret_or_1)) {
            
            $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]);
            $send(args, 'each', [], function $$5(arg){var $c, $d, name = nil, value = nil, idx = nil;

              
              if (arg == null) arg = nil;
              if ($truthy((arg = arg.$to_s())['$include?']("="))) {
                
                $d = arg.$partition("="), $c = $to_ary($d), (name = ($c[0] == null ? nil : $c[0])), (($c[1] == null ? nil : $c[1])), (value = ($c[2] == null ? nil : $c[2]));
                if ($truthy(name['$include?'](":"))) {
                  
                  $d = name.$partition(":"), $c = $to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2]));
                  idx = ($eqeq(idx, "@") ? (names.$size()) : (idx.$to_i()));
                  names['$[]='](idx, name);
                }                return ($c = [name, value], $send(defaults, '[]=', $c), $c[$c.length - 1]);
              } else if ($truthy(arg['$include?'](":"))) {
                
                $d = arg.$partition(":"), $c = $to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2]));
                idx = ($eqeq(idx, "@") ? (names.$size()) : (idx.$to_i()));
                return ($c = [idx, name], $send(names, '[]=', $c), $c[$c.length - 1]);
              } else {
                return names['$<<'](arg)
              }});
            self.$option("positional_attrs", names.$compact());
            return self.$option("default_attrs", defaults);
          } else if ($eqeqeq($$$('Hash'), $ret_or_1)) {
            
            $b = [[], $hash2([], {})], (names = $b[0]), (defaults = $b[1]);
            $send(args, 'each', [], function $$6(key, val){var $c, $d, name = nil, idx = nil;

              
              if (key == null) key = nil;
              if (val == null) val = nil;
              if ($truthy((name = key.$to_s())['$include?'](":"))) {
                
                $d = name.$partition(":"), $c = $to_ary($d), (idx = ($c[0] == null ? nil : $c[0])), (($c[1] == null ? nil : $c[1])), (name = ($c[2] == null ? nil : $c[2]));
                idx = ($eqeq(idx, "@") ? (names.$size()) : (idx.$to_i()));
                names['$[]='](idx, name);
              }              if ($truthy(val)) {
                return ($c = [name, val], $send(defaults, '[]=', $c), $c[$c.length - 1])
              } else {
                return nil
              }});
            self.$option("positional_attrs", names.$compact());
            return self.$option("default_attrs", defaults);
          } else {
            return self.$raise($$$('ArgumentError'), "unsupported attributes specification for macro: " + (args.$inspect()))
          }        }, -1);
        return $alias(self, "resolves_attributes", "resolve_attributes");
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Preprocessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$process', function $$process(document, reader) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('Preprocessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        })
      })($nesting[0], $$('Processor'), $nesting);
      $const_set($$('Preprocessor'), 'DSL', $$('DocumentProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'TreeProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$process', function $$process(document) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('TreeProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        })
      })($nesting[0], $$('Processor'), $nesting);
      $const_set($$('TreeProcessor'), 'DSL', $$('DocumentProcessorDsl'));
      $const_set($nesting[0], 'Treeprocessor', $$('TreeProcessor'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Postprocessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$process', function $$process(document, output) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('Postprocessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        })
      })($nesting[0], $$('Processor'), $nesting);
      $const_set($$('Postprocessor'), 'DSL', $$('DocumentProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'IncludeProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$process', function $$process(document, reader, target, attributes) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('IncludeProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        });
        return $def(self, '$handles?', $return_val(true));
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'IncludeProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DocumentProcessorDsl'));
        return $def(self, '$handles?', function $IncludeProcessorDsl_handles$ques$7($a) {
          var block = $IncludeProcessorDsl_handles$ques$7.$$p || nil, $post_args, args, $b, self = this;
          if (self.handles_block == null) self.handles_block = nil;

          $IncludeProcessorDsl_handles$ques$7.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          if ((block !== nil)) {
            
            if (!$truthy(args['$empty?']())) {
              self.$raise($$$('ArgumentError'), "wrong number of arguments (given " + (args.$size()) + ", expected 0)");
            }            return (self.handles_block = block);
          } else if ($truthy((($b = self['handles_block'], $b != null && $b !== nil) ? 'instance-variable' : nil))) {
            return self.handles_block.$call(args['$[]'](0))
          } else {
            return true
          }        }, -1);
      })($nesting[0], $nesting);
      $const_set($$('IncludeProcessor'), 'DSL', $$('IncludeProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'DocinfoProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.config = nil;
        
        
        $def(self, '$initialize', function $$initialize(config) {
          var $a; $$initialize.$$p || nil; var self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          if (config == null) config = $hash2([], {});
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [config], null);
          if ($truthy(($ret_or_1 = self.config['$[]']("location")))) {
            return $ret_or_1
          } else {
            return ($a = ["location", "head"], $send(self.config, '[]=', $a), $a[$a.length - 1])
          }        }, -1);
        return $def(self, '$process', function $$process(document) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('DocinfoProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        });
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'DocinfoProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('DocumentProcessorDsl'));
        return $def(self, '$at_location', function $$at_location(value) {
          var self = this;

          return self.$option("location", value)
        });
      })($nesting[0], $nesting);
      $const_set($$('DocinfoProcessor'), 'DSL', $$('DocinfoProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BlockProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.config = nil;
        
        self.$attr_accessor("name");
        
        $def(self, '$initialize', function $$initialize(name, config) {
          var $a; $$initialize.$$p || nil; var self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          if (name == null) name = nil;
          if (config == null) config = $hash2([], {});
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [config], null);
          self.name = ($truthy(($ret_or_1 = name)) ? ($ret_or_1) : (self.config['$[]']("name")));
          if ($eqeqeq($NilClass, ($ret_or_1 = self.config['$[]']("contexts")))) {
            if ($truthy((self.config['$[]']("contexts")))) ; else {
              self.config['$[]=']("contexts", ["open", "paragraph"].$to_set());
            }
          } else if ($eqeqeq($$$('Symbol'), $ret_or_1)) {
            self.config['$[]=']("contexts", [self.config['$[]']("contexts")].$to_set());
          } else {
            self.config['$[]=']("contexts", self.config['$[]']("contexts").$to_set());
          }          if ($truthy(($ret_or_1 = self.config['$[]']("content_model")))) {
            return $ret_or_1
          } else {
            return ($a = ["content_model", "compound"], $send(self.config, '[]=', $a), $a[$a.length - 1])
          }        }, -1);
        return $def(self, '$process', function $$process(parent, reader, attributes) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('BlockProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        });
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'BlockProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('SyntaxProcessorDsl'));
        
        $def(self, '$contexts', function $$contexts($a) {
          var $post_args, value, self = this;

          
          $post_args = $slice(arguments);
          value = $post_args;
          return self.$option("contexts", value.$flatten().$to_set());
        }, -1);
        $alias(self, "on_contexts", "contexts");
        $alias(self, "on_context", "contexts");
        return $alias(self, "bind_to", "contexts");
      })($nesting[0], $nesting);
      $const_set($$('BlockProcessor'), 'DSL', $$('BlockProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'MacroProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.config = nil;
        
        self.$attr_accessor("name");
        
        $def(self, '$initialize', function $$initialize(name, config) {
          var $a; $$initialize.$$p || nil; var self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          if (name == null) name = nil;
          if (config == null) config = $hash2([], {});
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [config], null);
          self.name = ($truthy(($ret_or_1 = name)) ? ($ret_or_1) : (self.config['$[]']("name")));
          if ($truthy(($ret_or_1 = self.config['$[]']("content_model")))) {
            return $ret_or_1
          } else {
            return ($a = ["content_model", "attributes"], $send(self.config, '[]=', $a), $a[$a.length - 1])
          }        }, -1);
        return $def(self, '$process', function $$process(parent, target, attributes) {
          var self = this;

          return self.$raise($$$('NotImplementedError'), "" + ($$('MacroProcessor')) + " subclass " + (self.$class()) + " must implement the #" + ("process") + " method")
        });
      })($nesting[0], $$('Processor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'MacroProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('SyntaxProcessorDsl'));
        
        $def(self, '$resolve_attributes', function $$resolve_attributes($a) {
          var $post_args, args, $yield = $$resolve_attributes.$$p || nil, self = this;

          $$resolve_attributes.$$p = null;
          
          $post_args = $slice(arguments);
          args = $post_args;
          if (($eqeq(args.$size(), 1) && ($not(args['$[]'](0))))) {
            return self.$option("content_model", "text")
          } else {
            
            $send2(self, $find_super(self, 'resolve_attributes', $$resolve_attributes, false, true), 'resolve_attributes', $to_a(args), $yield);
            return self.$option("content_model", "attributes");
          }        }, -1);
        return $alias(self, "resolves_attributes", "resolve_attributes");
      })($nesting[0], $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'BlockMacroProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.name = nil;
        return $def(self, '$name', function $$name() {
          var self = this;

          
          if (!$truthy($$('MacroNameRx')['$match?'](self.name.$to_s()))) {
            self.$raise($$$('ArgumentError'), "invalid name for block macro: " + (self.name));
          }          return self.name;
        })
      })($nesting[0], $$('MacroProcessor'), $nesting);
      $const_set($$('BlockMacroProcessor'), 'DSL', $$('MacroProcessorDsl'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'InlineMacroProcessor');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.config = $proto.name = nil;
        
        $class_variable_set($nesting[0], '@@rx_cache', $hash2([], {}));
        
        $def(self, '$regexp', function $$regexp() {
          var $a, self = this, $ret_or_1 = nil;

          if ($truthy(($ret_or_1 = self.config['$[]']("regexp")))) {
            return $ret_or_1
          } else {
            return ($a = ["regexp", self.$resolve_regexp(self.name.$to_s(), self.config['$[]']("format"))], $send(self.config, '[]=', $a), $a[$a.length - 1])
          }
        });
        return $def(self, '$resolve_regexp', function $$resolve_regexp(name, format) {
          var $a, self = this, $ret_or_1 = nil;

          
          if (!$truthy($$('MacroNameRx')['$match?'](name))) {
            self.$raise($$$('ArgumentError'), "invalid name for inline macro: " + (name));
          }          if ($truthy(($ret_or_1 = $class_variable_get($nesting[0], '@@rx_cache', false)['$[]']([name, format])))) {
            return $ret_or_1
          } else {
            return ($a = [[name, format], $regexp(["\\\\?", name, ":", ($eqeq(format, "short") ? ("(){0}") : ("(\\S+?)")), "\\[(|", $$('CC_ANY'), "*?[^\\\\])\\]"])], $send($class_variable_get($nesting[0], '@@rx_cache', false), '[]=', $a), $a[$a.length - 1])
          }        });
      })($nesting[0], $$('MacroProcessor'), $nesting);
      (function($base, $parent_nesting) {
        var self = $module($base, 'InlineMacroProcessorDsl');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        self.$include($$('MacroProcessorDsl'));
        
        $def(self, '$format', function $$format(value) {
          var self = this;

          return self.$option("format", value)
        });
        $alias(self, "match_format", "format");
        $alias(self, "using_format", "format");
        return $def(self, '$match', function $$match(value) {
          var self = this;

          return self.$option("regexp", value)
        });
      })($nesting[0], $nesting);
      $const_set($$('InlineMacroProcessor'), 'DSL', $$('InlineMacroProcessorDsl'));
      (function($base, $super) {
        var self = $klass($base, $super, 'Extension');

        
        
        self.$attr_reader("kind");
        self.$attr_reader("config");
        self.$attr_reader("instance");
        return $def(self, '$initialize', function $$initialize(kind, instance, config) {
          var self = this;

          
          self.kind = kind;
          self.instance = instance;
          return (self.config = config);
        });
      })($nesting[0], null);
      (function($base, $super) {
        var self = $klass($base, $super, 'ProcessorExtension');

        
        
        self.$attr_reader("process_method");
        return $def(self, '$initialize', function $$initialize(kind, instance, process_method) {
          $$initialize.$$p || nil; var self = this, $ret_or_1 = nil;

          $$initialize.$$p = null;
          
          if (process_method == null) process_method = nil;
          $send2(self, $find_super(self, 'initialize', $$initialize, false, true), 'initialize', [kind, instance, instance.$config()], null);
          return (self.process_method = ($truthy(($ret_or_1 = process_method)) ? ($ret_or_1) : (instance.$method("process"))));
        }, -3);
      })($nesting[0], $$('Extension'));
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Group');

        var $nesting = [self].concat($parent_nesting);

        
        (function(self, $parent_nesting) {
          var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

          return $def(self, '$register', function $$register(name) {
            var self = this;

            
            if (name == null) name = nil;
            return $$('Extensions').$register(name, self);
          }, -1)
        })(Opal.get_singleton_class(self), $nesting);
        return $def(self, '$activate', function $$activate(registry) {
          var self = this;

          return self.$raise($$$('NotImplementedError'))
        });
      })($nesting[0], null, $nesting);
      (function($base, $super, $parent_nesting) {
        var self = $klass($base, $super, 'Registry');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

        $proto.document = $proto.groups = $proto.preprocessor_extensions = $proto.tree_processor_extensions = $proto.postprocessor_extensions = $proto.include_processor_extensions = $proto.docinfo_processor_extensions = $proto.block_extensions = $proto.block_macro_extensions = $proto.inline_macro_extensions = nil;
        
        self.$attr_reader("document");
        self.$attr_reader("groups");
        
        $def(self, '$initialize', function $$initialize(groups) {
          var self = this;

          
          if (groups == null) groups = $hash2([], {});
          self.groups = groups;
          self.$reset();
          self.preprocessor_extensions = (self.tree_processor_extensions = (self.postprocessor_extensions = (self.include_processor_extensions = (self.docinfo_processor_extensions = (self.block_extensions = (self.block_macro_extensions = (self.inline_macro_extensions = nil)))))));
          return (self.document = nil);
        }, -1);
        
        $def(self, '$activate', function $$activate(document) {
          var self = this, ext_groups = nil;

          
          if ($truthy(self.document)) {
            self.$reset();
          }          self.document = document;
          if (!$truthy((ext_groups = $rb_plus($$('Extensions').$groups().$values(), self.groups.$values()))['$empty?']())) {
            $send(ext_groups, 'each', [], function $$8(group){var self = $$8.$$s == null ? this : $$8.$$s, $ret_or_1 = nil;

              
              if (group == null) group = nil;
              if ($eqeqeq($$$('Proc'), ($ret_or_1 = group))) {
                
                switch (group.$arity()) {
                  case 0:
                  case -1:
                    return $send(self, 'instance_exec', [], group.$to_proc())
                  case 1:
                    return group.$call(self)
                  default:
                    return nil
                }
              } else if ($eqeqeq($Class, $ret_or_1)) {
                return group.$new().$activate(self)
              } else {
                return group.$activate(self)
              }}, {$$s: self});
          }          return self;
        });
        
        $def(self, '$preprocessor', function $$preprocessor($a) {
          var block = $$preprocessor.$$p || nil, $post_args, args, self = this;

          $$preprocessor.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_document_processor', ["preprocessor", args], block.$to_proc());
        }, -1);
        
        $def(self, '$preprocessors?', function $Registry_preprocessors$ques$9() {
          var self = this;

          return self.preprocessor_extensions['$!']()['$!']()
        });
        
        $def(self, '$preprocessors', $return_ivar("preprocessor_extensions"));
        
        $def(self, '$tree_processor', function $$tree_processor($a) {
          var block = $$tree_processor.$$p || nil, $post_args, args, self = this;

          $$tree_processor.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_document_processor', ["tree_processor", args], block.$to_proc());
        }, -1);
        
        $def(self, '$tree_processors?', function $Registry_tree_processors$ques$10() {
          var self = this;

          return self.tree_processor_extensions['$!']()['$!']()
        });
        
        $def(self, '$tree_processors', $return_ivar("tree_processor_extensions"));
        $alias(self, "treeprocessor", "tree_processor");
        $alias(self, "treeprocessors?", "tree_processors?");
        $alias(self, "treeprocessors", "tree_processors");
        
        $def(self, '$postprocessor', function $$postprocessor($a) {
          var block = $$postprocessor.$$p || nil, $post_args, args, self = this;

          $$postprocessor.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_document_processor', ["postprocessor", args], block.$to_proc());
        }, -1);
        
        $def(self, '$postprocessors?', function $Registry_postprocessors$ques$11() {
          var self = this;

          return self.postprocessor_extensions['$!']()['$!']()
        });
        
        $def(self, '$postprocessors', $return_ivar("postprocessor_extensions"));
        
        $def(self, '$include_processor', function $$include_processor($a) {
          var block = $$include_processor.$$p || nil, $post_args, args, self = this;

          $$include_processor.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_document_processor', ["include_processor", args], block.$to_proc());
        }, -1);
        
        $def(self, '$include_processors?', function $Registry_include_processors$ques$12() {
          var self = this;

          return self.include_processor_extensions['$!']()['$!']()
        });
        
        $def(self, '$include_processors', $return_ivar("include_processor_extensions"));
        
        $def(self, '$docinfo_processor', function $$docinfo_processor($a) {
          var block = $$docinfo_processor.$$p || nil, $post_args, args, self = this;

          $$docinfo_processor.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_document_processor', ["docinfo_processor", args], block.$to_proc());
        }, -1);
        
        $def(self, '$docinfo_processors?', function $Registry_docinfo_processors$ques$13(location) {
          var self = this;

          
          if (location == null) location = nil;
          if ($truthy(self.docinfo_processor_extensions)) {
            if ($truthy(location)) {
              return $send(self.docinfo_processor_extensions, 'any?', [], function $$14(ext){
                
                if (ext == null) ext = nil;
                return ext.$config()['$[]']("location")['$=='](location);})
            } else {
              return true
            }
          } else {
            return false
          }        }, -1);
        
        $def(self, '$docinfo_processors', function $$docinfo_processors(location) {
          var self = this;

          
          if (location == null) location = nil;
          if ($truthy(self.docinfo_processor_extensions)) {
            if ($truthy(location)) {
              return $send(self.docinfo_processor_extensions, 'select', [], function $$15(ext){
                
                if (ext == null) ext = nil;
                return ext.$config()['$[]']("location")['$=='](location);})
            } else {
              return self.docinfo_processor_extensions
            }
          } else {
            return nil
          }        }, -1);
        
        $def(self, '$block', function $$block($a) {
          var block = $$block.$$p || nil, $post_args, args, self = this;

          $$block.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_syntax_processor', ["block", args], block.$to_proc());
        }, -1);
        
        $def(self, '$blocks?', function $Registry_blocks$ques$16() {
          var self = this;

          return self.block_extensions['$!']()['$!']()
        });
        
        $def(self, '$registered_for_block?', function $Registry_registered_for_block$ques$17(name, context) {
          var self = this, ext = nil;

          if ($truthy((ext = self.block_extensions['$[]'](name.$to_sym())))) {
            if ($truthy(ext.$config()['$[]']("contexts")['$include?'](context))) {
              return ext
            } else {
              return false
            }
          } else {
            return false
          }
        });
        
        $def(self, '$find_block_extension', function $$find_block_extension(name) {
          var self = this;

          return self.block_extensions['$[]'](name.$to_sym())
        });
        
        $def(self, '$block_macro', function $$block_macro($a) {
          var block = $$block_macro.$$p || nil, $post_args, args, self = this;

          $$block_macro.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_syntax_processor', ["block_macro", args], block.$to_proc());
        }, -1);
        
        $def(self, '$block_macros?', function $Registry_block_macros$ques$18() {
          var self = this;

          return self.block_macro_extensions['$!']()['$!']()
        });
        
        $def(self, '$registered_for_block_macro?', function $Registry_registered_for_block_macro$ques$19(name) {
          var self = this, ext = nil;

          if ($truthy((ext = self.block_macro_extensions['$[]'](name.$to_sym())))) {
            return ext
          } else {
            return false
          }
        });
        
        $def(self, '$find_block_macro_extension', function $$find_block_macro_extension(name) {
          var self = this;

          return self.block_macro_extensions['$[]'](name.$to_sym())
        });
        
        $def(self, '$inline_macro', function $$inline_macro($a) {
          var block = $$inline_macro.$$p || nil, $post_args, args, self = this;

          $$inline_macro.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          return $send(self, 'add_syntax_processor', ["inline_macro", args], block.$to_proc());
        }, -1);
        
        $def(self, '$inline_macros?', function $Registry_inline_macros$ques$20() {
          var self = this;

          return self.inline_macro_extensions['$!']()['$!']()
        });
        
        $def(self, '$registered_for_inline_macro?', function $Registry_registered_for_inline_macro$ques$21(name) {
          var self = this, ext = nil;

          if ($truthy((ext = self.inline_macro_extensions['$[]'](name.$to_sym())))) {
            return ext
          } else {
            return false
          }
        });
        
        $def(self, '$find_inline_macro_extension', function $$find_inline_macro_extension(name) {
          var self = this;

          return self.inline_macro_extensions['$[]'](name.$to_sym())
        });
        
        $def(self, '$inline_macros', function $$inline_macros() {
          var self = this;

          return self.inline_macro_extensions.$values()
        });
        
        $def(self, '$prefer', function $$prefer($a) {
          var block = $$prefer.$$p || nil, $post_args, args, self = this, extension = nil, arg0 = nil, extensions_store = nil;

          $$prefer.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          extension = ($eqeqeq($$('ProcessorExtension'), (arg0 = args.$shift())) ? (arg0) : ($send(self, 'send', [arg0].concat($to_a(args)), block.$to_proc())));
          extensions_store = self.$instance_variable_get(((("@") + (extension.$kind())) + "_extensions").$to_sym());
          extensions_store.$unshift(extensions_store.$delete(extension));
          return extension;
        }, -1);
        self.$private();
        
        $def(self, '$add_document_processor', function $$add_document_processor(kind, args) {
          var block = $$add_document_processor.$$p || nil, $b, $c, self = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, $ret_or_1 = nil, config = nil, processor = nil, extension = nil, processor_class = nil, processor_instance = nil;

          $$add_document_processor.$$p = null;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_symbol = $send(kind_name.$split(), 'map', [], function $$22(it){
            
            if (it == null) it = nil;
            return it.$capitalize();}).$join().$to_sym();
          kind_class = $$('Extensions').$const_get(kind_class_symbol, false);
          kind_java_class = ($truthy((($$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil)) ? ($$$($$$('AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol, false)) : (nil));
          kind_store = ($truthy(($ret_or_1 = self.$instance_variable_get(((("@") + (kind)) + "_extensions").$to_sym()))) ? ($ret_or_1) : (self.$instance_variable_set(((("@") + (kind)) + "_extensions").$to_sym(), [])));
          if ((block !== nil)) {
            
            config = self.$resolve_args(args, 1);
            (processor = kind_class.$new(config)).$singleton_class().$enable_dsl();
            if ($eqeq(block.$arity(), 0)) {
              $send(processor, 'instance_exec', [], block.$to_proc());
            } else {
              Opal.yield1(block, processor);
            }            if (!$truthy(processor['$process_block_given?']())) {
              self.$raise($$$('NoMethodError'), "No block specified to process " + (kind_name) + " extension at " + (block.$source_location().$join(":")));
            }            processor.$freeze();
            extension = $$('ProcessorExtension').$new(kind, processor);
          } else {
            
            $c = self.$resolve_args(args, 2), $b = $to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1]));
            if ($truthy((processor_class = $$('Helpers').$resolve_class(processor)))) {
              
              if (!($truthy($rb_lt(processor_class, kind_class)) || (($truthy(kind_java_class) && ($truthy($rb_lt(processor_class, kind_java_class))))))) {
                self.$raise($$$('ArgumentError'), "Invalid type for " + (kind_name) + " extension: " + (processor));
              }              processor_instance = processor_class.$new(config);
              processor_instance.$freeze();
              extension = $$('ProcessorExtension').$new(kind, processor_instance);
            } else if (($eqeqeq(kind_class, processor) || (($truthy(kind_java_class) && ($eqeqeq(kind_java_class, processor)))))) {
              
              processor.$update_config(config);
              processor.$freeze();
              extension = $$('ProcessorExtension').$new(kind, processor);
            } else {
              self.$raise($$$('ArgumentError'), "Invalid arguments specified for registering " + (kind_name) + " extension: " + (args));
            }          }          if ($eqeq(extension.$config()['$[]']("position"), ">>")) {
            
            kind_store.$unshift(extension);
          } else {
            
            kind_store['$<<'](extension);
          }          return extension;
        });
        
        $def(self, '$add_syntax_processor', function $$add_syntax_processor(kind, args) {
          var block = $$add_syntax_processor.$$p || nil, $b, $c, self = this, kind_name = nil, kind_class_symbol = nil, kind_class = nil, kind_java_class = nil, kind_store = nil, $ret_or_1 = nil, name = nil, config = nil, processor = nil, processor_class = nil, processor_instance = nil;

          $$add_syntax_processor.$$p = null;
          kind_name = kind.$to_s().$tr("_", " ");
          kind_class_symbol = $send(kind_name.$split(), 'map', [], function $$23(it){
            
            if (it == null) it = nil;
            return it.$capitalize();})['$<<']("Processor").$join().$to_sym();
          kind_class = $$('Extensions').$const_get(kind_class_symbol, false);
          kind_java_class = ($truthy((($$$('::', 'AsciidoctorJ', 'skip_raise')) ? 'constant' : nil)) ? ($$$($$$('AsciidoctorJ'), 'Extensions').$const_get(kind_class_symbol, false)) : (nil));
          kind_store = ($truthy(($ret_or_1 = self.$instance_variable_get(((("@") + (kind)) + "_extensions").$to_sym()))) ? ($ret_or_1) : (self.$instance_variable_set(((("@") + (kind)) + "_extensions").$to_sym(), $hash2([], {}))));
          if ((block !== nil)) {
            
            $c = self.$resolve_args(args, 2), $b = $to_ary($c), (name = ($b[0] == null ? nil : $b[0])), (config = ($b[1] == null ? nil : $b[1]));
            (processor = kind_class.$new(self.$as_symbol(name), config)).$singleton_class().$enable_dsl();
            if ($eqeq(block.$arity(), 0)) {
              $send(processor, 'instance_exec', [], block.$to_proc());
            } else {
              Opal.yield1(block, processor);
            }            if (!$truthy((name = self.$as_symbol(processor.$name())))) {
              self.$raise($$$('ArgumentError'), "No name specified for " + (kind_name) + " extension at " + (block.$source_location().$join(":")));
            }            if (!$truthy(processor['$process_block_given?']())) {
              self.$raise($$$('NoMethodError'), "No block specified to process " + (kind_name) + " extension at " + (block.$source_location().$join(":")));
            }            processor.$freeze();
            return ($b = [name, $$('ProcessorExtension').$new(kind, processor)], $send(kind_store, '[]=', $b), $b[$b.length - 1]);
          } else {
            
            $c = self.$resolve_args(args, 3), $b = $to_ary($c), (processor = ($b[0] == null ? nil : $b[0])), (name = ($b[1] == null ? nil : $b[1])), (config = ($b[2] == null ? nil : $b[2]));
            if ($truthy((processor_class = $$('Helpers').$resolve_class(processor)))) {
              
              if (!($truthy($rb_lt(processor_class, kind_class)) || (($truthy(kind_java_class) && ($truthy($rb_lt(processor_class, kind_java_class))))))) {
                self.$raise($$$('ArgumentError'), "Class specified for " + (kind_name) + " extension does not inherit from " + (kind_class) + ": " + (processor));
              }              processor_instance = processor_class.$new(self.$as_symbol(name), config);
              if (!$truthy((name = self.$as_symbol(processor_instance.$name())))) {
                self.$raise($$$('ArgumentError'), "No name specified for " + (kind_name) + " extension: " + (processor));
              }              processor_instance.$freeze();
              return ($b = [name, $$('ProcessorExtension').$new(kind, processor_instance)], $send(kind_store, '[]=', $b), $b[$b.length - 1]);
            } else if (($eqeqeq(kind_class, processor) || (($truthy(kind_java_class) && ($eqeqeq(kind_java_class, processor)))))) {
              
              processor.$update_config(config);
              if (!$truthy((name = ($truthy(name) ? (($b = [self.$as_symbol(name)], $send(processor, 'name=', $b), $b[$b.length - 1])) : (self.$as_symbol(processor.$name())))))) {
                self.$raise($$$('ArgumentError'), "No name specified for " + (kind_name) + " extension: " + (processor));
              }              processor.$freeze();
              return ($b = [name, $$('ProcessorExtension').$new(kind, processor)], $send(kind_store, '[]=', $b), $b[$b.length - 1]);
            } else {
              return self.$raise($$$('ArgumentError'), "Invalid arguments specified for registering " + (kind_name) + " extension: " + (args))
            }          }        });
        
        $def(self, '$reset', function $$reset() {
          var self = this;

          
          self.preprocessor_extensions = (self.tree_processor_extensions = (self.postprocessor_extensions = (self.include_processor_extensions = (self.docinfo_processor_extensions = (self.block_extensions = (self.block_macro_extensions = (self.inline_macro_extensions = nil)))))));
          return (self.document = nil);
        });
        
        $def(self, '$resolve_args', function $$resolve_args(args, expect) {
          var opts = nil, missing = nil;

          
          opts = ($eqeqeq($$$('Hash'), args['$[]'](-1)) ? (args.$pop()) : ($hash2([], {})));
          if ($eqeq(expect, 1)) {
            return opts
          }          if ($truthy($rb_gt((missing = $rb_minus($rb_minus(expect, 1), args.$size())), 0))) {
            args = $rb_plus(args, $$$('Array').$new(missing));
          } else if ($truthy($rb_lt(missing, 0))) {
            args.$pop(missing['$-@']());
          }          args['$<<'](opts);
          return args;
        });
        return $def(self, '$as_symbol', function $$as_symbol(name) {
          
          if ($truthy(name)) {
            return name.$to_sym()
          } else {
            return nil
          }
        });
      })($nesting[0], null, $nesting);
      return (function(self, $parent_nesting) {
        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        
        
        $def(self, '$generate_name', function $$generate_name() {
          var self = this;

          return "extgrp" + (self.$next_auto_id())
        });
        
        $def(self, '$next_auto_id', function $$next_auto_id() {
          var self = this, $ret_or_1 = nil;
          if (self.auto_id == null) self.auto_id = nil;

          
          self.auto_id = ($truthy(($ret_or_1 = self.auto_id)) ? ($ret_or_1) : (-1));
          return (self.auto_id = $rb_plus(self.auto_id, 1));
        });
        
        $def(self, '$groups', function $$groups() {
          var self = this, $ret_or_1 = nil;
          if (self.groups == null) self.groups = nil;

          return (self.groups = ($truthy(($ret_or_1 = self.groups)) ? ($ret_or_1) : ($hash2([], {}))))
        });
        
        $def(self, '$create', function $$create(name) {
          var block = $$create.$$p || nil, self = this, $ret_or_1 = nil;

          $$create.$$p = null;
          if (name == null) name = nil;
          if ((block !== nil)) {
            return $$('Registry').$new($hash(($truthy(($ret_or_1 = name)) ? ($ret_or_1) : (self.$generate_name())), block))
          } else {
            return $$('Registry').$new()
          }        }, -1);
        
        $def(self, '$register', function $$register($a) {
          var block = $$register.$$p || nil, $post_args, args, $b, self = this, argc = nil, resolved_group = nil, group = nil, $ret_or_1 = nil, name = nil;

          $$register.$$p = null;
          $post_args = $slice(arguments);
          args = $post_args;
          argc = args.$size();
          if ((block !== nil)) {
            resolved_group = block;
          } else if ($truthy((group = args.$pop()))) {
            resolved_group = ($truthy(($ret_or_1 = $$('Helpers').$resolve_class(group))) ? ($ret_or_1) : (group));
          } else {
            self.$raise($$$('ArgumentError'), "Extension group to register not specified");
          }          name = ($truthy(($ret_or_1 = args.$pop())) ? ($ret_or_1) : (self.$generate_name()));
          if (!$truthy(args['$empty?']())) {
            self.$raise($$$('ArgumentError'), "Wrong number of arguments (" + (argc) + " for 1..2)");
          }          return ($b = [name.$to_sym(), resolved_group], $send(self.$groups(), '[]=', $b), $b[$b.length - 1]);
        }, -1);
        
        $def(self, '$unregister_all', function $$unregister_all() {
          var self = this;

          
          self.groups = $hash2([], {});
          return nil;
        });
        return $def(self, '$unregister', function $$unregister($a) {
          var $post_args, names, self = this;

          
          $post_args = $slice(arguments);
          names = $post_args;
          $send(names, 'each_with_object', [self.$groups()], function $$24(group, catalog){
            
            if (group == null) group = nil;
            if (catalog == null) catalog = nil;
            return catalog.$delete(group.$to_sym());});
          return nil;
        }, -1);
      })(Opal.get_singleton_class(self), $nesting);
    })($nesting[0], $nesting)
  })($nesting[0], $nesting);
};

Opal.modules["asciidoctor/js/asciidoctor_ext/stylesheet"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('rstrip,read,join');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Stylesheets');

      var $proto = self.$$prototype;

      $proto.primary_stylesheet_data = nil;
      return $def(self, '$primary_stylesheet_data', function $$primary_stylesheet_data() {
        var self = this, $ret_or_1 = nil;

        return (self.primary_stylesheet_data = ($truthy(($ret_or_1 = self.primary_stylesheet_data)) ? ($ret_or_1) : ($$$('IO').$read($$$('File').$join("css", "asciidoctor.css")).$rstrip())))
      })
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/document"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $def = Opal.def, $nesting = []; Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Document');

      
      return $def(self, '$fill_datetime_attributes', function $$fill_datetime_attributes(attrs, input_mtime) {
        
        
      var $truthy = Opal.truthy;
      var $falsy = Opal.falsy;
      var nil = Opal.nil;
      var utc_offset;
      var source_date_epoch;
      var localdate;
      var localyear;
      var localtime;
      var localdatetime;
      var docdate;
      var doctime;

      var getYear = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCFullYear() : time.getFullYear()
      };
      var getMonth = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCMonth() : time.getMonth()
      };
      var getDay = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCDate() : time.getDate()
      };
      var getHours = function (time, utc_offset) {
        return utc_offset === 0 ? time.getUTCHours() : time.getHours()
      };

      var now = new Date();
      // See https://reproducible-builds.org/specs/source-date-epoch/
      if (Opal.const_get_qualified('::', 'ENV')['$key?']('SOURCE_DATE_EPOCH')) {
        now.setTime(parseInt(Opal.const_get_qualified('::', 'ENV')['$[]']('SOURCE_DATE_EPOCH')) * 1000);
        source_date_epoch = now;
        utc_offset = 0;  // utc
      } else {
        utc_offset = -now.getTimezoneOffset() / 60; // local date
      }
      // localdate and localyear
      if ($truthy((localdate = attrs['$[]']('localdate')))) {
        if ($falsy(localyear = attrs['$[]']('localyear'))) {
          localyear = localdate.indexOf('-') === 4 ? localdate.substring(0, 4) : nil;
          attrs['$[]=']('localyear', localyear);
        }
      } else {
        var now_year = getYear(now, utc_offset).toString();
        var now_month = ('0' + (getMonth(now, utc_offset) + 1)).slice(-2);
        var now_day = ('0' + getDay(now, utc_offset)).slice(-2);
        localdate = now_year + '-' + now_month + '-' + now_day;
        attrs['$[]=']('localdate', localdate);
        localyear = now_year;
        attrs['$[]=']('localyear', now_year);
      }
      // localtime
      if ($falsy((localtime = attrs['$[]']('localtime')))) {
        var hours = ('0' + (getHours(now, utc_offset))).slice(-2);
        var minutes = ('0' + (now.getMinutes())).slice(-2);
        var seconds = ('0' + (now.getSeconds())).slice(-2);
        var utc_offset_format;
        if (utc_offset === 0) {
          utc_offset_format = 'UTC';
        } else if (utc_offset > 0) {
          utc_offset_format = ('+0' + (utc_offset * 100)).slice(-5);
        } else {
          utc_offset_format = ('-0' + (-utc_offset * 100)).slice(-5);
        }
        localtime = hours + ':' + minutes + ':' + seconds + ' ' + utc_offset_format;
        attrs['$[]=']('localtime', localtime);
      }
      // localdatetime
      if ($falsy((localdatetime = attrs['$[]']('localdatetime')))) {
        localdatetime = localdate + ' ' + localtime;
        attrs['$[]=']('localdatetime', localdatetime);
      }

      // docdate, doctime and docdatetime should default to localdate, localtime and localdatetime if not otherwise set
      if ($truthy(source_date_epoch)) {
        input_mtime = source_date_epoch;
      } else if ($truthy(input_mtime)) {
        utc_offset = -input_mtime.getTimezoneOffset() / 60;
      } else {
        input_mtime = now;
      }

      // docdate and docyear
      if ($truthy(docdate = attrs['$[]']('docdate'))) {
        attrs['$[]=']('docyear', docdate.indexOf('-') === 4 ? docdate.substring(0, 4) : nil);
      } else {
        var mtime_year = getYear(input_mtime, utc_offset).toString();
        var mtime_month = ('0' + (getMonth(input_mtime, utc_offset) + 1)).slice(-2);
        var mtime_day = ('0' + (getDay(input_mtime, utc_offset))).slice(-2);
        docdate = mtime_year + '-' + mtime_month + '-' + mtime_day;
        attrs['$[]=']('docdate', docdate);
        if ($falsy(attrs['$[]']('docyear'))) {
          attrs['$[]=']('docyear', mtime_year);
        }
      }
      // doctime
      if ($falsy(doctime = attrs['$[]']('doctime'))) {
        var mtime_hours = ('0' + (getHours(input_mtime, utc_offset))).slice(-2);
        var mtime_minutes = ('0' + (input_mtime.getMinutes())).slice(-2);
        var mtime_seconds = ('0' + (input_mtime.getSeconds())).slice(-2);
        var utc_offset_format;
        if (utc_offset === 0) {
          utc_offset_format = 'UTC';
        } else if (utc_offset > 0) {
          utc_offset_format = ('+0' + (utc_offset * 100)).slice(-5);
        } else {
          utc_offset_format = ('-0' + (-utc_offset * 100)).slice(-5);
        }
        doctime = mtime_hours + ':' + mtime_minutes + ':' + mtime_seconds + ' ' + utc_offset_format;
        attrs['$[]=']('doctime', doctime);
      }
      // docdatetime
      if ($falsy(attrs['$[]']('docdatetime'))) {
        attrs['$[]=']('docdatetime', docdate + ' ' + doctime);
      }
      return nil
    
      })
    })($nesting[0], $$('AbstractBlock'))
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/substitutors"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $def = Opal.def, $nesting = []; Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base) {
      var self = $module($base, 'Substitutors');

      
      return $def(self, '$sub_placeholder', function $$sub_placeholder(format_string, replacement) {
        
        return format_string.replace('%s', replacement);
      })
    })($nesting[0])
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/parser"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $klass = Opal.klass, $truthy = Opal.truthy, $defs = Opal.defs, $nesting = []; Opal.nil;

  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $super) {
      var self = $klass($base, $super, 'Parser');

      
      if ($truthy(String.prototype.repeat)) {
        return $defs(self, '$uniform?', function $Parser_uniform$ques$1(str, chr, len) {
          
          return chr.repeat(len) === str;
        })
      } else {
        return $defs(self, '$uniform?', function $Parser_uniform$ques$2(str, chr, len) {
          
          return Array.apply(null, { length: len }).map(function () { return chr }).join('') === str;
        })
      }
    })($nesting[0], null)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext/syntax_highlighter"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $truthy = Opal.truthy, $def = Opal.def, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('key?,registry,[],include?,include,empty?,debug,logger,join,keys');
  return (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting);

    return (function($base, $parent_nesting) {
      var self = $module($base, 'SyntaxHighlighter');

      var $nesting = [self].concat($parent_nesting);

      return (function($base, $parent_nesting) {
        var self = $module($base, 'Factory');

        var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting);

        return $def(self, '$for', function $Factory_for$1(name) {
          var self = this;

          if ($truthy(self.$registry()['$key?'](name))) {
            return self.$registry()['$[]'](name)
          } else {
            
            if (!$truthy(self['$include?']($$('Logging')))) {
              self.$include($$('Logging'));
            }            if ($truthy(self.$registry()['$empty?']())) {
              self.$logger().$debug("no syntax highlighter available, functionality disabled.");
            } else {
              self.$logger().$debug("syntax highlighter named '" + (name) + "' is not available, must be one of: '" + (self.$registry().$keys().$join("', '")) + "'.");
            }            return nil;
          }
        })
      })($nesting[0], $nesting)
    })($nesting[0], $nesting)
  })($nesting[0], $nesting)
};

Opal.modules["asciidoctor/js/asciidoctor_ext"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("asciidoctor/js/asciidoctor_ext/stylesheet");
  self.$require("asciidoctor/js/asciidoctor_ext/document");
  self.$require("asciidoctor/js/asciidoctor_ext/substitutors");
  self.$require("asciidoctor/js/asciidoctor_ext/parser");
  self.$require("asciidoctor/js/asciidoctor_ext/syntax_highlighter");
  
// Load specific runtime
self.$require("asciidoctor/js/asciidoctor_ext/node");
};

Opal.modules["asciidoctor/js/opal_ext/logger"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var $klass = Opal.klass, $def = Opal.def, $truthy = Opal.truthy, $rb_lt = Opal.rb_lt, $nesting = [], nil = Opal.nil;

  Opal.add_stubs('chr,rjust,message_as_string,<,write,call,[]');
  return (function($base, $super, $parent_nesting) {
    var self = $klass($base, $super, 'Logger');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $proto = self.$$prototype;

    $proto.level = $proto.progname = $proto.pipe = $proto.formatter = nil;
    
    (function($base, $super) {
      var self = $klass($base, $super, 'Formatter');

      
      return $def(self, '$call', function $$call(severity, time, progname, msg) {
        var self = this, time_format = nil;

        
        time_format = time.getFullYear() + '-' + ('0'+(time.getMonth()+1)).slice(-2) + '-' + ('0'+time.getDate()).slice(-2) + 'T' + ('0'+time.getHours()).slice(-2) + ':' + ('0'+time.getMinutes()).slice(-2) + ':' + ('0'+time.getSeconds()).slice(-2) + '.' + ('00' + new Date().getMilliseconds() * 1000).slice(-6);
        return "" + (severity.$chr()) + ", [" + (time_format) + "] " + (severity.$rjust(5)) + " -- " + (progname) + ": " + (self.$message_as_string(msg));
      })
    })($nesting[0], null);
    return $def(self, '$add', function $$add(severity, message, progname) {
      var block = $$add.$$p || nil, self = this, $ret_or_1 = nil;

      $$add.$$p = null;
      if (message == null) message = nil;
      if (progname == null) progname = nil;
      if ($truthy($rb_lt((severity = ($truthy(($ret_or_1 = severity)) ? ($ret_or_1) : ($$('UNKNOWN')))), self.level))) {
        return true
      }      progname = ($truthy(($ret_or_1 = progname)) ? ($ret_or_1) : (self.progname));
      if (!$truthy(message)) {
        if ((block !== nil)) {
          message = Opal.yieldX(block, []);
        } else {
          
          message = progname;
          progname = self.progname;
        }
      }      self.pipe.$write(self.formatter.$call(($truthy(($ret_or_1 = $$('SEVERITY_LABELS')['$[]'](severity))) ? ($ret_or_1) : ("ANY")), new Date(), progname, message));
      return true;
    }, -2);
  })($nesting[0], null, $nesting)
};

Opal.modules["asciidoctor/js/postscript"] = function(Opal) {/* Generated by Opal 1.7.3 */
  var self = Opal.top; Opal.nil;

  Opal.add_stubs('require');
  
  self.$require("asciidoctor/converter/composite");
  self.$require("asciidoctor/converter/html5");
  self.$require("asciidoctor/extensions");
  self.$require("asciidoctor/js/asciidoctor_ext");
  return self.$require("asciidoctor/js/opal_ext/logger");
};

Opal.queue(function(Opal) {/* Generated by Opal 1.7.3 */
  var $module = Opal.module, $const_set = Opal.const_set, $send = Opal.send, $to_ary = Opal.to_ary, $defs = Opal.defs, $def = Opal.def, $truthy = Opal.truthy, $hash2 = Opal.hash2, $eqeq = Opal.eqeq, $rb_minus = Opal.rb_minus, $regexp = Opal.regexp, self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.$$$;

  Opal.add_stubs('require,==,to_h,sort,map,constants,const_get,downcase,to_s,<=>,upcase,[],values,new,attr_reader,instance_variable_set,send,singleton_class,<<,define,dirname,absolute_path,join,home,pwd,to_set,tap,each,chr,each_key,[]=,slice,length,-,merge,default=,drop,insert');
  
  self.$require("set");
  self.$require("asciidoctor/js");
  (function($base, $parent_nesting) {
    var self = $module($base, 'Asciidoctor');

    var $nesting = [self].concat($parent_nesting), $$ = Opal.$r($nesting), $ret_or_1 = nil;

    
    $const_set($nesting[0], 'RUBY_ENGINE_OPAL', $const_set($nesting[0], 'RUBY_ENGINE', $$$('RUBY_ENGINE'))['$==']("opal"));
    (function($base, $parent_nesting) {
      var self = $module($base, 'SafeMode');

      var $nesting = [self].concat($parent_nesting);

      
      $const_set($nesting[0], 'UNSAFE', 0);
      $const_set($nesting[0], 'SAFE', 1);
      $const_set($nesting[0], 'SERVER', 10);
      $const_set($nesting[0], 'SECURE', 20);
      self.names_by_value = $send($send(self.$constants(false), 'map', [], function $SafeMode$1(sym){var self = $SafeMode$1.$$s == null ? this : $SafeMode$1.$$s;

        
        if (sym == null) sym = nil;
        return [self.$const_get(sym), sym.$to_s().$downcase()];}, {$$s: self}), 'sort', [], function $SafeMode$2($mlhs_tmp1, $mlhs_tmp2){var $a, $b, a = nil, b = nil;

        
        if ($mlhs_tmp1 == null) $mlhs_tmp1 = nil;
        if ($mlhs_tmp2 == null) $mlhs_tmp2 = nil;
        $b = $mlhs_tmp1, $a = $to_ary($b), (a = ($a[0] == null ? nil : $a[0]));
        $b = $mlhs_tmp2, $a = $to_ary($b), (b = ($a[0] == null ? nil : $a[0]));
        return a['$<=>'](b);}, {$$has_top_level_mlhs_arg: true}).$to_h();
      $defs(self, '$value_for_name', function $$value_for_name(name) {
        var self = this;

        return self.$const_get(name.$upcase(), false)
      });
      $defs(self, '$name_for_value', function $$name_for_value(value) {
        var self = this;
        if (self.names_by_value == null) self.names_by_value = nil;

        return self.names_by_value['$[]'](value)
      });
      return $defs(self, '$names', function $$names() {
        var self = this;
        if (self.names_by_value == null) self.names_by_value = nil;

        return self.names_by_value.$values()
      });
    })($nesting[0], $nesting);
    (function($base, $parent_nesting) {
      var self = $module($base, 'Compliance');

      
      self.keys = $$$('Set').$new();
      (function(self, $parent_nesting) {
        
        
        self.$attr_reader("keys");
        return $def(self, '$define', function $$define(key, value) {
          var self = this;
          if (self.keys == null) self.keys = nil;

          
          self.$instance_variable_set("@" + (key), value);
          self.$singleton_class().$send("attr_accessor", key);
          self.keys['$<<'](key);
          return nil;
        });
      })(Opal.get_singleton_class(self));
      self.$define("block_terminates_paragraph", true);
      self.$define("strict_verbatim_paragraphs", true);
      self.$define("underline_style_section_titles", true);
      self.$define("unwrap_standalone_preamble", true);
      self.$define("attribute_missing", "skip");
      self.$define("attribute_undefined", "drop-line");
      self.$define("shorthand_property_syntax", true);
      self.$define("natural_xrefs", true);
      self.$define("unique_id_start_index", 2);
      return self.$define("markdown_syntax", true);
    })($nesting[0]);
    if (!$truthy((($$('ROOT_DIR', 'skip_raise')) ? 'constant' : nil))) {
      $const_set($nesting[0], 'ROOT_DIR', $$$('File').$dirname($$$('File').$absolute_path(".")));
    }    $const_set($nesting[0], 'LIB_DIR', $$$('File').$join($$('ROOT_DIR'), "lib"));
    $const_set($nesting[0], 'DATA_DIR', $$$('File').$join($$('ROOT_DIR'), "data"));
    $const_set($nesting[0], 'USER_HOME', (function() { try {
      return $$$('Dir').$home()
    } catch ($err) {
      if (Opal.rescue($err, [$$('StandardError')])) {
        try {
          
          if ($truthy(($ret_or_1 = $$$('ENV')['$[]']("HOME")))) {
            return $ret_or_1
          } else {
            return $$$('Dir').$pwd()
          };
        } finally { Opal.pop_exception(); }
      } else { throw $err; }
    }})());
    $const_set($nesting[0], 'LF', "\n");
    $const_set($nesting[0], 'NULL', "\x00");
    $const_set($nesting[0], 'TAB', "\t");
    $const_set($nesting[0], 'MAX_INT', 9007199254740991);
    $const_set($nesting[0], 'UTF_8', $$$($$$('Encoding'), 'UTF_8'));
    $const_set($nesting[0], 'BOM_BYTES_UTF_8', [239, 187, 191]);
    $const_set($nesting[0], 'BOM_BYTES_UTF_16LE', [255, 254]);
    $const_set($nesting[0], 'BOM_BYTES_UTF_16BE', [254, 255]);
    $const_set($nesting[0], 'FILE_READ_MODE', ($truthy($$('RUBY_ENGINE_OPAL')) ? ("r") : ("rb:utf-8:utf-8")));
    $const_set($nesting[0], 'URI_READ_MODE', $$('FILE_READ_MODE'));
    $const_set($nesting[0], 'FILE_WRITE_MODE', ($truthy($$('RUBY_ENGINE_OPAL')) ? ("w") : ("w:utf-8")));
    $const_set($nesting[0], 'DEFAULT_DOCTYPE', "article");
    $const_set($nesting[0], 'DEFAULT_BACKEND', "html5");
    $const_set($nesting[0], 'DEFAULT_STYLESHEET_KEYS', ["", "DEFAULT"].$to_set());
    $const_set($nesting[0], 'DEFAULT_STYLESHEET_NAME', "asciidoctor.css");
    $const_set($nesting[0], 'BACKEND_ALIASES', $hash2(["html", "docbook"], {"html": "html5", "docbook": "docbook5"}));
    $const_set($nesting[0], 'DEFAULT_PAGE_WIDTHS', $hash2(["docbook"], {"docbook": 425}));
    $const_set($nesting[0], 'DEFAULT_EXTENSIONS', $hash2(["html", "docbook", "pdf", "epub", "manpage", "asciidoc"], {"html": ".html", "docbook": ".xml", "pdf": ".pdf", "epub": ".epub", "manpage": ".man", "asciidoc": ".adoc"}));
    $const_set($nesting[0], 'ASCIIDOC_EXTENSIONS', $hash2([".adoc", ".asciidoc", ".asc", ".ad", ".txt"], {".adoc": true, ".asciidoc": true, ".asc": true, ".ad": true, ".txt": true}));
    $const_set($nesting[0], 'SETEXT_SECTION_LEVELS', $hash2(["=", "-", "~", "^", "+"], {"=": 0, "-": 1, "~": 2, "^": 3, "+": 4}));
    $const_set($nesting[0], 'ADMONITION_STYLES', ["NOTE", "TIP", "IMPORTANT", "WARNING", "CAUTION"].$to_set());
    $const_set($nesting[0], 'ADMONITION_STYLE_HEADS', $send($$$('Set').$new(), 'tap', [], function $Asciidoctor$3(accum){
      
      if (accum == null) accum = nil;
      return $send($$('ADMONITION_STYLES'), 'each', [], function $$4(s){
        
        if (s == null) s = nil;
        return accum['$<<'](s.$chr());});}));
    $const_set($nesting[0], 'PARAGRAPH_STYLES', ["comment", "example", "literal", "listing", "normal", "open", "pass", "quote", "sidebar", "source", "verse", "abstract", "partintro"].$to_set());
    $const_set($nesting[0], 'VERBATIM_STYLES', ["literal", "listing", "source", "verse"].$to_set());
    $const_set($nesting[0], 'DELIMITED_BLOCKS', $hash2(["--", "----", "....", "====", "****", "____", "++++", "|===", ",===", ":===", "!===", "////", "```"], {"--": ["open", ["comment", "example", "literal", "listing", "pass", "quote", "sidebar", "source", "verse", "admonition", "abstract", "partintro"].$to_set()], "----": ["listing", ["literal", "source"].$to_set()], "....": ["literal", ["listing", "source"].$to_set()], "====": ["example", ["admonition"].$to_set()], "****": ["sidebar", $$$('Set').$new()], "____": ["quote", ["verse"].$to_set()], "++++": ["pass", ["stem", "latexmath", "asciimath"].$to_set()], "|===": ["table", $$$('Set').$new()], ",===": ["table", $$$('Set').$new()], ":===": ["table", $$$('Set').$new()], "!===": ["table", $$$('Set').$new()], "////": ["comment", $$$('Set').$new()], "```": ["fenced_code", $$$('Set').$new()]}));
    $const_set($nesting[0], 'DELIMITED_BLOCK_HEADS', $send($hash2([], {}), 'tap', [], function $Asciidoctor$5(accum){
      
      if (accum == null) accum = nil;
      return $send($$('DELIMITED_BLOCKS'), 'each_key', [], function $$6(k){var $b;

        
        if (k == null) k = nil;
        return ($b = [k.$slice(0, 2), true], $send(accum, '[]=', $b), $b[$b.length - 1]);});}));
    $const_set($nesting[0], 'DELIMITED_BLOCK_TAILS', $send($hash2([], {}), 'tap', [], function $Asciidoctor$7(accum){
      
      if (accum == null) accum = nil;
      return $send($$('DELIMITED_BLOCKS'), 'each_key', [], function $$8(k){var $b;

        
        if (k == null) k = nil;
        if ($eqeq(k.$length(), 4)) {
          return ($b = [k, k['$[]']($rb_minus(k.$length(), 1))], $send(accum, '[]=', $b), $b[$b.length - 1])
        } else {
          return nil
        }});}));
    $const_set($nesting[0], 'CAPTION_ATTRIBUTE_NAMES', $hash2(["example", "figure", "listing", "table"], {"example": "example-caption", "figure": "figure-caption", "listing": "listing-caption", "table": "table-caption"}));
    $const_set($nesting[0], 'LAYOUT_BREAK_CHARS', $hash2(["'", "<"], {"'": "thematic_break", "<": "page_break"}));
    $const_set($nesting[0], 'MARKDOWN_THEMATIC_BREAK_CHARS', $hash2(["-", "*", "_"], {"-": "thematic_break", "*": "thematic_break", "_": "thematic_break"}));
    $const_set($nesting[0], 'HYBRID_LAYOUT_BREAK_CHARS', $$('LAYOUT_BREAK_CHARS').$merge($$('MARKDOWN_THEMATIC_BREAK_CHARS')));
    $const_set($nesting[0], 'NESTABLE_LIST_CONTEXTS', ["ulist", "olist", "dlist"]);
    $const_set($nesting[0], 'ORDERED_LIST_STYLES', ["arabic", "loweralpha", "lowerroman", "upperalpha", "upperroman"]);
    $const_set($nesting[0], 'ORDERED_LIST_KEYWORDS', $hash2(["loweralpha", "lowerroman", "upperalpha", "upperroman"], {"loweralpha": "a", "lowerroman": "i", "upperalpha": "A", "upperroman": "I"}));
    $const_set($nesting[0], 'ATTR_REF_HEAD', "{");
    $const_set($nesting[0], 'LIST_CONTINUATION', "+");
    $const_set($nesting[0], 'HARD_LINE_BREAK', " +");
    $const_set($nesting[0], 'LINE_CONTINUATION', " \\");
    $const_set($nesting[0], 'LINE_CONTINUATION_LEGACY', " +");
    $const_set($nesting[0], 'BLOCK_MATH_DELIMITERS', $hash2(["asciimath", "latexmath"], {"asciimath": ["\\$", "\\$"], "latexmath": ["\\[", "\\]"]}));
    $const_set($nesting[0], 'INLINE_MATH_DELIMITERS', $hash2(["asciimath", "latexmath"], {"asciimath": ["\\$", "\\$"], "latexmath": ["\\(", "\\)"]}));
    $const_set($nesting[0], 'STEM_TYPE_ALIASES', $hash2(["latexmath", "latex", "tex"], {"latexmath": "latexmath", "latex": "latexmath", "tex": "latexmath"}))['$default=']("asciimath");
    $const_set($nesting[0], 'FONT_AWESOME_VERSION', "4.7.0");
    $const_set($nesting[0], 'HIGHLIGHT_JS_VERSION', "9.18.3");
    $const_set($nesting[0], 'MATHJAX_VERSION', "2.7.9");
    $const_set($nesting[0], 'DEFAULT_ATTRIBUTES', $hash2(["appendix-caption", "appendix-refsig", "caution-caption", "chapter-refsig", "example-caption", "figure-caption", "important-caption", "last-update-label", "note-caption", "part-refsig", "prewrap", "sectids", "section-refsig", "table-caption", "tip-caption", "toc-placement", "toc-title", "untitled-label", "version-label", "warning-caption"], {"appendix-caption": "Appendix", "appendix-refsig": "Appendix", "caution-caption": "Caution", "chapter-refsig": "Chapter", "example-caption": "Example", "figure-caption": "Figure", "important-caption": "Important", "last-update-label": "Last updated", "note-caption": "Note", "part-refsig": "Part", "prewrap": "", "sectids": "", "section-refsig": "Section", "table-caption": "Table", "tip-caption": "Tip", "toc-placement": "auto", "toc-title": "Table of Contents", "untitled-label": "Untitled", "version-label": "Version", "warning-caption": "Warning"}));
    $const_set($nesting[0], 'FLEXIBLE_ATTRIBUTES', ["sectnums"]);
    $const_set($nesting[0], 'INTRINSIC_ATTRIBUTES', $hash2(["startsb", "endsb", "vbar", "caret", "asterisk", "tilde", "plus", "backslash", "backtick", "blank", "empty", "sp", "two-colons", "two-semicolons", "nbsp", "deg", "zwsp", "quot", "apos", "lsquo", "rsquo", "ldquo", "rdquo", "wj", "brvbar", "pp", "cpp", "amp", "lt", "gt"], {"startsb": "[", "endsb": "]", "vbar": "|", "caret": "^", "asterisk": "*", "tilde": "~", "plus": "&#43;", "backslash": "\\", "backtick": "`", "blank": "", "empty": "", "sp": " ", "two-colons": "::", "two-semicolons": ";;", "nbsp": "&#160;", "deg": "&#176;", "zwsp": "&#8203;", "quot": "&#34;", "apos": "&#39;", "lsquo": "&#8216;", "rsquo": "&#8217;", "ldquo": "&#8220;", "rdquo": "&#8221;", "wj": "&#8288;", "brvbar": "&#166;", "pp": "&#43;&#43;", "cpp": "C&#43;&#43;", "amp": "&", "lt": "<", "gt": ">"}));
    $const_set($nesting[0], 'QUOTE_SUBS', $send($hash2([], {}), 'tap', [], function $Asciidoctor$9(accum){var normal = nil, compat = nil;

      
      if (accum == null) accum = nil;
      accum['$[]='](false, (normal = [["strong", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?\\*\\*(", $$('CC_ALL'), "+?)\\*\\*"], 'm')], ["strong", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?\\*(\\S|\\S", $$('CC_ALL'), "*?\\S)\\*(?!", $$('CG_WORD'), ")"], 'm')], ["double", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?\"`(\\S|\\S", $$('CC_ALL'), "*?\\S)`\"(?!", $$('CG_WORD'), ")"], 'm')], ["single", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:`}])(?:\\[([^\\]]+)\\])?'`(\\S|\\S", $$('CC_ALL'), "*?\\S)`'(?!", $$('CG_WORD'), ")"], 'm')], ["monospaced", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?``(", $$('CC_ALL'), "+?)``"], 'm')], ["monospaced", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:\"'`}])(?:\\[([^\\]]+)\\])?`(\\S|\\S", $$('CC_ALL'), "*?\\S)`(?![", $$('CC_WORD'), "\"'`])"], 'm')], ["emphasis", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?__(", $$('CC_ALL'), "+?)__"], 'm')], ["emphasis", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?_(\\S|\\S", $$('CC_ALL'), "*?\\S)_(?!", $$('CG_WORD'), ")"], 'm')], ["mark", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?##(", $$('CC_ALL'), "+?)##"], 'm')], ["mark", "constrained", $regexp(["(^|[^", $$('CC_WORD'), "&;:}])(?:\\[([^\\]]+)\\])?#(\\S|\\S", $$('CC_ALL'), "*?\\S)#(?!", $$('CG_WORD'), ")"], 'm')], ["superscript", "unconstrained", /\\?(?:\[([^\]]+)\])?\^(\S+?)\^/], ["subscript", "unconstrained", /\\?(?:\[([^\]]+)\])?~(\S+?)~/]]));
      accum['$[]='](true, (compat = normal.$drop(0)));
      compat['$[]='](2, ["double", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?``(\\S|\\S", $$('CC_ALL'), "*?\\S)''(?!", $$('CG_WORD'), ")"], 'm')]);
      compat['$[]='](3, ["single", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?`(\\S|\\S", $$('CC_ALL'), "*?\\S)'(?!", $$('CG_WORD'), ")"], 'm')]);
      compat['$[]='](4, ["monospaced", "unconstrained", $regexp(["\\\\?(?:\\[([^\\]]+)\\])?\\+\\+(", $$('CC_ALL'), "+?)\\+\\+"], 'm')]);
      compat['$[]='](5, ["monospaced", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?\\+(\\S|\\S", $$('CC_ALL'), "*?\\S)\\+(?!", $$('CG_WORD'), ")"], 'm')]);
      return compat.$insert(3, ["emphasis", "constrained", $regexp(["(^|[^", $$('CC_WORD'), ";:}])(?:\\[([^\\]]+)\\])?'(\\S|\\S", $$('CC_ALL'), "*?\\S)'(?!", $$('CG_WORD'), ")"], 'm')]);}));
    $const_set($nesting[0], 'REPLACEMENTS', [[/\\?\(C\)/, "&#169;", "none"], [/\\?\(R\)/, "&#174;", "none"], [/\\?\(TM\)/, "&#8482;", "none"], [/(?: |\n|^|\\)--(?: |\n|$)/, "&#8201;&#8212;&#8201;", "none"], [$regexp(["(", $$('CG_WORD'), ")\\\\?--(?=", $$('CG_WORD'), ")"]), "&#8212;&#8203;", "leading"], [/\\?\.\.\./, "&#8230;&#8203;", "none"], [/\\?`'/, "&#8217;", "none"], [$regexp(["(", $$('CG_ALNUM'), ")\\\\?'(?=", $$('CG_ALPHA'), ")"]), "&#8217;", "leading"], [/\\?-&gt;/, "&#8594;", "none"], [/\\?=&gt;/, "&#8658;", "none"], [/\\?&lt;-/, "&#8592;", "none"], [/\\?&lt;=/, "&#8656;", "none"], [/\\?(&)amp;((?:[a-zA-Z][a-zA-Z]+\d{0,2}|#\d\d\d{0,4}|#x[\da-fA-F][\da-fA-F][\da-fA-F]{0,3});)/, "", "bounding"]]);
    return nil;
  })($nesting[0], $nesting);
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/core_ext");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/helpers");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/logging");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/rx");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/substitutors");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/version");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/abstract_node");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/abstract_block");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/attribute_list");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/block");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/callouts");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/converter");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/document");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/inline");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/list");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/parser");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/path_resolver");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/reader");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/section");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/stylesheets");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/table");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/writer");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/load");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/convert");
  
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/syntax_highlighter");
  self.$require("asciidoctor.rb"+ '/../' + "asciidoctor/timings");
  return self.$require("asciidoctor/js/postscript");});


/* global Opal */

/**
 * Convert a JSON to an (Opal) Hash.
 * @private
 */
const toHash = function (object) {
  return object && !object.$$is_hash ? Opal.hash2(Object.keys(object), object) : object
};

/**
 * Convert an (Opal) Hash to JSON.
 * @private
 */
const fromHash = function (hash) {
  const object = {};
  if (hash) {
    const stringMap = hash.$$smap;
    for (const key in stringMap) {
      const value = stringMap[key];
      object[key] = value === Opal.nil ? undefined : value;
    }
    const numericMap = hash.$$map;
    if (numericMap) {
      const positional = [];
      for (const key in numericMap) {
        const entry = numericMap[key];
        const value = entry.value;
        const index = entry.key - 1;
        positional[index] = value === Opal.nil ? undefined : value;
      }
      if (positional.length > 0) {
        object.$positional = positional;
      }
    }
  }
  return object
};

const fromHashKeys = function (hash) {
  const object = {};
  if (hash) {
    const data = hash.$$keys;
    for (const key in data) {
      const value = data[key].value;
      object[key.toString()] = value === Opal.nil ? undefined : value;
    }
  }
  return object
};

/**
 * @private
 */
const prepareOptions = function (options) {
  options = toHash(options);
  if (options) {
    const converter = options['$[]']('converter');
    if (converter && converter !== Opal.nil) {
      options['$[]=']('converter', bridgeConverter(converter));
    }
    const attrs = options['$[]']('attributes');
    if (attrs && typeof attrs === 'object' && attrs.constructor.name === 'Object') {
      options = options.$dup();
      options['$[]=']('attributes', toHash(attrs));
    }
  }
  return options
};

const bridgeConverter = function (converter) {
  const buildBackendTraitsFromObject = function (obj) {
    return Object.assign({},
      obj.basebackend ? { basebackend: obj.basebackend } : {},
      obj.outfilesuffix ? { outfilesuffix: obj.outfilesuffix } : {},
      obj.filetype ? { filetype: obj.filetype } : {},
      obj.htmlsyntax ? { htmlsyntax: obj.htmlsyntax } : {},
      obj.supports_templates ? { supports_templates: obj.supports_templates } : {}
    )
  };
  const assignBackendTraitsToInstance = function (obj, instance) {
    if (obj.backend_traits) {
      instance.backend_traits = toHash(obj.backend_traits);
    } else if (obj.backendTraits) {
      instance.backend_traits = toHash(obj.backendTraits);
    } else if (obj.basebackend || obj.outfilesuffix || obj.filetype || obj.htmlsyntax || obj.supports_templates) {
      instance.backend_traits = toHash(buildBackendTraitsFromObject(obj));
    }
  };
  const bridgeHandlesMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$handles?', 'handles', function () {
      return true
    });
  };
  const bridgeComposedMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$composed', 'composed');
  };
  const bridgeEqEqMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$==', '==', function (other) {
      return instance === other
    });
  };
  const bridgeSendMethodToInstance = function (obj, instance) {
    bridgeMethodToInstance(obj, instance, '$send', 'send', function (symbol) {
      const [, ...args] = Array.from(arguments);
      const func = instance['$' + symbol];
      if (func) {
        return func.apply(instance, args)
      }
      throw new Error(`undefined method \`${symbol}\` for \`${instance.toString()}\``)
    });
  };
  const bridgeMethodToInstance = function (obj, instance, methodName, functionName, defaultImplementation) {
    if (typeof obj[methodName] === 'undefined') {
      if (typeof obj[functionName] === 'function') {
        instance[methodName] = obj[functionName];
      } else if (defaultImplementation) {
        instance[methodName] = defaultImplementation;
      }
    }
  };
  const addRespondToMethod = function (instance) {
    if (typeof instance['$respond_to?'] !== 'function') {
      instance['$respond_to?'] = function (name) {
        return typeof this[name] === 'function'
      };
    }
  };
  if (typeof converter === 'function') {
    // Class
    const object = initializeClass(ConverterBase, converter.constructor.name, {
      initialize: function (backend, opts) {
        const self = this;
        const result = new converter(backend, opts); // eslint-disable-line
        Object.assign(this, result);
        assignBackendTraitsToInstance(result, self);
        const propertyNames = Object.getOwnPropertyNames(converter.prototype);
        for (let i = 0; i < propertyNames.length; i++) {
          const propertyName = propertyNames[i];
          if (propertyName !== 'constructor') {
            self[propertyName] = result[propertyName];
          }
        }
        if (typeof result.$convert === 'undefined' && typeof result.convert === 'function') {
          self.$convert = result.convert;
        }
        bridgeHandlesMethodToInstance(result, self);
        bridgeComposedMethodToInstance(result, self);
        addRespondToMethod(self);
        self.super(backend, opts);
      }
    });
    object.$extend(ConverterBackendTraits);
    return object
  }
  if (typeof converter === 'object') {
    // Instance
    if (typeof converter.$convert === 'undefined' && typeof converter.convert === 'function') {
      converter.$convert = converter.convert;
    }
    assignBackendTraitsToInstance(converter, converter);
    if (converter.backend_traits) {
      // "extends" ConverterBackendTraits
      const converterBackendTraitsFunctionNames = [
        'basebackend',
        'filetype',
        'htmlsyntax',
        'outfilesuffix',
        'supports_templates',
        'supports_templates?',
        'init_backend_traits',
        'backend_traits'
      ];
      for (const functionName of converterBackendTraitsFunctionNames) {
        converter['$' + functionName] = ConverterBackendTraits.prototype['$' + functionName];
      }
      converter.$$meta = ConverterBackendTraits;
    }
    bridgeHandlesMethodToInstance(converter, converter);
    bridgeComposedMethodToInstance(converter, converter);
    bridgeEqEqMethodToInstance(converter, converter);
    bridgeSendMethodToInstance(converter, converter);
    addRespondToMethod(converter);
    return converter
  }
  return converter
};

function initializeClass (superClass, className, functions, defaultFunctions, argProxyFunctions) {
  const scope = Opal.klass(Opal.Object, superClass, className, function () { });
  let postConstructFunction;
  let initializeFunction;
  let constructorFunction;
  const defaultFunctionsOverridden = {};
  for (const functionName in functions) {
    if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
      (function (functionName) {
        const userFunction = functions[functionName];
        if (functionName === 'postConstruct') {
          postConstructFunction = userFunction;
        } else if (functionName === 'initialize') {
          initializeFunction = userFunction;
        } else if (functionName === 'constructor') {
          constructorFunction = userFunction;
        } else {
          if (defaultFunctions && Object.prototype.hasOwnProperty.call(defaultFunctions, functionName)) {
            defaultFunctionsOverridden[functionName] = true;
          }
          let $function;
          Opal.def(scope, '$' + functionName, ($function = function () {
            let args;
            if (argProxyFunctions && Object.prototype.hasOwnProperty.call(argProxyFunctions, functionName)) {
              args = argProxyFunctions[functionName](arguments);
            } else {
              args = arguments;
            }
            // append Ruby block as the final argument
            const $block = $function.$$p;
            if ($block) {
              args[args.length] = function () { return Opal.yield1($block) };
              args.length += 1;
              $function.$$p = null;
            }
            return userFunction.apply(this, args)
          }));
        }
      }(functionName));
    }
  }
  let initialize;
  if (typeof constructorFunction === 'function') {
    initialize = function () {
      const args = Array.from(arguments);
      for (let i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i]);
        }
      }
      args.unshift(null);
      const result = new (Function.prototype.bind.apply(constructorFunction, args)); // eslint-disable-line
      Object.assign(this, result);
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)();
      }
    };
  } else if (typeof initializeFunction === 'function') {
    initialize = function () {
      const args = Array.from(arguments);
      for (let i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i]);
        }
      }
      initializeFunction.apply(this, args);
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)();
      }
    };
  } else {
    initialize = function () {
      Opal.send(this, Opal.find_super_dispatcher(this, 'initialize', initialize));
      if (typeof postConstructFunction === 'function') {
        postConstructFunction.bind(this)();
      }
    };
  }
  Opal.def(scope, '$initialize', initialize);
  let $superFunction;
  Opal.def(scope, 'super', ($superFunction = function (func) {
    if (typeof func === 'function') {
      Opal.send(this, Opal.find_super_dispatcher(this, func.name, func));
    } else {
      // Bind the initialize function to super();
      const argumentsList = Array.from(arguments);
      for (let i = 0; i < argumentsList.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof argumentsList[i] === 'object') {
          argumentsList[i] = toHash(argumentsList[i]);
        }
      }
      Opal.send(this, Opal.find_super_dispatcher(this, 'initialize', initialize), argumentsList);
    }
  }));
  for (const functionName in functions) {
    $superFunction[functionName] = function () {
      const argumentsList = Array.from(arguments);
      for (let i = 0; i < argumentsList.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof argumentsList[i] === 'object' && typeof argumentsList[i].constructor === 'function' && argumentsList[i].constructor.name === 'Object') {
          argumentsList[i] = toHash(argumentsList[i]);
        }
      }
      const self = scope.$$prototype;
      return Opal.send(self, Opal.find_super_dispatcher(self, functionName, self[`$${functionName}`]), argumentsList)
    };
  }
  if (defaultFunctions) {
    for (const defaultFunctionName in defaultFunctions) {
      if (Object.prototype.hasOwnProperty.call(defaultFunctions, defaultFunctionName) && !Object.prototype.hasOwnProperty.call(defaultFunctionsOverridden, defaultFunctionName)) {
        (function (defaultFunctionName) {
          const defaultFunction = defaultFunctions[defaultFunctionName];
          Opal.def(scope, '$' + defaultFunctionName, function () {
            return defaultFunction.apply(this, arguments)
          });
        }(defaultFunctionName));
      }
    }
  }
  return scope
}

// Asciidoctor API

/**
 * @namespace
 * @description
 * The main application interface (API) for Asciidoctor.
 * This API provides methods to parse AsciiDoc content and convert it to various output formats using built-in or third-party converters.
 *
 * An AsciiDoc document can be as simple as a single line of content,
 * though it more commonly starts with a document header that declares the document title and document attribute definitions.
 * The document header is then followed by zero or more section titles, optionally nested, to organize the paragraphs, blocks, lists, etc. of the document.
 *
 * By default, the processor converts the AsciiDoc document to HTML 5 using a built-in converter.
 * However, this behavior can be changed by specifying a different backend (e.g., +docbook+).
 * A backend is a keyword for an output format (e.g., DocBook).
 * That keyword, in turn, is used to select a converter, which carries out the request to convert the document to that format.
 *
 * @example
 * asciidoctor.convertFile('document.adoc', { 'safe': 'safe' }) // Convert an AsciiDoc file
 *
 * asciidoctor.convert("I'm using *Asciidoctor* version {asciidoctor-version}.", { 'safe': 'safe' }) // Convert an AsciiDoc string
 *
 * const doc = asciidoctor.loadFile('document.adoc', { 'safe': 'safe' }) // Parse an AsciiDoc file into a document object
 *
 * const doc = asciidoctor.load("= Document Title\n\nfirst paragraph\n\nsecond paragraph", { 'safe': 'safe' }) // Parse an AsciiDoc string into a document object
 */
const Asciidoctor = Opal.Asciidoctor.$$class;

/**
 * Get Asciidoctor core version number.
 *
 * @returns {string} - the version number of Asciidoctor core.
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.getCoreVersion = function () {
  return this.$$const.VERSION
};

/**
 * Get Asciidoctor.js runtime environment information.
 *
 * @returns {Object} - the runtime environment including the ioModule, the platform, the engine and the framework.
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.getRuntime = function () {
  return {
    ioModule: Opal.const_get_qualified('::', 'JAVASCRIPT_IO_MODULE'),
    platform: Opal.const_get_qualified('::', 'JAVASCRIPT_PLATFORM'),
    engine: Opal.const_get_qualified('::', 'JAVASCRIPT_ENGINE'),
    framework: Opal.const_get_qualified('::', 'JAVASCRIPT_FRAMEWORK')
  }
};

/**
 * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.
 *
 * Accepts input as a Buffer or String.
 *
 * @param {string|Buffer} input - AsciiDoc input as String or Buffer
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {string|Document} - the {@link Document} object if the converted String is written to a file,
 * otherwise the converted String
 * @example
 * const input = `= Hello, AsciiDoc!
 * Guillaume Grossetie <ggrossetie@example.com>
 *
 * An introduction to http://asciidoc.org[AsciiDoc].
 *
 * == First Section
 *
 * * item 1
 * * item 2`
 *
 * const html = asciidoctor.convert(input)
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.convert = function (input, options) {
  if (typeof input === 'object' && input.constructor.name === 'Buffer') {
    input = input.toString('utf8');
  }
  const toFile = options && options.to_file;
  if (typeof toFile === 'object' && toFile.constructor.name === 'Writable' && typeof toFile.write === 'function') {
    toFile['$respond_to?'] = (name) => name === 'write';
    toFile.$object_id = () => '';
    toFile.$write = function (data) {
      this.write(data);
    };
  }
  const opts = prepareOptions(options);
  const result = this.$convert(input, opts);
  if (typeof toFile === 'object' && toFile.constructor.name === 'Writable' && typeof toFile.end === 'function') {
    toFile.end();
  }
  return result === Opal.nil ? '' : result
};

/**
 * Parse the AsciiDoc source input into an {@link Document} and convert it to the specified backend format.
 *
 * @param {string} filename - source filename
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {string|Document} - the {@link Document} object if the converted String is written to a file,
 * otherwise the converted String
 * @example
 * const html = asciidoctor.convertFile('./document.adoc')
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.convertFile = function (filename, options) {
  return this.$convert_file(filename, prepareOptions(options))
};

/**
 * Parse the AsciiDoc source input into an {@link Document}
 *
 * Accepts input as a Buffer or String.
 *
 * @param {string|Buffer} input - AsciiDoc input as String or Buffer
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {Document} - the {@link Document} object
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.load = function (input, options) {
  if (typeof input === 'object' && input.constructor.name === 'Buffer') {
    input = input.toString('utf8');
  }
  return this.$load(input, prepareOptions(options))
};

/**
 * Parse the contents of the AsciiDoc source file into an {@link Document}
 *
 * @param {string} filename - source filename
 * @param {Object} options - a JSON of options to control processing (default: {})
 * @returns {Document} - the {@link Document} object
 * @memberof Asciidoctor
 */
Asciidoctor.prototype.loadFile = function (filename, options) {
  return this.$load_file(filename, prepareOptions(options))
};

// AbstractBlock API

/**
 * @namespace
 * @extends AbstractNode
 */
const AbstractBlock = Opal.Asciidoctor.AbstractBlock;

/**
 *  Describes the type of content this block accepts and how it should be converted.
 * @returns {string} - the type of content this block accepts.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getContentModel = function () {
  const contentModel = this.content_model;
  return contentModel === Opal.nil ? undefined : contentModel
};

/**
 *  Set the type of content this block accepts. Acceptable values are:
 *  - compound - this block contains other blocks
 *  - simple - this block holds a paragraph of prose that receives normal substitutions
 *  - verbatim - this block holds verbatim text (displayed "as is") that receives verbatim substitutions
 *  - raw - this block holds unprocessed content passed directly to the output with no substitutions applied
 *  - empty - this block has no content
 * @param {string} contentModel - type of content, one of: compound, simple, verbatim, raw or empty.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setContentModel = function (contentModel) {
  this.content_model = contentModel;
};

/**
 * Append a block to this block's list of child blocks.
 * @param {AbstractBlock} block - the block to append
 * @returns {AbstractBlock} - the parent block to which this block was appended.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.append = function (block) {
  this.$append(block);
  return this
};

/**
 * Get the String title of this Block with title substitutions applied
 *
 * The following substitutions are applied to block and section titles:
 *
 * <code>specialcharacters</code>, <code>quotes</code>, <code>replacements</code>, <code>macros</code>, <code>attributes</code> and <code>post_replacements</code>
 *
 * @returns {string} - the converted String title for this Block, or undefined if the title is not set.
 * @example
 * block.title // "Foo 3^ # {two-colons} Bar(1)"
 * block.getTitle(); // "Foo 3^ # :: Bar(1)"
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getTitle = function () {
  const title = this.$title();
  return title === Opal.nil ? undefined : title
};

/**
 * Set the String block title.
 *
 * @param {string} title - The block title
 * @returns {string} - the new String title assigned to this Block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setTitle = function (title) {
  title = typeof title === 'undefined' ? Opal.nil : title;
  return this['$title='](title)
};

/**
 * Generate and assign caption to block if not already assigned.
 *
 * If the block has a title and a caption prefix is available for this block,
 * then build a caption from this information, assign it a number and store it
 * to the caption attribute on the block.
 *
 * If a caption has already been assigned to this block, do nothing.
 *
 * The parts of a complete caption are: `<prefix> <number>. <title>`
 * This partial caption represents the part the precedes the title.
 *
 * @param {string} value - the String caption to assign to this block or nil to use document attribute.
 * @param {string} captionContext - the String context to use when resolving caption-related attributes.
 * If not provided, the name of the context for this block is used. Only certain contexts allow the caption to be looked up.
 *
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.assignCaption = function (value, captionContext) {
  value = typeof value === 'undefined' ? Opal.nil : value;
  captionContext = typeof captionContext === 'undefined' ? null : captionContext;
  this.$assign_caption(value, captionContext);
};

/**
 * Convenience method that returns the interpreted title of the Block
 * with the caption prepended.
 * Concatenates the value of this Block's caption instance variable and the
 * return value of this Block's title method. No space is added between the
 * two values. If the Block does not have a caption, the interpreted title is
 * returned.
 *
 * @returns {string} - the converted String title prefixed with the caption, or just the converted String title if no caption is set
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getCaptionedTitle = function () {
  return this.$captioned_title()
};

/**
 * Get the style (block type qualifier) for this block.
 *
 * @returns {string} - the style for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getStyle = function () {
  const style = this.style;
  return style === Opal.nil ? undefined : style
};

/**
 * Set the style for this block.
 *
 * @param {string} style - Style
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setStyle = function (style) {
  this.style = style;
};

/**
 * Get the location in the AsciiDoc source where this block begins.
 *
 * @returns {Cursor} - the location in the AsciiDoc source where this block begins
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getSourceLocation = function () {
  const sourceLocation = this.source_location;
  if (sourceLocation === Opal.nil) {
    return undefined
  }
  sourceLocation.getFile = function () {
    const file = this.file;
    return file === Opal.nil ? undefined : file
  };
  sourceLocation.getDirectory = function () {
    const dir = this.dir;
    return dir === Opal.nil ? undefined : dir
  };
  sourceLocation.getPath = function () {
    const path = this.path;
    return path === Opal.nil ? undefined : path
  };
  sourceLocation.getLineNumber = function () {
    const lineno = this.lineno;
    return lineno === Opal.nil ? undefined : lineno
  };
  return sourceLocation
};

/**
 * Get the caption for this block.
 *
 * @returns {string} - the caption for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getCaption = function () {
  const caption = this.$caption();
  return caption === Opal.nil ? undefined : caption
};

/**
 * Set the caption for this block.
 *
 * @param {string} caption - Caption
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setCaption = function (caption) {
  this.caption = typeof caption === 'undefined' ? Opal.nil : caption;
};

/**
 * Get the level of this section or the section level in which this block resides.
 *
 * @returns {number} - the level (Integer) of this section
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getLevel = function () {
  const level = this.level;
  return level === Opal.nil ? undefined : level
};

/**
 * Get the substitution keywords to be applied to the contents of this block.
 *
 * @returns {Array<string>} - the list of {string} substitution keywords associated with this block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getSubstitutions = function () {
  return this.subs
};

/**
 * Check whether a given substitution keyword is present in the substitutions for this block.
 *
 * @returns {boolean} - whether the substitution is present on this block.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasSubstitution = function (substitution) {
  return this['$sub?'](substitution)
};

/**
 * Remove the specified substitution keyword from the list of substitutions for this block.
 *
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.removeSubstitution = function (substitution) {
  this.$remove_sub(substitution);
};

/**
 * Checks if the {@link AbstractBlock} contains any child blocks.
 *
 * @returns {boolean} - whether the {@link AbstractBlock} has child blocks.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasBlocks = function () {
  return this.blocks.length > 0
};

/**
 * Get the list of {@link AbstractBlock} sub-blocks for this block.
 *
 * @returns {Array<AbstractBlock>} - a list of {@link AbstractBlock} sub-blocks
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getBlocks = function () {
  return this.blocks
};

/**
 * Get the converted result of the child blocks by converting the children appropriate to content model that this block supports.
 *
 * @returns {string} - the converted result of the child blocks
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getContent = function () {
  const content = this.$content();
  return content === Opal.nil ? undefined : content
};

/**
 * Get the converted content for this block.
 * If the block has child blocks, the content method should cause them to be converted
 * and returned as content that can be included in the parent block's template.
 *
 * @returns {string} - the converted String content for this block
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.convert = function () {
  return this.$convert()
};

/**
 * Query for all descendant block-level nodes in the document tree
 * that match the specified selector (context, style, id, and/or role).
 * If a function block is given, it's used as an additional filter.
 * If no selector or function block is supplied, all block-level nodes in the tree are returned.
 * @param {Object} [selector]
 * @param {function} [block]
 * @example
 * doc.findBy({'context': 'section'});
 * // => { level: 0, title: "Hello, AsciiDoc!", blocks: 0 }
 * // => { level: 1, title: "First Section", blocks: 1 }
 *
 * doc.findBy({'context': 'section'}, function (section) { return section.getLevel() === 1; });
 * // => { level: 1, title: "First Section", blocks: 1 }
 *
 * doc.findBy({'context': 'listing', 'style': 'source'});
 * // => { context: :listing, content_model: :verbatim, style: "source", lines: 1 }
 *
 * @returns {Array<AbstractBlock>} - a list of block-level nodes that match the filter or an empty list if no matches are found
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.findBy = function (selector, block) {
  if (typeof block === 'undefined' && typeof selector === 'function') {
    return Opal.send(this, 'find_by', null, selector)
  } else if (typeof block === 'function') {
    return Opal.send(this, 'find_by', [toHash(selector)], block)
  } else {
    return this.$find_by(toHash(selector))
  }
};

/**
 * Get the source line number where this block started.
 * @returns {number} - the source line number where this block started
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getLineNumber = function () {
  const lineno = this.$lineno();
  return lineno === Opal.nil ? undefined : lineno
};

/**
 * Check whether this block has any child Section objects.
 * Only applies to Document and Section instances.
 * @returns {boolean} - true if this block has child Section objects, otherwise false
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasSections = function () {
  // REMIND: call directly the underlying method "$sections?"
  // once https://github.com/asciidoctor/asciidoctor/pull/3591 is merged and a new version is released.
  // return this['$sections?']()
  return this.next_section_index !== Opal.nil && this.next_section_index > 0
};

/**
 * Get the Array of child Section objects.
 * Only applies to Document and Section instances.
 * @memberof AbstractBlock
 * @returns {Array<Section>} - an {Array} of {@link Section} objects
 */
AbstractBlock.prototype.getSections = function () {
  return this.$sections()
};

/**
 * Get the numeral of this block (if section, relative to parent, otherwise absolute).
 * Only assigned to section if automatic section numbering is enabled.
 * Only assigned to formal block (block with title) if corresponding caption attribute is present.
 * If the section is an appendix, the numeral is a letter (starting with A).
 * @returns {string} - the numeral
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getNumeral = function () {
  const numeral = this.$numeral();
  return numeral === Opal.nil ? undefined : numeral
};

/**
 * Set the numeral of this block.
 * @param {string} value - The numeral value
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.setNumeral = function (value) {
  this['$numeral='](value);
};

/**
 * A convenience method that checks whether the title of this block is defined.
 *
 * @returns {boolean} - a {boolean} indicating whether this block has a title.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.hasTitle = function () {
  return this['$title?']()
};

/**
 * Returns the converted alt text for this block image.
 * @returns {string} - the {string} value of the alt attribute with XML special character and replacement substitutions applied.
 * @memberof AbstractBlock
 */
AbstractBlock.prototype.getAlt = function () {
  return this.$alt()
};

// Section API

/**
 * @description
 * Methods for managing sections of AsciiDoc content in a document.
 *
 * @example
 * <pre>
 *   section = asciidoctor.Section.create()
 *   section.setTitle('Section 1')
 *   section.setId('sect1')
 *   section.getBlocks().length // 0
 *   section.getId() // "sect1"
 *   section.append(newBlock)
 *   section.getBlocks().length // 1
 * </pre>
 * @namespace
 * @extends AbstractBlock
 */
const Section = Opal.Asciidoctor.Section;

/**
 * Create a {Section} object.
 * @param {AbstractBlock} [parent] - The parent AbstractBlock. If set, must be a Document or Section object (default: undefined)
 * @param {number} [level] - The Integer level of this section (default: 1 more than parent level or 1 if parent not defined)
 * @param {boolean} [numbered] - A Boolean indicating whether numbering is enabled for this Section (default: false)
 * @param {Object} [opts] - An optional JSON of options (default: {})
 * @returns {Section} - a new {Section} object
 * @memberof Section
 */
Section.create = function (parent, level, numbered, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return this.$new(parent, level, numbered, toHash(opts))
};

/**
 * Set the level of this section or the section level in which this block resides.
 * @param {number} level - Level (Integer)
 * @memberof AbstractBlock
 */
Section.prototype.setLevel = function (level) {
  this.level = level;
};

/**
 * Get the 0-based index order of this section within the parent block.
 * @returns {number}
 * @memberof Section
 */
Section.prototype.getIndex = function () {
  return this.index
};

/**
 * Set the 0-based index order of this section within the parent block.
 * @param {string} index - The index order of this section
 * @memberof Section
 */
Section.prototype.setIndex = function (index) {
  this.index = index;
};

/**
 * Get the section name of this section.
 * @returns {string|undefined}
 * @memberof Section
 */
Section.prototype.getSectionName = function () {
  const sectname = this.sectname;
  return sectname === Opal.nil ? undefined : sectname
};

/**
 * Set the section name of this section.
 * @param {string} value - The section name
 * @memberof Section
 */
Section.prototype.setSectionName = function (value) {
  this.sectname = value;
};

/**
 * Get the section numeral of this section.
 * @returns {string}
 * @memberof Section
 */
Section.prototype.getSectionNumeral = function () {
  return this.$sectnum()
};

Section.prototype.getSectionNumber = Section.prototype.getSectionNumeral;

/**
 * Get the flag to indicate whether this is a special section or a child of one.
 * @returns {boolean}
 * @memberof Section
 */
Section.prototype.isSpecial = function () {
  return this.special
};

/**
 * Set the flag to indicate whether this is a special section or a child of one.
 * @param {boolean} value - A flag to indicated if this is a special section
 * @memberof Section
 */
Section.prototype.setSpecial = function (value) {
  this.special = value;
};

/**
 * Get the state of the numbered attribute at this section (need to preserve for creating TOC).
 * @returns {boolean}
 * @memberof Section
 */
Section.prototype.isNumbered = function () {
  return this.numbered
};

/**
 * Get the caption for this section (only relevant for appendices).
 * @returns {string}
 * @memberof Section
 */
Section.prototype.getCaption = function () {
  const value = this.caption;
  return value === Opal.nil ? undefined : value
};

/**
 * Get the name of the Section (title)
 * @returns {string}
 * @see {@link AbstractBlock#getTitle}
 * @memberof Section
 */
Section.prototype.getName = function () {
  return this.getTitle()
};

/**
 * @description
 * Methods for managing AsciiDoc content blocks.
 *
 * @example
 * block = asciidoctor.Block.create(parent, 'paragraph', {source: '_This_ is a <test>'})
 * block.getContent()
 * // "<em>This</em> is a &lt;test&gt;"
 *
 * @namespace
 * @extends AbstractBlock
 */
const Block = Opal.Asciidoctor.Block;

/**
 * Create a {Block} object.
 * @param {AbstractBlock} parent - The parent {AbstractBlock} with a compound content model to which this {Block} will be appended.
 * @param {string} context - The context name for the type of content (e.g., "paragraph").
 * @param {Object} [opts] - a JSON of options to customize block initialization: (default: {})
 * @param {string} opts.content_model - indicates whether blocks can be nested in this {Block} ("compound"),
 * otherwise how the lines should be processed ("simple", "verbatim", "raw", "empty"). (default: "simple")
 * @param {Object} opts.attributes - a JSON of attributes (key/value pairs) to assign to this {Block}. (default: {})
 * @param {string|Array<string>} opts.source - a String or {Array} of raw source for this {Block}. (default: undefined)
 *
 * IMPORTANT: If you don't specify the `subs` option, you must explicitly call the `commit_subs` method to resolve and assign the substitutions
 * to this block (which are resolved from the `subs` attribute, if specified, or the default substitutions based on this block's context).
 * If you want to use the default subs for a block, pass the option `subs: "default"`.
 * You can override the default subs using the `default_subs` option.
 *
 * @returns {Block} - a new {Block} object
 * @memberof Block
 */
Block.create = function (parent, context, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return this.$new(parent, context, toHash(opts))
};

/**
 * Get the source of this block.
 * @returns {string} - the String source of this block.
 * @memberof Block
 */
Block.prototype.getSource = function () {
  return this.$source()
};

/**
 * Get the source lines of this block.
 * @returns {Array<string>} - the String {Array} of source lines for this block.
 * @memberof Block
 */
Block.prototype.getSourceLines = function () {
  return this.lines
};

// AbstractNode API

/**
 * @namespace
 * @description
 * An abstract base class that provides state and methods for managing a node of AsciiDoc content.
 * The state and methods on this class are common to all content segments in an AsciiDoc document.
 */
const AbstractNode = Opal.Asciidoctor.AbstractNode;

/**
 * Apply the specified substitutions to the text.
 * If no substitutions are specified, the following substitutions are applied:
 * <code>specialcharacters</code>, <code>quotes</code>, <code>attributes</code>, <code>replacements</code>, <code>macros</code>, and <code>post_replacements</code>.
 *
 * @param {string|Array<string>} text - The String or String Array of text to process; must not be undefined.
 * @param {Array<string>} [subs] - The substitutions to perform; must be an Array or undefined.
 * @returns {string|Array<string>} - a String or String Array to match the type of the text argument with substitutions applied.
 * @memberof AbstractNode
 */
AbstractNode.prototype.applySubstitutions = function (text, subs) {
  return this.$apply_subs(text, subs)
};

/**
 * Resolve the list of comma-delimited subs against the possible options.
 *
 * @param {string} subs - The comma-delimited String of substitution names or aliases.
 * @param {string} [type] - A String representing the context for which the subs are being resolved (default: 'block').
 * @param {Array<string>} [defaults] - An Array of substitutions to start with when computing incremental substitutions (default: undefined).
 * @param {string} [subject] - The String to use in log messages to communicate the subject for which subs are being resolved (default: undefined)
 *
 * @returns {Array<string>} - An Array of Strings representing the substitution operation or nothing if no subs are found.
 * @memberof AbstractNode
 */
AbstractNode.prototype.resolveSubstitutions = function (subs, type, defaults, subject) {
  if (typeof type === 'undefined') {
    type = 'block';
  }
  if (typeof defaults === 'undefined') {
    defaults = Opal.nil;
  }
  if (typeof subject === 'undefined') {
    subject = Opal.nil;
  }
  const value = this.$resolve_subs(subs, type, defaults, subject);
  return value === Opal.nil ? undefined : value
};

/**
 * Call {@link AbstractNode#resolveSubstitutions} for the 'block' type.
 *
 * @see {@link AbstractNode#resolveSubstitutions}
 */
AbstractNode.prototype.resolveBlockSubstitutions = function (subs, defaults, subject) {
  return this.resolveSubstitutions(subs, 'block', defaults, subject)
};

/**
 * Call {@link AbstractNode#resolveSubstitutions} for the 'inline' type with the subject set as passthrough macro.
 *
 * @see {@link AbstractNode#resolveSubstitutions}
 */
AbstractNode.prototype.resolvePassSubstitutions = function (subs) {
  return this.resolveSubstitutions(subs, 'inline', undefined, 'passthrough macro')
};

/**
 * @returns {string} - the String name of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getNodeName = function () {
  return this.node_name
};

/**
 * @returns {Object} - the JSON of attributes for this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getAttributes = function () {
  return fromHash(this.attributes)
};

/**
 * Get the value of the specified attribute.
 * If the attribute is not found on this node, fallback_name is set, and this node is not the Document node, get the value of the specified attribute from the Document node.
 *
 * Look for the specified attribute in the attributes on this node and return the value of the attribute, if found.
 * Otherwise, if fallback_name is set (default: same as name) and this node is not the Document node, look for that attribute on the Document node and return its value, if found.
 * Otherwise, return the default value (default: undefined).
 *
 * @param {string} name - The String of the attribute to resolve.
 * @param {*} [defaultValue] - The {Object} value to return if the attribute is not found (default: undefined).
 * @param {string} [fallbackName] - The String of the attribute to resolve on the Document if the attribute is not found on this node (default: same as name).
 *
 * @returns {*} - the {Object} value (typically a String) of the attribute or defaultValue if the attribute is not found.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getAttribute = function (name, defaultValue, fallbackName) {
  const value = this.$attr(name, defaultValue, fallbackName);
  return value === Opal.nil ? undefined : value
};

/**
 * Check whether the specified attribute is present on this node.
 *
 * @param {string} name - The String of the attribute to resolve.
 * @returns {boolean} - true if the attribute is present, otherwise false
 * @memberof AbstractNode
 */
AbstractNode.prototype.hasAttribute = function (name) {
  return name in this.attributes.$$smap
};

/**
 * Check if the specified attribute is defined using the same logic as {AbstractNode#getAttribute}, optionally performing acomparison with the expected value if specified.
 *
 * Look for the specified attribute in the attributes on this node.
 * If not found, fallback_name is specified (default: same as name), and this node is not the Document node, look for that attribute on the Document node.
 * In either case, if the attribute is found, and the comparison value is truthy, return whether the two values match.
 * Otherwise, return whether the attribute was found.
 *
 * @param {string} name - The String name of the attribute to resolve.
 * @param {*} [expectedValue] - The expected Object value of the attribute (default: undefined).
 * @param {string} fallbackName - The String of the attribute to resolve on the Document if the attribute is not found on this node (default: same as name).
 *
 * @returns {boolean} - a Boolean indicating whether the attribute exists and, if a truthy comparison value is specified, whether the value of the attribute matches the comparison value.
 * @memberof AbstractNode
 */
AbstractNode.prototype.isAttribute = function (name, expectedValue, fallbackName) {
  return this['$attr?'](name, expectedValue, fallbackName)
};

/**
 * Assign the value to the attribute name for the current node.
 *
 * @param {string} name - The String attribute name to assign
 * @param {*} value - The Object value to assign to the attribute (default: '')
 * @param {boolean} overwrite - A Boolean indicating whether to assign the attribute if currently present in the attributes JSON (default: true)
 *
 * @returns {boolean} - a Boolean indicating whether the assignment was performed
 * @memberof AbstractNode
 */
AbstractNode.prototype.setAttribute = function (name, value, overwrite) {
  if (typeof overwrite === 'undefined') overwrite = true;
  return this.$set_attr(name, value, overwrite)
};

/**
 * Remove the attribute from the current node.
 * @param {string} name - The String attribute name to remove
 * @returns {string} - the previous {string} value, or undefined if the attribute was not present.
 * @memberof AbstractNode
 */
AbstractNode.prototype.removeAttribute = function (name) {
  const value = this.$remove_attr(name);
  return value === Opal.nil ? undefined : value
};

/**
 * Get the {@link Document} to which this node belongs.
 *
 * @returns {Document} - the {@link Document} object to which this node belongs.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getDocument = function () {
  return this.document
};

/**
 * Get the {@link AbstractNode} to which this node is attached.
 *
 * @memberof AbstractNode
 * @returns {AbstractNode} - the {@link AbstractNode} object to which this node is attached,
 * or undefined if this node has no parent.
 */
AbstractNode.prototype.getParent = function () {
  const parent = this.parent;
  return parent === Opal.nil ? undefined : parent
};

/**
 * @returns {boolean} - true if this {AbstractNode} is an instance of {Inline}
 * @memberof AbstractNode
 */
AbstractNode.prototype.isInline = function () {
  return this['$inline?']()
};

/**
 * @returns {boolean} - true if this {AbstractNode} is an instance of {Block}
 * @memberof AbstractNode
 */
AbstractNode.prototype.isBlock = function () {
  return this['$block?']()
};

/**
 * Checks if the role attribute is set on this node and, if an expected value is given, whether the space-separated role matches that value.
 *
 * @param {string} expectedValue - The expected String value of the role (optional, default: undefined)
 *
 * @returns {boolean} - a Boolean indicating whether the role attribute is set on this node and, if an expected value is given, whether the space-separated role matches that value.
 * @memberof AbstractNode
 */
AbstractNode.prototype.isRole = function (expectedValue) {
  return this['$role?'](expectedValue)
};

/**
 * Retrieves the space-separated String role for this node.
 *
 * @returns {string} - the role as a space-separated String.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getRole = function () {
  const role = this.$role();
  return role === Opal.nil ? undefined : role
};

/**
 * Sets the value of the role attribute on this node.
 *
 * @param {...string|Array<string>} names - A single role name, a space-separated String of role names, an Array of role names or a list of role names
 *
 * @returns {string} - the value of the role attribute
 * @memberof AbstractNode
 */
AbstractNode.prototype.setRole = function (names) {
  if (Array.isArray(names) || (typeof names === 'string' && arguments.length === 1)) {
    return this['$role='](names)
  }
  return this['$role='](Array.from(arguments))
};

/**
 * Checks if the specified role is present in the list of roles for this node.
 *
 * @param {string} name - The String name of the role to find.
 *
 * @returns {boolean} - a Boolean indicating whether this node has the specified role.
 * @memberof AbstractNode
 */
AbstractNode.prototype.hasRole = function (name) {
  return this['$has_role?'](name)
};

/**
 * Retrieves the String role names for this node as an Array.
 *
 * @returns {Array<string>} - the role names as a String {Array}, which is empty if the role attribute is absent on this node.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getRoles = function () {
  return this.$roles()
};

/**
 * Adds the given role directly to this node.
 *
 * @param {string} name - The name of the role to add
 *
 * @returns {boolean} - a Boolean indicating whether the role was added.
 * @memberof AbstractNode
 */
AbstractNode.prototype.addRole = function (name) {
  return this.$add_role(name)
};

/**
 * Public: Removes the given role directly from this node.
 *
 * @param {string} name - The name of the role to remove
 *
 * @returns {boolean} - a Boolean indicating whether the role was removed.
 * @memberof AbstractNode
 */
AbstractNode.prototype.removeRole = function (name) {
  return this.$remove_role(name)
};

/**
 * A convenience method that checks if the reftext attribute is defined.
 * @returns {boolean} - A Boolean indicating whether the reftext attribute is defined
 * @memberof AbstractNode
 */
AbstractNode.prototype.isReftext = function () {
  return this['$reftext?']()
};

/**
 * A convenience method that returns the value of the reftext attribute with substitutions applied.
 * @returns {string|undefined} - the value of the reftext attribute with substitutions applied.
 * @memberof AbstractNode
 */
AbstractNode.prototype.getReftext = function () {
  const reftext = this.$reftext();
  return reftext === Opal.nil ? undefined : reftext
};

/**
 * @returns {string} - Get the context name for this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getContext = function () {
  const context = this.context;
  // Automatically convert Opal pseudo-symbol to String
  return typeof context === 'string' ? context : context.toString()
};

/**
 * @returns {string} - the String id of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.getId = function () {
  const id = this.id;
  return id === Opal.nil ? undefined : id
};

/**
 * @param {string} id - the String id of this node
 * @memberof AbstractNode
 */
AbstractNode.prototype.setId = function (id) {
  this.id = id;
};

/**
 * A convenience method to check if the specified option attribute is enabled on the current node.
 * Check if the option is enabled. This method simply checks to see if the <name>-option attribute is defined on the current node.
 *
 * @param {string} name - the String name of the option
 *
 * @return {boolean} - a Boolean indicating whether the option has been specified
 * @memberof AbstractNode
 */
AbstractNode.prototype.isOption = function (name) {
  return this['$option?'](name)
};

/**
 * Set the specified option on this node.
 * This method sets the specified option on this node by setting the <name>-option attribute.
 *
 * @param {string} name - the String name of the option
 *
 * @memberof AbstractNode
 */
AbstractNode.prototype.setOption = function (name) {
  return this.$set_option(name)
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getIconUri = function (name) {
  return this.$icon_uri(name)
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getMediaUri = function (target, assetDirKey) {
  return this.$media_uri(target, assetDirKey)
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getImageUri = function (targetImage, assetDirKey) {
  return this.$image_uri(targetImage, assetDirKey)
};

/**
 * Get the {Converter} instance being used to convert the current {Document}.
 * @returns {Object}
 * @memberof AbstractNode
 */
AbstractNode.prototype.getConverter = function () {
  return this.$converter()
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.readContents = function (target, options) {
  return this.$read_contents(target, toHash(options))
};

/**
 * Read the contents of the file at the specified path.
 * This method assumes that the path is safe to read.
 * It checks that the file is readable before attempting to read it.
 *
 * @param path - the {string} path from which to read the contents
 * @param {Object} options - a JSON {Object} of options to control processing (default: {})
 * @param {boolean} options.warn_on_failure - a {boolean} that controls whether a warning is issued if the file cannot be read (default: false)
 * @param {boolean} options.normalize - a {boolean} that controls whether the lines are normalized and coerced to UTF-8 (default: false)
 *
 * @returns {string} - the String content of the file at the specified path, or undefined if the file does not exist.
 * @memberof AbstractNode
 */
AbstractNode.prototype.readAsset = function (path, options) {
  const result = this.$read_asset(path, toHash(options));
  return result === Opal.nil ? undefined : result
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeWebPath = function (target, start, preserveTargetUri) {
  return this.$normalize_web_path(target, start, preserveTargetUri)
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeSystemPath = function (target, start, jail, options) {
  return this.$normalize_system_path(target, start, jail, toHash(options))
};

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.normalizeAssetPath = function (assetRef, assetName, autoCorrect) {
  return this.$normalize_asset_path(assetRef, assetName, autoCorrect)
};

// Document API

/**
 * The {@link Document} class represents a parsed AsciiDoc document.
 *
 * Document is the root node of a parsed AsciiDoc document.<br/>
 * It provides an abstract syntax tree (AST) that represents the structure of the AsciiDoc document
 * from which the Document object was parsed.
 *
 * Although the constructor can be used to create an empty document object,
 * more commonly, you'll load the document object from AsciiDoc source
 * using the primary API methods on {@link Asciidoctor}.
 * When using one of these APIs, you almost always want to set the safe mode to 'safe' (or 'unsafe')
 * to enable all of Asciidoctor's features.
 *
 * <pre>
 *   const doc = Asciidoctor.load('= Hello, AsciiDoc!', { 'safe': 'safe' })
 *   // => Asciidoctor::Document { doctype: "article", doctitle: "Hello, AsciiDoc!", blocks: 0 }
 * </pre>
 *
 * Instances of this class can be used to extract information from the document or alter its structure.
 * As such, the Document object is most often used in extensions and by integrations.
 *
 * The most basic usage of the Document object is to retrieve the document's title.
 *
 * <pre>
 *  const source = '= Document Title'
 *  const doc = asciidoctor.load(source, { 'safe': 'safe' })
 *  console.log(doc.getTitle()) // 'Document Title'
 * </pre>
 *
 * You can also use the Document object to access document attributes defined in the header, such as the author and doctype.
 * @namespace
 * @extends AbstractBlock
 */
const Document = Opal.Asciidoctor.Document;

/**
 * Append a content Block to this Document.
 * If the child block is a Section, assign an index to it.
 * @param {AbstractBlock} block - the child Block to append to this parent Block
 * @returns {AbstractBlock} - the parent block to which this block was appended.
 * @memberof Document
 */
Document.prototype.append = function (block) {
  this['$<<'](block);
  return this
};

/**
 * Returns the SyntaxHighlighter associated with this document.
 *
 * @returns {SyntaxHighlighter} - the SyntaxHighlighter associated with this document.
 * @memberof Document
 */
Document.prototype.getSyntaxHighlighter = function () {
  const syntaxHighlighter = this.syntax_highlighter;
  // eslint-disable-next-line no-proto
  const prototype = syntaxHighlighter.__proto__;
  if (prototype) {
    if (typeof prototype['$highlight?'] === 'function') {
      prototype.handlesHighlighting = function () {
        const value = prototype['$highlight?']();
        return value === Opal.nil ? false : value
      };
    }
    if (typeof prototype['$docinfo?'] === 'function') {
      prototype.hasDocinfo = prototype['$docinfo?'];
    }
    if (typeof prototype.$format === 'function') {
      prototype.format = function (node, lang, opts) {
        return this.$format(node, lang, toHash(opts))
      };
    }
    if (typeof prototype.$docinfo === 'function') {
      prototype.docinfo = function (location, doc, opts) {
        return this.$docinfo(location, doc, toHash(opts))
      };
    }
  }
  return syntaxHighlighter
};

/**
 * Returns a JSON {Object} of references captured by the processor.
 *
 * @returns {Object} - a JSON {Object} of {AbstractNode} in the document.
 * @memberof Document
 */
Document.prototype.getRefs = function () {
  return fromHash(this.catalog.$$smap.refs)
};

/**
 * Returns an {Array} of {Document/ImageReference} captured by the processor.
 *
 * @returns {Array<ImageReference>} - an {Array} of {Document/ImageReference} in the document.
 * Will return an empty array if the option "catalog_assets: true" was not defined on the processor.
 * @memberof Document
 */
Document.prototype.getImages = function () {
  return this.catalog.$$smap.images
};

/**
 * Returns an {Array} of links captured by the processor.
 *
 * @returns {Array<string>} - an {Array} of links in the document.
 * Will return an empty array if:
 * - the function was called before the document was converted
 * - the option "catalog_assets: true" was not defined on the processor
 * @memberof Document
 */
Document.prototype.getLinks = function () {
  return this.catalog.$$smap.links
};

/**
 * @returns {boolean} - true if the document has footnotes otherwise false
 * @memberof Document
 */
Document.prototype.hasFootnotes = function () {
  return this['$footnotes?']()
};

/**
 * Returns an {Array} of {Document/Footnote} captured by the processor.
 *
 * @returns {Array<Footnote>} - an {Array} of {Document/Footnote} in the document.
 * Will return an empty array if the function was called before the document was converted.
 * @memberof Document
 */
Document.prototype.getFootnotes = function () {
  return this.$footnotes()
};

/**
 * Returns the level-0 {Section} (i.e. the document title).
 * Only stores the title, not the header attributes.
 *
 * @returns {string} - the level-0 {Section}.
 * @memberof Document
 */
Document.prototype.getHeader = function () {
  return this.header
};

/**
 * @memberof Document
 */
Document.prototype.setAttribute = function (name, value) {
  return this.$set_attribute(name, value)
};

/**

 * @memberof Document
 */
Document.prototype.removeAttribute = function (name) {
  this.attributes.$delete(name);
  this.attribute_overrides.$delete(name);
};

/**
 * Convert the AsciiDoc document using the templates loaded by the Converter.
 * If a "template_dir" is not specified, or a template is missing, the converter will fall back to using the appropriate built-in template.
 *
 * @param {Object} [options] - a JSON of options to control processing (default: {})
 *
 * @returns {string}
 * @memberof Document
 */
Document.prototype.convert = function (options) {
  const result = this.$convert(toHash(options));
  return result === Opal.nil ? '' : result
};

/**
 * Write the output to the specified file.
 *
 * If the converter responds to "write", delegate the work of writing the file to that method.
 * Otherwise, write the output the specified file.
 *
 * @param {string} output
 * @param {string} target
 *
 * @memberof Document
 */
Document.prototype.write = function (output, target) {
  return this.$write(output, target)
};

/**
 * @returns {string} - the full name of the author as a String
 * @memberof Document
 */
Document.prototype.getAuthor = function () {
  return this.$author()
};

/**
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getSource = function () {
  return this.$source()
};

/**
 * @returns {Array<string>}
 * @memberof Document
 */
Document.prototype.getSourceLines = function () {
  return this.$source_lines()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isNested = function () {
  return this['$nested?']()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isEmbedded = function () {
  return this['$embedded?']()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasExtensions = function () {
  return this['$extensions?']()
};

/**
 * Get the value of the doctype attribute for this document.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getDoctype = function () {
  return this.doctype
};

/**
 * Get the value of the backend attribute for this document.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getBackend = function () {
  return this.backend
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.isBasebackend = function (base) {
  return this['$basebackend?'](base)
};

/**
 * Get the title explicitly defined in the document attributes.
 * @returns {string}
 * @see {@link AbstractNode#getAttributes}
 * @memberof Document
 */
Document.prototype.getTitle = function () {
  const title = this.$title();
  return title === Opal.nil ? undefined : title
};

/**
 * Set the title on the document header
 *
 * Set the title of the document header to the specified value.
 * If the header does not exist, it is first created.
 *
 * @param {string} title - the String title to assign as the title of the document header
 *
 * @returns {string} - the new String title assigned to the document header
 * @memberof Document
 */
Document.prototype.setTitle = function (title) {
  return this['$title='](title)
};

/**
 * @returns {Document/Title} - a {@link Document/Title}
 * @memberof Document
 */
Document.prototype.getDocumentTitle = function (options) {
  const doctitle = this.$doctitle(toHash(options));
  return doctitle === Opal.nil ? undefined : doctitle
};

/**
 * @see {@link Document#getDocumentTitle}
 * @memberof Document
 */
Document.prototype.getDoctitle = Document.prototype.getDocumentTitle;

/**
 * Get the document catalog JSON object.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCatalog = function () {
  return fromHash(this.catalog)
};

/**
 *
 * @returns {Object}
 * @see Document#getCatalog
 * @memberof Document
 */
Document.prototype.getReferences = Document.prototype.getCatalog;

/**
 * Get the document revision date from document header (document attribute <code>revdate</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionDate = function () {
  return this.getAttribute('revdate')
};

/**
 * @see Document#getRevisionDate
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevdate = function () {
  return this.getRevisionDate()
};

/**
 * Get the document revision number from document header (document attribute <code>revnumber</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionNumber = function () {
  return this.getAttribute('revnumber')
};

/**
 * Get the document revision remark from document header (document attribute <code>revremark</code>).
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getRevisionRemark = function () {
  return this.getAttribute('revremark')
};

/**
 *  Assign a value to the specified attribute in the document header.
 *
 *  The assignment will be visible when the header attributes are restored,
 *  typically between processor phases (e.g., between parse and convert).
 *
 * @param {string} name - The {string} attribute name to assign
 * @param {Object} value - The {Object} value to assign to the attribute (default: '')
 * @param {boolean} overwrite - A {boolean} indicating whether to assign the attribute
 * if already present in the attributes Hash (default: true)
 *
 * @returns {boolean} - true if the assignment was performed otherwise false
 * @memberof Document
 */
Document.prototype.setHeaderAttribute = function (name, value, overwrite) {
  if (typeof overwrite === 'undefined') overwrite = true;
  if (typeof value === 'undefined') value = '';
  return this.$set_header_attribute(name, value, overwrite)
};

/**
 * Convenience method to retrieve the authors of this document as an {Array} of {Document/Author} objects.
 *
 * This method is backed by the author-related attributes on the document.
 *
 * @returns {Array<Author>} - an {Array} of {Document/Author} objects.
 * @memberof Document
 */
Document.prototype.getAuthors = function () {
  return this.$authors()
};

// Document.Footnote API

/**
 * @namespace
 * @module Document/Footnote
 */
const Footnote = Document.Footnote;

/**
 * @returns {number} - the footnote's index
 * @memberof Document/Footnote
 */
Footnote.prototype.getIndex = function () {
  const index = this.$$data.index;
  return index === Opal.nil ? undefined : index
};

/**
 * @returns {number} - the footnote's id
 * @memberof Document/Footnote
 */
Footnote.prototype.getId = function () {
  const id = this.$$data.id;
  return id === Opal.nil ? undefined : id
};

/**
 * @returns {string} - the footnote's text
 * @memberof Document/Footnote
 */
Footnote.prototype.getText = function () {
  const text = this.$$data.text;
  return text === Opal.nil ? undefined : text
};

// Document.ImageReference API

/**
 * @class
 * @module Document/ImageReference
 */
const ImageReference = Document.ImageReference;

/**
 * @returns {string} - the image's target
 * @memberof Document/ImageReference
 */
ImageReference.prototype.getTarget = function () {
  return this.$$data.target
};

/**
 * @returns {string} - the image's directory (imagesdir attribute)
 * @memberof Document/ImageReference
 */
ImageReference.prototype.getImagesDirectory = function () {
  const value = this.$$data.imagesdir;
  return value === Opal.nil ? undefined : value
};

// Document.Author API

/**
 * The Author class represents information about an author extracted from document attributes.
 * @namespace
 * @module Document/Author
 */
const Author = Document.Author;

/**
 * @returns {string} - the author's full name
 * @memberof Document/Author
 */
Author.prototype.getName = function () {
  const name = this.$$data.name;
  return name === Opal.nil ? undefined : name
};

/**
 * @returns {string} - the author's first name
 * @memberof Document/Author
 */
Author.prototype.getFirstName = function () {
  const firstName = this.$$data.firstname;
  return firstName === Opal.nil ? undefined : firstName
};

/**
 * @returns {string} - the author's middle name (or undefined if the author has no middle name)
 * @memberof Document/Author
 */
Author.prototype.getMiddleName = function () {
  const middleName = this.$$data.middlename;
  return middleName === Opal.nil ? undefined : middleName
};

/**
 * @returns {string} - the author's last name
 * @memberof Document/Author
 */
Author.prototype.getLastName = function () {
  const lastName = this.$$data.lastname;
  return lastName === Opal.nil ? undefined : lastName
};

/**
 * @returns {string} - the author's initials (by default based on the author's name)
 * @memberof Document/Author
 */
Author.prototype.getInitials = function () {
  const initials = this.$$data.initials;
  return initials === Opal.nil ? undefined : initials
};

/**
 * @returns {string} - the author's email
 * @memberof Document/Author
 */
Author.prototype.getEmail = function () {
  const email = this.$$data.email;
  return email === Opal.nil ? undefined : email
};

// private constructor
Document.RevisionInfo = function (date, number, remark) {
  this.date = date;
  this.number = number;
  this.remark = remark;
};

/**
 * @class
 * @namespace
 * @module Document/RevisionInfo
 */
const RevisionInfo = Document.RevisionInfo;

/**
 * Get the document revision date from document header (document attribute <code>revdate</code>).
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getDate = function () {
  return this.date
};

/**
 * Get the document revision number from document header (document attribute <code>revnumber</code>).
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getNumber = function () {
  return this.number
};

/**
 * Get the document revision remark from document header (document attribute <code>revremark</code>).
 * A short summary of changes in this document revision.
 * @returns {string}
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.getRemark = function () {
  return this.remark
};

/**
 * @returns {boolean} - true if the revision info is empty (ie. not defined), otherwise false
 * @memberof Document/RevisionInfo
 */
RevisionInfo.prototype.isEmpty = function () {
  return this.date === undefined && this.number === undefined && this.remark === undefined
};

// SafeMode API

/**
 * @namespace
 */
const SafeMode = Opal.Asciidoctor.SafeMode;

/**
 * @param {string} name - the name of the security level
 * @returns {number} - the integer value of the corresponding security level
 */
SafeMode.getValueForName = function (name) {
  return this.$value_for_name(name)
};

/**
 * @param {number} value - the integer value of the security level
 * @returns {string} - the name of the corresponding security level
 */
SafeMode.getNameForValue = function (value) {
  const name = this.$name_for_value(value);
  return name === Opal.nil ? undefined : name
};

/**
 * @returns {Array<string>} - the String {Array} of security levels
 */
SafeMode.getNames = function () {
  return this.$names()
};

// Callouts API

/**
 * Maintains a catalog of callouts and their associations.
 * @namespace
 */
const Callouts = Opal.Asciidoctor.Callouts;

/**
 * Create a new Callouts.
 * @returns {Callouts} - a new Callouts
 * @memberof Callouts
 */
Callouts.create = function () {
  return this.$new()
};

/**
 * Register a new callout for the given list item ordinal.
 * Generates a unique id for this callout based on the index of the next callout list in the document and the index of this callout since the end of the last callout list.
 *
 * @param {number} ordinal - the Integer ordinal (1-based) of the list item to which this callout is to be associated
 * @returns {string} - The unique String id of this callout
 * @example
 *  callouts = asciidoctor.Callouts.create()
 *  callouts.register(1)
 *  // => "CO1-1"
 *  callouts.nextList()
 *  callouts.register(2)
 *  // => "CO2-1"
 * @memberof Callouts
 */

Callouts.prototype.register = function (ordinal) {
  return this.$register(ordinal)
};
/**
 * Get the next callout index in the document.
 *
 * Reads the next callout index in the document and advances the pointer.
 * This method is used during conversion to retrieve the unique id of the callout that was generated during parsing.
 *
 * @returns {string} - The unique String id of the next callout in the document
 * @memberof Callouts
 */
Callouts.prototype.readNextId = function () {
  return this.$read_next_id()
};

/**
 * et a space-separated list of callout ids for the specified list item.
 * @param {number} ordinal - the Integer ordinal (1-based) of the list item for which to retrieve the callouts
 * @returns {string} - a space-separated String of callout ids associated with the specified list item
 * @memberof Callouts
 */
Callouts.prototype.getCalloutIds = function (ordinal) {
  return this.$callout_ids(ordinal)
};

/**
 * @memberof Callouts
 */
Callouts.prototype.getLists = function () {
  const lists = this.lists;
  if (lists && lists.length > 0) {
    for (let i = 0; i < lists.length; i++) {
      const list = lists[i];
      if (list && list.length > 0) {
        for (let j = 0; j < list.length; j++) {
          if (typeof list[j] === 'object' && '$$smap' in list[j]) {
            list[j] = fromHash(list[j]);
          }
        }
      }
    }
  }
  return lists
};

/**
 * @memberof Callouts
 */
Callouts.prototype.getListIndex = function () {
  return this.list_index
};

/**
 * The current list for which callouts are being collected.
 * @returns {Array} - The Array of callouts at the position of the list index pointer
 * @memberof Callouts
 */
Callouts.prototype.getCurrentList = function () {
  const currentList = this.$current_list();
  if (currentList && currentList.length > 0) {
    for (let i = 0; i < currentList.length; i++) {
      if (typeof currentList[i] === 'object' && '$$smap' in currentList[i]) {
        currentList[i] = fromHash(currentList[i]);
      }
    }
  }
  return currentList
};

/**
 * Advance to the next callout list in the document.
 * @memberof Callouts
 */
Callouts.prototype.nextList = function () {
  return this.$nextList()
};

/**
 * Rewind the list index pointer, intended to be used when switching from the parsing to conversion phase.
 * @memberof Callouts
 */
Callouts.prototype.rewind = function () {
  return this.$rewind()
};

/**
 * @returns {Document/RevisionInfo} - a {@link Document/RevisionInfo}
 * @memberof Document
 */
Document.prototype.getRevisionInfo = function () {
  return new Document.RevisionInfo(this.getRevisionDate(), this.getRevisionNumber(), this.getRevisionRemark())
};

/**
 * @returns {boolean} - true if the document contains revision info, otherwise false
 * @memberof Document
 */
Document.prototype.hasRevisionInfo = function () {
  const revisionInfo = this.getRevisionInfo();
  return !revisionInfo.isEmpty()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNotitle = function () {
  return this.$notitle()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNoheader = function () {
  return this.$noheader()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getNofooter = function () {
  return this.$nofooter()
};

/**
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasHeader = function () {
  return this['$header?']()
};

/**
 * Replay attribute assignments at the block level.
 *
 * <i>This method belongs to an internal API that deals with how attributes are managed by the processor.</i>
 * If you understand why this group of methods are necessary, and what they do, feel free to use them.
 * <strong>However, keep in mind they are subject to change at any time.</strong>
 *
 * @param {Object} blockAttributes - A JSON of attributes
 * @memberof Document
 */
Document.prototype.playbackAttributes = function (blockAttributes) {
  blockAttributes = toHash(blockAttributes);
  if (blockAttributes) {
    const attrEntries = blockAttributes['$[]']('attribute_entries');
    if (attrEntries && Array.isArray(attrEntries)) {
      const result = [];
      for (let i = 0; i < attrEntries.length; i++) {
        const attrEntryObject = attrEntries[i];
        if (attrEntryObject && typeof attrEntryObject === 'object' && attrEntryObject.constructor.name === 'Object') {
          attrEntryObject.$name = function () {
            return this.name
          };
          attrEntryObject.$value = function () {
            return this.value
          };
          attrEntryObject.$negate = function () {
            return this.negate
          };
        }
        result.push(attrEntryObject);
      }
      blockAttributes['$[]=']('attribute_entries', result);
    }
  }
  this.$playback_attributes(blockAttributes);
};

/**
 * Delete the specified attribute from the document if the name is not locked.
 * If the attribute is locked, false is returned.
 * Otherwise, the attribute is deleted.
 *
 * @param {string} name - the String attribute name
 *
 * @returns {boolean} - true if the attribute was deleted, false if it was not because it's locked
 * @memberof Document
 */
Document.prototype.deleteAttribute = function (name) {
  return this.$delete_attribute(name)
};

/**
 * Determine if the attribute has been locked by being assigned in document options.
 *
 * @param {string} key - The attribute key to check
 *
 * @returns {boolean} - true if the attribute is locked, false otherwise
 * @memberof Document
 */
Document.prototype.isAttributeLocked = function (key) {
  return this['$attribute_locked?'](key)
};

/**
 * Restore the attributes to the previously saved state (attributes in header).
 *
 * @memberof Document
 */
Document.prototype.restoreAttributes = function () {
  return this.$restore_attributes()
};

/**
 * Parse the AsciiDoc source stored in the {Reader} into an abstract syntax tree.
 *
 * If the data parameter is not nil, create a new {PreprocessorReader} and assigned it to the reader property of this object.
 * Otherwise, continue with the reader that was created when the {Document} was instantiated.
 * Pass the reader to {Parser.parse} to parse the source data into an abstract syntax tree.
 *
 * If parsing has already been performed, this method returns without performing any processing.
 *
 * @param {string|Array<string>} [data] - The optional replacement AsciiDoc source data as a String or String Array. (default: undefined)
 *
 * @returns {Document} - this {Document}
 * @memberof Document
 */
Document.prototype.parse = function (data) {
  return this.$parse(data)
};

/**
 * Read the docinfo file(s) for inclusion in the document template
 *
 * If the docinfo1 attribute is set, read the docinfo.ext file.
 * If the docinfo attribute is set, read the doc-name.docinfo.ext file.
 * If the docinfo2 attribute is set, read both files in that order.
 *
 * @param {string} docinfoLocation - The Symbol location of the docinfo (e.g., head, footer, etc). (default: head)
 * @param {string|undefined} suffix - The suffix of the docinfo file(s).
 * If not set, the extension will be set to the outfilesuffix. (default: undefined)
 *
 * @returns {string} - the contents of the docinfo file(s) or empty string if no files are found or the safe mode is secure or greater.
 * @memberof Document
 */
Document.prototype.getDocinfo = function (docinfoLocation, suffix) {
  return this.$docinfo(docinfoLocation, suffix)
};

/**
 * @param {string} [docinfoLocation] - A {string} for checking docinfo extensions at a given location (head or footer) (default: head)
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.hasDocinfoProcessors = function (docinfoLocation) {
  return this['$docinfo_processors?'](docinfoLocation)
};

/**
 * Increment the specified counter and store it in the block's attributes.
 *
 * @param {string} counterName - the String name of the counter attribute
 * @param {Block} block - the {Block} on which to save the counter
 *
 * @returns {number} - the next number in the sequence for the specified counter
 * @memberof Document
 */
Document.prototype.incrementAndStoreCounter = function (counterName, block) {
  return this.$increment_and_store_counter(counterName, block)
};

/**
 * @deprecated Please use {Document#incrementAndStoreCounter} method.
 * @memberof Document
 */
Document.prototype.counterIncrement = Document.prototype.incrementAndStoreCounter;

/**
 * Get the named counter and take the next number in the sequence.
 *
 * @param {string} name - the String name of the counter
 * @param {string|number} seed - the initial value as a String or Integer
 *
 * @returns {number} the next number in the sequence for the specified counter
 * @memberof Document
 */
Document.prototype.counter = function (name, seed) {
  return this.$counter(name, seed)
};

/**
 * A read-only integer value indicating the level of security that should be enforced while processing this document.
 * The value must be set in the Document constructor using the "safe" option.
 *
 * A value of 0 (UNSAFE) disables any of the security features enforced by Asciidoctor.
 *
 * A value of 1 (SAFE) closely parallels safe mode in AsciiDoc.
 * In particular, it prevents access to files which reside outside of the parent directory of the source file and disables any macro other than the include directive.
 *
 * A value of 10 (SERVER) disallows the document from setting attributes that would affect the conversion of the document,
 * in addition to all the security features of SafeMode.SAFE.
 * For instance, this level forbids changing the backend or source-highlighter using an attribute defined in the source document header.
 * This is the most fundamental level of security for server deployments (hence the name).
 *
 * A value of 20 (SECURE) disallows the document from attempting to read files from the file system and including the contents of them into the document,
 * in addition to all the security features of SafeMode.SECURE.
 * In particular, it disallows use of the include::[] directive and the embedding of binary content (data uri), stylesheets and JavaScripts referenced by the document.
 * (Asciidoctor and trusted extensions may still be allowed to embed trusted content into the document).
 *
 * Since Asciidoctor is aiming for wide adoption, 20 (SECURE) is the default value and is recommended for server deployments.
 *
 * A value of 100 (PARANOID) is planned to disallow the use of passthrough macros and prevents the document from setting any known attributes,
 * in addition to all the security features of SafeMode.SECURE.
 * Please note that this level is not currently implemented (and therefore not enforced)!
 *
 * @returns {number} - An integer value indicating the level of security
 * @memberof Document
 */
Document.prototype.getSafe = function () {
  return this.safe
};

/**
 * Get the Boolean AsciiDoc compatibility mode.
 * Enabling this attribute activates the following syntax changes:
 *
 *   * single quotes as constrained emphasis formatting marks
 *   * single backticks parsed as inline literal, formatted as monospace
 *   * single plus parsed as constrained, monospaced inline formatting
 *   * double plus parsed as constrained, monospaced inline formatting
 *
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getCompatMode = function () {
  return this.compat_mode
};

/**
 * Get the Boolean flag that indicates whether source map information should be tracked by the parser.
 * @returns {boolean}
 * @memberof Document
 */
Document.prototype.getSourcemap = function () {
  const sourcemap = this.sourcemap;
  return sourcemap === Opal.nil ? false : sourcemap
};

/**
 * Set the Boolean flag that indicates whether source map information should be tracked by the parser.
 * @param {boolean} value
 * @memberof Document
 */
Document.prototype.setSourcemap = function (value) {
  this.sourcemap = value;
};

/**
 * Get the JSON of document counters.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCounters = function () {
  return fromHash(this.counters)
};

/**
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getCallouts = function () {
  return this.$callouts()
};

/**
 * Get the String base directory for converting this document.
 *
 * Defaults to directory of the source file.
 * If the source is a string, defaults to the current directory.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getBaseDir = function () {
  return this.base_dir
};

/**
 * Get the JSON of resolved options used to initialize this {Document}.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getOptions = function () {
  return fromHash(this.options)
};

/**
 * Get the outfilesuffix defined at the end of the header.
 * @returns {string}
 * @memberof Document
 */
Document.prototype.getOutfilesuffix = function () {
  return this.outfilesuffix
};

/**
 * Get a reference to the parent Document of this nested document.
 * @returns {Document|undefined}
 * @memberof Document
 */
Document.prototype.getParentDocument = function () {
  const parentDocument = this.parent_document;
  return parentDocument === Opal.nil ? undefined : parentDocument
};

/**
 * Get the {Reader} associated with this document.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getReader = function () {
  return this.reader
};

/**
 * Get the {Converter} instance being used to convert the current {Document}.
 * @returns {Object}
 * @memberof Document
 */
Document.prototype.getConverter = function () {
  return this.converter
};

/**
 * Get the activated {Extensions.Registry} associated with this document.
 * @returns {Extensions/Registry}
 * @memberof Document
 */
Document.prototype.getExtensions = function () {
  const extensions = this.extensions;
  return extensions === Opal.nil ? undefined : extensions
};

// Document.Title API

/**
 * A partitioned title (i.e., title & subtitle).
 * @namespace
 * @module Document/Title
 */
const Title = Document.Title;

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getMain = function () {
  return this.main
};

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getCombined = function () {
  return this.combined
};

/**
 * @returns {string}
 * @memberof Document/Title
 */
Title.prototype.getSubtitle = function () {
  const subtitle = this.subtitle;
  return subtitle === Opal.nil ? undefined : subtitle
};

/**
 * @returns {boolean}
 * @memberof Document/Title
 */
Title.prototype.isSanitized = function () {
  const sanitized = this['$sanitized?']();
  return sanitized === Opal.nil ? false : sanitized
};

/**
 * @returns {boolean}
 * @memberof Document/Title
 */
Title.prototype.hasSubtitle = function () {
  return this['$subtitle?']()
};

// Inline API

/**
 * Methods for managing inline elements in AsciiDoc block.
 * @namespace
 * @extends AbstractNode
 */
const Inline = Opal.Asciidoctor.Inline;

/**
 * Create a new Inline element.
 * @param {AbstractBlock} parent
 * @param {string} context
 * @param {string|undefined} text
 * @param {Object|undefined} opts
 * @returns {Inline} - a new Inline element
 * @memberof Inline
 */
Inline.create = function (parent, context, text, opts) {
  return this.$new(parent, context, text, prepareOptions(opts))
};

/**
 * Get the converted content for this inline node.
 *
 * @returns {string} - the converted String content for this inline node
 * @memberof Inline
 */
Inline.prototype.convert = function () {
  return this.$convert()
};

/**
 * Get the converted String text of this Inline node, if applicable.
 *
 * @returns {string|undefined} - the converted String text for this Inline node, or undefined if not applicable for this node.
 * @memberof Inline
 */
Inline.prototype.getText = function () {
  const text = this.$text();
  return text === Opal.nil ? undefined : text
};

/**
 * Get the String sub-type (aka qualifier) of this Inline node.
 *
 * This value is used to distinguish different variations of the same node
 * category, such as different types of anchors.
 *
 * @returns {string} - the string sub-type of this Inline node.
 * @memberof Inline
 */
Inline.prototype.getType = function () {
  return this.$type()
};

/**
 * Get the primary String target of this Inline node.
 *
 * @returns {string|undefined} - the string target of this Inline node.
 * @memberof Inline
 */
Inline.prototype.getTarget = function () {
  const target = this.$target();
  return target === Opal.nil ? undefined : target
};

/**
 * Returns the converted alt text for this inline image.
 *
 * @returns {string} - the String value of the alt attribute.
 * @memberof Inline
 */
Inline.prototype.getAlt = function () {
  return this.$alt()
};

// List API

/**
 * Methods for managing AsciiDoc lists (ordered, unordered and description lists).
 * @namespace
 * @extends AbstractBlock
 */
const List = Opal.Asciidoctor.List;

/**
 * Checks if the {@link List} contains any child {@link ListItem}.
 *
 * @memberof List
 * @returns {boolean} - whether the {@link List} has child {@link ListItem}.
 */
List.prototype.hasItems = function () {
  return this['$items?']()
};

/**
 * Get the Array of {@link ListItem} nodes for this {@link List}.
 *
 * @returns {Array<ListItem>} - an Array of {@link ListItem} nodes.
 * @memberof List
 */
List.prototype.getItems = function () {
  return this.blocks
};

// ListItem API

/**
 * Methods for managing items for AsciiDoc olists, ulist, and dlists.
 *
 * In a description list (dlist), each item is a tuple that consists of a 2-item Array of ListItem terms and a ListItem description (i.e., [[term, term, ...], desc].
 * If a description is not set, then the second entry in the tuple is nil.
 * @namespace
 * @extends AbstractBlock
 */
const ListItem = Opal.Asciidoctor.ListItem;

/**
 * Get the converted String text of this {@link ListItem} node.
 *
 * @returns {string} - the converted String text for this {@link ListItem} node.
 * @memberof ListItem
 */
ListItem.prototype.getText = function () {
  return this.$text()
};

/**
 * Set the String source text of this {@link ListItem} node.
 *
 * @returns {string} - the new String text assigned to this {@link ListItem}
 * @memberof ListItem
 */
ListItem.prototype.setText = function (text) {
  return this['$text='](text)
};

/**
 * A convenience method that checks whether the text of this {@link ListItem} is not blank (i.e. not undefined or empty string).
 *
 * @returns {boolean} - whether the text is not blank
 * @memberof ListItem
 */
ListItem.prototype.hasText = function () {
  return this['$text?']()
};

/**
 * Get the {string} used to mark this {@link ListItem}.
 *
 * @returns {string}
 * @memberof ListItem
 */
ListItem.prototype.getMarker = function () {
  return this.marker
};

/**
 * Set the {string} used to mark this {@link ListItem}.
 *
 * @param {string} marker - the {string} used to mark this {@link ListItem}
 * @memberof ListItem
 */
ListItem.prototype.setMarker = function (marker) {
  this.marker = marker;
};

/**
 * Get the {@link List} to which this {@link ListItem} is attached.
 *
 * @returns {List} - the {@link List} object to which this {@link ListItem} is attached,
 * or undefined if this node has no parent.
 * @memberof ListItem
 */
ListItem.prototype.getList = function () {
  return this.$list()
};

/**
 * @see {@link ListItem#getList}
 * @memberof ListItem
 */
ListItem.prototype.getParent = ListItem.prototype.getList;

// Reader API

/** @namespace */
const Reader = Opal.Asciidoctor.Reader;

/**
 * Push source onto the front of the reader and switch the context based on the file, document-relative path and line information given.
 *
 * This method is typically used in an IncludeProcessor to add source read from the target specified.
 *
 * @param {string} data
 * @param {string|undefined} file
 * @param {string|undefined} path
 * @param {number} lineno - The line number
 * @param {Object} attributes - a JSON of attributes
 * @returns {Reader} - this {Reader} object.
 * @memberof Reader
 */
Reader.prototype.pushInclude = function (data, file, path, lineno, attributes) {
  return this.$push_include(data, file, path, lineno, toHash(attributes))
};

/**
 * Get the current location of the reader's cursor, which encapsulates the file, dir, path, and lineno of the file being read.
 *
 * @returns {Cursor}
 * @memberof Reader
 */
Reader.prototype.getCursor = function () {
  return this.$cursor()
};

/**
 * Get the remaining unprocessed lines, without consuming them, as an {Array} of {string}.
 *
 * Lines will not be consumed from the Reader (ie. you will be able to read these lines again).
 *
 * @returns {Array<string>} - the remaining unprocessed lines as an {Array} of {string}.
 * @memberof Reader
 */
Reader.prototype.getLines = function () {
  return this.$lines()
};

/**
 * Get the remaining unprocessed lines, without consuming them, as a {string}.
 *
 * Lines will not be consumed from the Reader (ie. you will be able to read these lines again).
 *
 * @returns {string} - the remaining unprocessed lines as a {string} (joined by linefeed characters).
 * @memberof Reader
 */
Reader.prototype.getString = function () {
  return this.$string()
};

/**
 * Check whether there are any lines left to read.
 * If a previous call to this method resulted in a value of false, immediately returned the cached value.
 * Otherwise, delegate to peekLine to determine if there is a next line available.
 *
 * @returns {boolean} - true if there are more lines, false if there are not.
 * @memberof Reader
 */
Reader.prototype.hasMoreLines = function () {
  return this['$has_more_lines?']()
};

/**
 * Check whether this reader is empty (contains no lines).
 *
 * @returns {boolean} - true if there are no more lines to peek, otherwise false.
 * @memberof Reader
 */
Reader.prototype.isEmpty = function () {
  return this['$empty?']()
};

/**
 * Peek at the next line.
 * Processes the line if not already marked as processed, but does not consume it (ie. you will be able to read this line again).
 *
 * This method will probe the reader for more lines.
 * If there is a next line that has not previously been visited, the line is passed to the Reader#processLine method to be initialized.
 * This call gives sub-classes the opportunity to do preprocessing.
 * If the return value of the Reader#processLine is undefined, the data is assumed to be changed and Reader#peekLine is invoked again to perform further processing.
 *
 * If hasMoreLines is called immediately before peekLine, the direct flag is implicitly true (since the line is flagged as visited).
 *
 * @param {boolean} direct - A {boolean} flag to bypasses the check for more lines and immediately returns the first element of the internal lines {Array}. (default: false)
 * @returns {string} - the next line as a {string} if there are lines remaining.
 * @memberof Reader
 */
Reader.prototype.peekLine = function (direct) {
  direct = direct || false;
  const line = this.$peek_line(direct);
  return line === Opal.nil ? undefined : line
};

/**
 * Consume, preprocess, and return the next line.
 *
 * Line will be consumed from the Reader (ie. you won't be able to read this line again).
 *
 * @returns {string} - the next line as a {string} if data is present.
 * @memberof Reader
 */
Reader.prototype.readLine = function () {
  const line = this.$read_line();
  return line === Opal.nil ? undefined : line
};

/**
 * Consume, preprocess, and return the remaining lines.
 *
 * This method calls Reader#readLine repeatedly until all lines are consumed and returns the lines as an {Array} of {string}.
 * This method differs from Reader#getLines in that it processes each line in turn, hence triggering any preprocessors implemented in sub-classes.
 *
 * Lines will be consumed from the Reader (ie. you won't be able to read these lines again).
 *
 * @returns {Array<string>} - the lines read as an {Array} of {string}.
 * @memberof Reader
 */
Reader.prototype.readLines = function () {
  return this.$read_lines()
};

/**
 * Consume, preprocess, and return the remaining lines joined as a {string}.
 *
 * Delegates to Reader#readLines, then joins the result.
 *
 * Lines will be consumed from the Reader (ie. you won't be able to read these lines again).
 *
 * @returns {string} - the lines read joined as a {string}
 * @memberof Reader
 */
Reader.prototype.read = function () {
  return this.$read()
};

/**
 * Advance to the next line by discarding the line at the front of the stack.
 *
 * @returns {boolean} - a Boolean indicating whether there was a line to discard.
 * @memberof Reader
 */
Reader.prototype.advance = function () {
  return this.$advance()
};

// Cursor API

/** @namespace */
const Cursor = Opal.Asciidoctor.Reader.Cursor;

/**
 * Get the file associated to the cursor.
 * @returns {string|undefined}
 * @memberof Cursor
 */
Cursor.prototype.getFile = function () {
  const file = this.file;
  return file === Opal.nil ? undefined : file
};

/**
 * Get the directory associated to the cursor.
 * @returns {string|undefined} - the directory associated to the cursor
 * @memberof Cursor
 */
Cursor.prototype.getDirectory = function () {
  const dir = this.dir;
  return dir === Opal.nil ? undefined : dir
};

/**
 * Get the path associated to the cursor.
 * @returns {string|undefined} - the path associated to the cursor (or '<stdin>')
 * @memberof Cursor
 */
Cursor.prototype.getPath = function () {
  const path = this.path;
  return path === Opal.nil ? undefined : path
};

/**
 * Get the line number of the cursor.
 * @returns {number|undefined} - the line number of the cursor
 * @memberof Cursor
 */
Cursor.prototype.getLineNumber = function () {
  return this.lineno
};

// Logger API (available in Asciidoctor 1.5.7+)

function initializeLoggerFormatterClass (className, functions) {
  const superclass = Opal.const_get_qualified(Opal.Logger, 'Formatter');
  return initializeClass(superclass, className, functions, {}, {
    call: function (args) {
      for (let i = 0; i < args.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof args[i] === 'object' && '$$smap' in args[i]) {
          args[i] = fromHash(args[i]);
        }
      }
      return args
    }
  })
}

function initializeLoggerClass (className, functions) {
  const superClass = Opal.const_get_qualified(Opal.Asciidoctor, 'Logger');
  return initializeClass(superClass, className, functions, {}, {
    add: function (args) {
      if (args.length >= 2 && typeof args[2] === 'object' && '$$smap' in args[2]) {
        const message = args[2];
        const messageObject = fromHash(message);
        messageObject.getText = function () {
          return this.text
        };
        messageObject.getSourceLocation = function () {
          return this.source_location
        };
        messageObject.$inspect = function () {
          const sourceLocation = this.getSourceLocation();
          if (sourceLocation) {
            return sourceLocation.getPath() + ': line ' + sourceLocation.getLineNumber() + ': ' + this.getText()
          } else {
            return this.getText()
          }
        };
        args[2] = messageObject;
      }
      if (args.length >= 1) {
        args[1] = args[1] === Opal.nil ? undefined : args[1];
      }
      return args
    }
  })
}

/**
 * @namespace
 */
const LoggerManager = Opal.const_get_qualified(Opal.Asciidoctor, 'LoggerManager', true);

// Alias
Opal.Asciidoctor.LoggerManager = LoggerManager;

/**
 * @memberof LoggerManager
 */
LoggerManager.getLogger = function () {
  return this.$logger()
};

/**
 * @memberof LoggerManager
 */
LoggerManager.setLogger = function (logger) {
  this['$logger='](logger);
};

/**
 * @memberof LoggerManager
 */
LoggerManager.newLogger = function (name, functions) {
  return initializeLoggerClass(name, functions).$new()
};

/**
 * @memberof LoggerManager
 */
LoggerManager.newFormatter = function (name, functions) {
  return initializeLoggerFormatterClass(name, functions).$new()
};

/**
 * @namespace
 */
const LoggerSeverity = Opal.const_get_qualified(Opal.Logger, 'Severity', true);

// Alias
Opal.Asciidoctor.LoggerSeverity = LoggerSeverity;

/**
 * @memberof LoggerSeverity
 */
LoggerSeverity.get = function (severity) {
  return LoggerSeverity.$constants()[severity]
};

/**
 * @namespace
 */
const LoggerFormatter = Opal.const_get_qualified(Opal.Logger, 'Formatter', true);

// Alias
Opal.Asciidoctor.LoggerFormatter = LoggerFormatter;

/**
 * @memberof LoggerFormatter
 */
LoggerFormatter.prototype.call = function (severity, time, programName, message) {
  return this.$call(LoggerSeverity.get(severity), time, programName, message)
};

/**
 * @namespace
 */
const MemoryLogger = Opal.const_get_qualified(Opal.Asciidoctor, 'MemoryLogger', true);

// Alias
Opal.Asciidoctor.MemoryLogger = MemoryLogger;

/**
 * Create a new MemoryLogger.
 * @returns {MemoryLogger} - a MemoryLogger
 * @memberof MemoryLogger
 */
MemoryLogger.create = function () {
  return this.$new()
};

/**
 * @returns {Array<Object>} - a list of messages
 * @memberof MemoryLogger
 */
MemoryLogger.prototype.getMessages = function () {
  const messages = this.messages;
  const result = [];
  for (let i = 0; i < messages.length; i++) {
    const message = messages[i];
    const messageObject = fromHash(message);
    if (typeof messageObject.message === 'string') {
      messageObject.getText = function () {
        return this.message
      };
    } else {
      // also convert the message attribute
      messageObject.message = fromHash(messageObject.message);
      messageObject.getText = function () {
        return this.message.text
      };
    }
    messageObject.getSeverity = function () {
      return this.severity.toString()
    };
    messageObject.getSourceLocation = function () {
      return this.message.source_location
    };
    result.push(messageObject);
  }
  return result
};

const Logging = Opal.const_get_qualified(Opal.Asciidoctor, 'Logging', true);

Opal.Asciidoctor.Logging = Logging;

Logging.getLogger = function () {
  return LoggerManager.$logger()
};

Logging.createLogMessage = function (text, context) {
  return Logging.prototype.$message_with_context(text, toHash(context))
};

// alias

/**
 * @memberof Reader
 */
Reader.prototype.getLogger = Logging.getLogger;
/**
 * @memberof Reader
 */
Reader.prototype.createLogMessage = Logging.createLogMessage;

/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.getLogger = Logging.getLogger;
/**
 * @memberof AbstractNode
 */
AbstractNode.prototype.createLogMessage = Logging.createLogMessage;

/**
 * @namespace
 */
const Logger = Opal.const_get_qualified(Opal.Asciidoctor, 'Logger', true);

// Alias
Opal.Asciidoctor.Logger = Logger;

/**
 * @returns {number|undefined} - the maximum severity
 * @memberof Logger
 */
Logger.prototype.getMaxSeverity = function () {
  const result = this.max_severity;
  return result === Opal.nil ? undefined : result
};
/**
 * @returns {LoggerFormatter} - the formatter
 * @memberof Logger
 */
Logger.prototype.getFormatter = function () {
  return this.formatter
};
/**
 * @param {LoggerFormatter} formatter - the formatter
 * @memberof Logger
 */
Logger.prototype.setFormatter = function (formatter) {
  this.formatter = formatter;
};
/**
 * @returns {number} - the logging severity threshold
 * @memberof Logger
 */
Logger.prototype.getLevel = function () {
  return this.level
};
/**
 * @param {number} level - the logging severity threshold
 * @memberof Logger
 */
Logger.prototype.setLevel = function (level) {
  this.level = level;
};
/**
 * @returns {string} - the program name
 * @memberof Logger
 */
Logger.prototype.getProgramName = function () {
  return this.progname
};
/**
 * @param {string} programName - the program name
 * @memberof Logger
 */
Logger.prototype.setProgramName = function (programName) {
  this.progname = programName;
};

const RubyLogger = Opal.const_get_qualified('::', 'Logger');

const log = function (logger, level, message) {
  logger['$' + level](message);
};
RubyLogger.prototype.add = function (severity, message, programName) {
  const severityValue = typeof severity === 'string' ? LoggerSeverity[severity.toUpperCase()] : severity;
  this.$add(severityValue, message, programName);
};
RubyLogger.prototype.log = RubyLogger.prototype.add;
RubyLogger.prototype.debug = function (message) {
  log(this, 'debug', message);
};
RubyLogger.prototype.info = function (message) {
  log(this, 'info', message);
};
RubyLogger.prototype.warn = function (message) {
  log(this, 'warn', message);
};
RubyLogger.prototype.error = function (message) {
  log(this, 'error', message);
};
RubyLogger.prototype.fatal = function (message) {
  log(this, 'fatal', message);
};
RubyLogger.prototype.isDebugEnabled = function () {
  return this['$debug?']()
};
RubyLogger.prototype.isInfoEnabled = function () {
  return this['$info?']()
};
RubyLogger.prototype.isWarnEnabled = function () {
  return this['$warn?']()
};
RubyLogger.prototype.isErrorEnabled = function () {
  return this['$error?']()
};
RubyLogger.prototype.isFatalEnabled = function () {
  return this['$fatal?']()
};

/**
 * @namespace
 */
const NullLogger = Opal.const_get_qualified(Opal.Asciidoctor, 'NullLogger', true);

// Alias
Opal.Asciidoctor.NullLogger = NullLogger;

/**
 * Create a new NullLogger.
 * @returns {NullLogger} - a NullLogger
 * @memberof NullLogger
 */
NullLogger.create = function () {
  return this.$new()
};

/**
 * @returns {number|undefined} - the maximum severity
 * @memberof NullLogger
 */
NullLogger.prototype.getMaxSeverity = function () {
  return this.max_severity
};

// Alias
Opal.Asciidoctor.StopIteration = Opal.StopIteration;

/**
 * @namespace
 */
const Timings = Opal.const_get_qualified(Opal.Asciidoctor, 'Timings', true);

// Alias
Opal.Asciidoctor.Timings = Timings;

/**
 * Create a new Timings.
 * @returns {Timings} - a Timings
 * @memberof Timings
 */
Timings.create = function () {
  return this.$new()
};

/**
 * Print a report to the specified output.
 * The report will include:
 * - the time to read and parse source
 * - the time to convert document
 * - the total time (read, parse and convert)
 * @param {RubyLogger|console|Object} [to] - an optional output (by default stdout)
 * @param {string} [subject] - an optional subject (usually the file name)
 * @memberof Timings
 */
Timings.prototype.printReport = function (to, subject) {
  let outputFunction;
  if (to) {
    if (typeof to.$add === 'function') {
      outputFunction = function (message) {
        to.$add(1, message);
      };
    } else if (typeof to.log === 'function') {
      outputFunction = to.log;
    } else if (typeof to.write === 'function') {
      outputFunction = function (message) {
        to.write(message, 'utf-8');
      };
    } else {
      throw new Error('The output should be a Stream (with a write function), an object with a log function or a Ruby Logger (with a add function)')
    }
  } else {
    outputFunction = function (message) {
      Opal.gvars.stdout.$write(message);
    };
  }
  if (subject) {
    outputFunction('Input file: ' + subject);
  }
  outputFunction(' Time to read and parse source: ' + this.$read_parse().toFixed(2));
  outputFunction(' Time to convert document: ' + this.$convert().toFixed(2));
  outputFunction(' Total time (read, parse and convert): ' + this.$read_parse_convert().toFixed(2));
};

/**
 * @namespace
 * @description
 * This API is experimental and subject to change.
 *
 * A pluggable adapter for integrating a syntax (aka code) highlighter into AsciiDoc processing.
 *
 * There are two types of syntax highlighter adapters. The first performs syntax highlighting during the convert phase.
 * This adapter type must define a "handlesHighlighting" method that returns true.
 * The companion "highlight" method will then be called to handle the "specialcharacters" substitution for source blocks.
 *
 * The second assumes syntax highlighting is performed on the client (e.g., when the HTML document is loaded).
 * This adapter type must define a "hasDocinfo" method that returns true.
 * The companion "docinfo" method will then be called to insert markup into the output document.
 * The docinfo functionality is available to both adapter types.
 *
 * Asciidoctor.js provides several a built-in adapter for highlight.js.
 * Additional adapters can be registered using SyntaxHighlighter.register.
 */
const SyntaxHighlighter = Opal.const_get_qualified(Opal.Asciidoctor, 'SyntaxHighlighter', true);

// Alias
Opal.Asciidoctor.SyntaxHighlighter = SyntaxHighlighter;

/**
 * Associates the syntax highlighter class or object with the specified names.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string|Array} names - A {string} name or an {Array} of {string} names
 * @param functions - A list of functions representing a {SyntaxHighlighter} or a {SyntaxHighlighter} class to instantiate
 * @memberof SyntaxHighlighter
 */
SyntaxHighlighter.register = function (names, functions) {
  const name = typeof names === 'string' ? names : names[0];
  if (typeof functions === 'function') {
    const classObject = functions;
    const prototype = classObject.prototype;
    const properties = Object.getOwnPropertyNames(prototype);
    functions = {};
    for (const propertyIdx in properties) {
      const propertyName = properties[propertyIdx];
      functions[propertyName] = prototype[propertyName];
    }
  }
  const scope = initializeClass(SyntaxHighlighterBase, name, functions, {}, {
    format: function (args) {
      if (args.length >= 2 && typeof args[2] === 'object' && '$$smap' in args[2]) {
        args[2] = fromHash(args[2]);
      }
      if (args.length >= 1) {
        args[1] = args[1] === Opal.nil ? undefined : args[1];
      }
      return args
    },
    highlight: function (args) {
      if (args.length >= 3 && typeof args[3] === 'object' && '$$smap' in args[3]) {
        let opts = args[3];
        opts = fromHash(opts);
        for (const key in opts) {
          const value = opts[key];
          if (key === 'callouts') {
            const callouts = fromHashKeys(value);
            for (const idx in callouts) {
              const callout = callouts[idx];
              for (let i = 0; i < callout.length; i++) {
                const items = callout[i];
                for (let j = 0; j < items.length; j++) {
                  items[j] = items[j] === Opal.nil ? undefined : items[j];
                }
              }
            }
            opts[key] = callouts;
          } else {
            opts[key] = value === Opal.nil ? undefined : value;
          }
        }
        args[3] = opts;
      }
      if (args.length >= 2) {
        args[2] = args[2] === Opal.nil ? undefined : args[2];
      }
      return args
    }
  });
  for (const functionName in functions) {
    if (Object.prototype.hasOwnProperty.call(functions, functionName)) {
      (function (functionName) {
        const userFunction = functions[functionName];
        if (functionName === 'handlesHighlighting') {
          Opal.def(scope, '$highlight?', function () {
            return userFunction.call()
          });
        } else if (functionName === 'hasDocinfo') {
          Opal.def(scope, '$docinfo?', function (location) {
            return userFunction.apply(this, [location])
          });
        }
      }(functionName));
    }
  }
  Opal.def(scope, '$name', function () {
    return name
  });
  SyntaxHighlighter.$register(scope, names);
  return scope
};

/**
 * Retrieves the syntax highlighter class or object registered for the specified name.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string} name - The {string} name of the syntax highlighter to retrieve.
 * @returns {SyntaxHighlighter} - the {SyntaxHighlighter} registered for this name.
 * @memberof SyntaxHighlighter
 */
SyntaxHighlighter.get = function (name) {
  const result = SyntaxHighlighter.$for(name);
  return result === Opal.nil ? undefined : result
};

/**
 * @deprecated Please use {SyntaxHighlighter#get} method as "for" is a reserved keyword.
 */
SyntaxHighlighter.for = SyntaxHighlighter.get;

/**
 * @namespace
 */
const SyntaxHighlighterBase = Opal.const_get_qualified(SyntaxHighlighter, 'Base', true);

// Alias
Opal.Asciidoctor.SyntaxHighlighterBase = SyntaxHighlighterBase;

/**
 * Statically register the current class in the registry for the specified names.
 *
 * @description This API is experimental and subject to change.
 *
 * @param {string|Array<string>} names - A {string} name or an {Array} of {string} names
 * @memberof SyntaxHighlighterBase
 */
SyntaxHighlighterBase.prototype.registerFor = function (names) {
  SyntaxHighlighter.$register(this, names);
};

// Table API

/**
 * Methods for managing AsciiDoc tables.
 * @namespace
 * @extends AbstractBlock
 */
const Table = Opal.Asciidoctor.Table;

/**
 * Create a new Table element.
 * @param {AbstractBlock} parent
 * @param {Object|undefined} attributes
 * @returns {Table} - a new {Table} object
 */
Table.create = function (parent, attributes) {
  return this.$new(parent, toHash(attributes))
};

/**
 * Get the caption of the table.
 * @returns {string}
 * @memberof Table
 */
Table.prototype.getCaption = function () {
  return this.caption
};

/**
 * Get the rows of this table.
 * @returns {Table.Rows} - an {Table.Rows} object with the members "head", "body" and "foot"
 * @memberof Table
 */
Table.prototype.getRows = function () {
  return this.rows
};

/**
 * Get the columns of this table.
 * @returns {Array<Column>}
 * @memberof Table
 */
Table.prototype.getColumns = function () {
  return this.columns
};

/**
 * Get the head rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getHeadRows = function () {
  return this.rows.head
};

/**
 * Check if the table has a head rows.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasHeadRows = function () {
  return this.rows !== Opal.nil && this.rows.head.length > 0
};

/**
 * Get the body rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getBodyRows = function () {
  return this.rows.body
};

/**
 * Check if the table has a body rows.
 * @returns {boolean}
 */
Table.prototype.hasBodyRows = function () {
  return this.rows !== Opal.nil && this.rows.body.length > 0
};

/**
 * Get the foot rows of this table.
 * @returns {Array<Array<Cell>>} - an Array of Array of Cell
 * @memberof Table
 */
Table.prototype.getFootRows = function () {
  return this.rows.foot
};

/**
 * Check if the table has a foot rows.
 * @returns {boolean}
 */
Table.prototype.hasFootRows = function () {
  return this.rows !== Opal.nil && this.rows.foot.length > 0
};

/**
 * Check if the table has a header option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasHeaderOption = function () {
  return this.has_header_option
};

/**
 * Check if the table has the footer option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasFooterOption = function () {
  return this.isOption('footer')
};

/**
 * Check if the table has the autowidth option set.
 * @returns {boolean}
 * @memberof Table
 */
Table.prototype.hasAutowidthOption = function () {
  return this.isOption('autowidth')
};

/**
 * Get the number of rows in the table.
 * Please note that the header and footer rows are also counted.
 * @returns {number|undefined}
 * @memberof Table
 */
Table.prototype.getRowCount = function () {
  return this.getAttribute('rowcount')
};

/**
 * Set the number of rows in the table.
 * Please note that the header and footer rows are also counted.
 * @param {number} value - the value
 * @memberof Table
 */
Table.prototype.setRowCount = function (value) {
  this.setAttribute('rowcount', value);
};

/**
 * Get the number of columns in the table.
 * @returns {number|undefined}
 * @memberof Table
 */
Table.prototype.getColumnCount = function () {
  return this.getAttribute('colcount')
};

/**
 * Set the number of columns in the table.
 * @param {number} value - the value
 * @memberof Table
 */
Table.prototype.setColumnCount = function (value) {
  this.setAttribute('colcount', value);
};

// Rows

/**
 * @namespace
 */
const Rows = Opal.Asciidoctor.Table.Rows;

/**
 * Create a new Rows element.
 * @param {array<array<Cell>>} head
 * @param {array<array<Cell>>} foot
 * @param {array<array<Cell>>} body
 * @returns Rows
 */
Rows.create = function (head, foot, body) {
  return this.$new(head, foot, body)
};

/**
 * Get head rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getHead = function () {
  return this.head
};

/**
 * Get foot rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getFoot = function () {
  return this.foot
};

/**
 * Get body rows.
 * @returns {array<array<Cell>>}
 */
Rows.prototype.getBody = function () {
  return this.body
};

/**
 * Retrieve the rows grouped by section as a nested Array.
 *
 * Creates a 2-dimensional array of two element entries.
 * The first element is the section name as a string.
 * The second element is the Array of rows in that section.
 * The entries are in document order (head, foot, body).
 * @returns {[[string, array<array<Cell>>], [string, array<array<Cell>>], [string, array<array<Cell>>]]}
 */
Rows.prototype.bySection = function () {
  return [['head', this.head], ['body', this.body], ['foot', this.foot]]
};

// Table Column

/**
 * Methods to manage the columns of an AsciiDoc table.
 * In particular, it keeps track of the column specs.
 * @namespace
 * @extends AbstractNode
 */
const Column = Opal.Asciidoctor.Table.Column;

/**
 * Create a new Column element.
 * @param {Table} table
 * @param {number} index
 * @param {Object|undefined} attributes
 * @returns Column
 */
Column.create = function (table, index, attributes) {
  return this.$new(table, index, toHash(attributes))
};

/**
 * Get the column number of this cell.
 * @returns {number|undefined}
 * @memberof Column
 */
Column.prototype.getColumnNumber = function () {
  return this.getAttribute('colnumber')
};

/**
 * Get the width of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getWidth = function () {
  return this.getAttribute('width')
};

/**
 * Get the horizontal align of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getHorizontalAlign = function () {
  return this.getAttribute('halign')
};

/**
 * Get the vertical align of this cell.
 * @returns {string|undefined}
 * @memberof Column
 */
Column.prototype.getVerticalAlign = function () {
  return this.getAttribute('valign')
};

/**
 * Get the style of this cell.
 * @returns {string}
 * @memberof Column
 */
Column.prototype.getStyle = function () {
  const style = this.style;
  return style === Opal.nil ? undefined : style
};

// Table Cell

/**
 * Methods for managing the cells in an AsciiDoc table.
 * @namespace
 * @extends AbstractBlock
 */
const Cell = Opal.Asciidoctor.Table.Cell;

/**
 * Create a new Cell element
 * @param {Column} column
 * @param {string} cellText
 * @param {Object|undefined} attributes
 * @param {Object|undefined} opts
 * @returns {Cell}
 */
Cell.create = function (column, cellText, attributes, opts) {
  return this.$new(column, cellText, toHash(attributes), toHash(opts))
};

/**
 * Get the column span of this {@link Cell} node.
 * @returns {number} - An Integer of the number of columns this cell will span (default: undefined)
 * @memberof Cell
 */
Cell.prototype.getColumnSpan = function () {
  const colspan = this.colspan;
  return colspan === Opal.nil ? undefined : colspan
};

/**
 * Set the column span of this {@link Cell} node.
 * @param {number} value
 * @returns {number} - The new colspan value
 * @memberof Cell
 */
Cell.prototype.setColumnSpan = function (value) {
  return this['$colspan='](value)
};

/**
 * Get the row span of this {@link Cell} node
 * @returns {number|undefined} - An Integer of the number of rows this cell will span (default: undefined)
 * @memberof Cell
 */
Cell.prototype.getRowSpan = function () {
  const rowspan = this.rowspan;
  return rowspan === Opal.nil ? undefined : rowspan
};

/**
 * Set the row span of this {@link Cell} node
 * @param {number} value
 * @returns {number} - The new rowspan value
 * @memberof Cell
 */
Cell.prototype.setRowSpan = function (value) {
  return this['$rowspan='](value)
};

/**
 * Get the content of the cell.
 * This method should not be used for cells in the head row or that have the literal style.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getContent = function () {
  return this.$content()
};

/**
 * Get the text of the cell.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getText = function () {
  return this.$text()
};

/**
 * Get the source of the cell.
 * @returns {string}
 * @memberof Cell
 */
Cell.prototype.getSource = function () {
  return this.$source()
};

/**
 * Get the lines of the cell.
 * @returns {Array<string>}
 * @memberof Cell
 */
Cell.prototype.getLines = function () {
  return this.$lines()
};

/**
 * Get the line number of the cell.
 * @returns {number|undefined}
 * @memberof Cell
 */
Cell.prototype.getLineNumber = function () {
  const lineno = this.$lineno();
  return lineno === Opal.nil ? undefined : lineno
};

/**
 * Get the source file of the cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getFile = function () {
  const file = this.$file();
  return file === Opal.nil ? undefined : file
};

/**
 * Get the style of the cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getStyle = function () {
  const style = this.$style();
  return style === Opal.nil ? undefined : style
};

/**
 * Get the column of this cell.
 * @returns {Column|undefined}
 * @memberof Cell
 */
Cell.prototype.getColumn = function () {
  const column = this.$column();
  return column === Opal.nil ? undefined : column
};

/**
 * Get the width of this cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getWidth = function () {
  return this.getAttribute('width')
};

/**
 * Get the column width in percentage of this cell.
 * @returns {string|undefined}
 * @memberof Cell
 */
Cell.prototype.getColumnPercentageWidth = function () {
  return this.getAttribute('colpcwidth')
};

/**
 * Get the nested {Document} of this cell when style is 'asciidoc'.
 * @returns {Document|undefined} - the nested {Document}
 * @memberof Cell
 */
Cell.prototype.getInnerDocument = function () {
  const innerDocument = this.inner_document;
  return innerDocument === Opal.nil ? undefined : innerDocument
};

// Templates

/**
 * @description
 * This API is experimental and subject to change.
 *
 * Please note that this API is currently only available in a Node environment.
 * We recommend to use a custom converter if you are running in the browser.
 *
 * @namespace
 * @module Converter/TemplateConverter
 */
const TemplateConverter = Opal.Asciidoctor.Converter.TemplateConverter;

if (TemplateConverter) {
  // Alias
  Opal.Asciidoctor.TemplateConverter = TemplateConverter;

  /**
   * Create a new TemplateConverter.
   * @param {string} backend - the backend name
   * @param templateDirectories - a list of template directories
   * @param {Object} opts - a JSON of options
   * @param {string} opts.template_engine - the name of the template engine
   * @param {Object} [opts.template_cache] - an optional template cache
   * @param {Object} [opts.template_cache.scans] - a JSON of template objects keyed by template name keyed by path patterns
   * @param {Object} [opts.template_cache.templates] - a JSON of template objects keyed by file paths
   * @returns {TemplateConverter}
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.create = function (backend, templateDirectories, opts) {
    if (opts && opts.template_cache) {
      opts.template_cache = toHash(opts.template_cache);
    }
    this.$new(backend, templateDirectories, toHash(opts));
  };

  /**
   * @returns {Object} - The global cache
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.getCache = function () {
    const caches = fromHash(this.caches);
    if (caches) {
      if (caches.scans) {
        caches.scans = fromHash(caches.scans);
        for (const key in caches.scans) {
          caches.scans[key] = fromHash(caches.scans[key]);
        }
      }
      if (caches.templates) {
        caches.templates = fromHash(caches.templates);
      }
    }
    return caches
  };

  /**
   * Clear the global cache.
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.clearCache = function () {
    this.$clear_caches();
  };

  /**
   * Convert an {AbstractNode} to the backend format using the named template.
   *
   * Looks for a template that matches the value of the template name or,
   * if the template name is not specified, the value of the {@see AbstractNode.getNodeName} function.
   *
   * @param {AbstractNode} node - the AbstractNode to convert
   * @param {string} templateName - the {string} name of the template to use, or the node name of the node if a template name is not specified. (optional, default: undefined)
   * @param {Object} opts - an optional JSON that is passed as local variables to the template. (optional, default: undefined)
   * @returns {string} - The {string} result from rendering the template
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.convert = function (node, templateName, opts) {
    return this.$convert(node, templateName, toHash(opts))
  };

  /**
   * Checks whether there is a template registered with the specified name.
   *
   * @param {string} name - the {string} template name
   * @returns {boolean} - a {boolean} that indicates whether a template is registered for the specified template name.
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.handles = function (name) {
    return this['$handles?'](name)
  };

  /**
   * Converts the {AbstractNode} using only its converted content.
   *
   * @param {AbstractNode} node
   * @returns {string} - the converted {string} content.
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.getContentOnly = function (node) {
    return this.$content_only(node)
  };

  /**
   * Skips conversion of the {AbstractNode}.
   *
   * @param {AbstractNode} node
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.skip = function (node) {
    this.$skip(node);
  };

  /**
   * Retrieves the templates that this converter manages.
   *
   * @returns {Object} - a JSON of template objects keyed by template name
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.getTemplates = function () {
    return fromHash(this.$templates())
  };

  /**
   * Registers a template with this converter.
   *
   * @param {string} name - the {string} template name
   * @param {Object} template - the template object to register
   * @returns {Object} - the template object
   * @memberof Converter/TemplateConverter
   */
  TemplateConverter.prototype.register = function (name, template) {
    return this.$register(name, template)
  };

  /**
   * @namespace
   * @description
   * This API is experimental and subject to change.
   *
   * Please note that this API is currently only available in a Node environment.
   * We recommend to use a custom converter if you are running in the browser.
   *
   * A pluggable adapter for integrating a template engine into the built-in template converter.
   */
  const TemplateEngine = {};
  TemplateEngine.registry = {};

  // Alias
  Opal.Asciidoctor.TemplateEngine = TemplateEngine;

  /**
   * Register a template engine adapter for the given names.
   * @param {string|Array} names - a {string} name or an {Array} of {string} names
   * @param {Object} templateEngineAdapter - a template engine adapter instance
   * @example
   *  const fs = require('fs')
   *  class DotTemplateEngineAdapter {
   *    constructor () {
   *      this.doT = require('dot')
   *    }
   *    compile (file, _) {
   *      const templateFn = this.doT.template(fs.readFileSync(file, 'utf8'))
   *      return {
   *        render: templateFn
   *      }
   *    }
   *  }
   *  asciidoctor.TemplateEngine.register('dot, new DotTemplateEngineAdapter())
   * @memberof TemplateEngine
   */
  TemplateEngine.register = function (names, templateEngineAdapter) {
    if (typeof names === 'string') {
      this.registry[names] = templateEngineAdapter;
    } else {
      // array
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        this.registry[name] = templateEngineAdapter;
      }
    }
  };
}

/**
 * @namespace
 * @module Converter/CompositeConverter
 */
const CompositeConverter = Opal.Asciidoctor.Converter.CompositeConverter;

if (CompositeConverter) {
  // Alias
  Opal.Asciidoctor.CompositeConverter = CompositeConverter;

  /**
   * Delegates to the first converter that identifies itself as the handler for the given transform.
   * The optional Hash is passed as the last option to the delegate's convert method.
   *
   * @param node - the AbstractNode to convert
   * @param [transform] - the optional {string} transform, or the name of the node if no transform is specified. (optional, default: undefined)
   * @param [opts] - an optional JSON that is passed as local variables to the template. (optional, default: undefined)
   * @returns The {string} result from the delegate's convert method
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.convert = function (node, transform, opts) {
    return this.$convert(node, transform, toHash(opts))
  };

  /**
   * Converts the {AbstractNode} using only its converted content.
   *
   * @param {AbstractNode} node
   * @returns {string} - the converted {string} content.
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.getContentOnly = function (node) {
    return this.$content_only(node)
  };

  /**
   * Skips conversion of the {AbstractNode}.
   *
   * @param {AbstractNode} node
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.skip = function (node) {
    this.$skip(node);
  };

  /**
   * Get the Array of Converter objects in the chain.
   * @returns {[Converter]}
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.getConverters = function () {
    return this.converters
  };

  /**
   * Retrieve the converter for the specified transform.
   * @param transform
   * @returns {Converter|undefined}
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.getConverter = function (transform) {
    const converter = this.$converter_for(transform);
    return converter === Opal.nil ? undefined : converter
  };

  /**
   * Find the converter for the specified transform.
   * Throw an exception if no converter is found.
   *
   * @param transform
   * @returns {Converter} - the matching converter
   * @throws Error if no converter is found
   * @memberof Converter/CompositeConverter
   */
  CompositeConverter.prototype.findConverter = function (transform) {
    return this.$find_converter(transform)
  };
}

// Converter API

/**
 * @namespace
 * @module Converter
 */
const Converter = Opal.const_get_qualified(Opal.Asciidoctor, 'Converter');

// Alias
Opal.Asciidoctor.Converter = Converter;

/**
 * Convert the specified node.
 *
 * @param {AbstractNode} node - the AbstractNode to convert
 * @param {string} transform - an optional String transform that hints at
 * which transformation should be applied to this node.
 * @param {Object} opts - a JSON of options that provide additional hints about how to convert the node (default: {})
 * @returns the {Object} result of the conversion, typically a {string}.
 * @memberof Converter
 */
Converter.prototype.convert = function (node, transform, opts) {
  return this.$convert(node, transform, toHash(opts))
};

/**
 * Create an instance of the converter bound to the specified backend.
 *
 * @param {string} backend - look for a converter bound to this keyword.
 * @param {Object} opts - a JSON of options to pass to the converter (default: {})
 * @returns {Converter} - a converter instance for converting nodes in an Asciidoctor AST.
 * @memberof Converter
 */
Converter.create = function (backend, opts) {
  return this.$create(backend, toHash(opts))
};

// Converter Factory API

/**
 * @namespace
 * @module Converter/Factory
 */
const ConverterFactory = Opal.Asciidoctor.Converter.Factory;

const ConverterBase = Opal.Asciidoctor.Converter.Base;

// Alias
Opal.Asciidoctor.ConverterFactory = ConverterFactory;

const ConverterBackendTraits = Opal.Asciidoctor.Converter.BackendTraits;

// Alias
Opal.Asciidoctor.ConverterBackendTraits = ConverterBackendTraits;

/**
 * Register a custom converter in the global converter factory to handle conversion to the specified backends.
 * If the backend value is an asterisk, the converter is used to handle any backend that does not have an explicit converter.
 *
 * @param converter - The Converter instance to register
 * @param backends {Array} - A {string} {Array} of backend names that this converter should be registered to handle (optional, default: ['*'])
 * @return {*} - Returns nothing
 * @memberof Converter/Factory
 */
ConverterFactory.register = function (converter, backends) {
  const args = [bridgeConverter(converter)].concat(backends);
  return Converter.$register.apply(Converter, args)
};

/**
 * Retrieves the singleton instance of the converter factory.
 *
 * @param {boolean} initialize - instantiate the singleton if it has not yet
 * been instantiated. If this value is false and the singleton has not yet been
 * instantiated, this method returns a fresh instance.
 * @returns {Converter/Factory} an instance of the converter factory.
 * @memberof Converter/Factory
 */
ConverterFactory.getDefault = function (initialize) {
  return this.$default(initialize)
};

/**
 * Create an instance of the converter bound to the specified backend.
 *
 * @param {string} backend - look for a converter bound to this keyword.
 * @param {Object} opts - a JSON of options to pass to the converter (default: {})
 * @returns {Converter} - a converter instance for converting nodes in an Asciidoctor AST.
 * @memberof Converter/Factory
 */
ConverterFactory.prototype.create = function (backend, opts) {
  return this.$create(backend, toHash(opts))
};

/**
 * Get the converter registry.
 * @returns the registry of converter instances or classes keyed by backend name
 * @memberof Converter/Factory
 */
ConverterFactory.getRegistry = function () {
  return fromHash(Converter.$registry())
};

/**
 * Lookup the custom converter registered with this factory to handle the specified backend.
 *
 * @param {string} backend - The {string} backend name.
 * @returns the {Converter} class or instance registered to convert the specified backend or undefined if no match is found.
 * @memberof Converter/Factory
 */
ConverterFactory.for = function (backend) {
  const converter = Converter.$for(backend);
  return converter === Opal.nil ? undefined : converter
};

/*
 * Unregister any custom converter classes that are registered with this factory.
 * Intended for testing only!
 */
ConverterFactory.unregisterAll = function () {
  const internalRegistry = Converter.DefaultFactory.$$cvars['@@registry'];
  Converter.DefaultFactory.$$cvars['@@registry'] = toHash({ html5: internalRegistry['$[]']('html5') });
};

// Built-in converter

/**
 * @namespace
 * @module Converter/Html5Converter
 */
const Html5Converter = Opal.Asciidoctor.Converter.Html5Converter;

// Alias
Opal.Asciidoctor.Html5Converter = Html5Converter;

/**
 * Create a new Html5Converter.
 * @returns {Html5Converter} - a Html5Converter
 * @memberof Converter/Html5Converter
 */
Html5Converter.create = function () {
  return this.$new()
};

/**
 * Converts an {AbstractNode} using the given transform.
 * This method must be implemented by a concrete converter class.
 *
 * @param {AbstractNode} node - The concrete instance of AbstractNode to convert.
 * @param {string} [transform] - An optional String transform that hints at which transformation should be applied to this node.
 * If a transform is not given, the transform is often derived from the value of the {AbstractNode#getNodeName} property. (optional, default: undefined)
 * @param {Object} [opts]- An optional JSON of options hints about how to convert the node. (optional, default: undefined)
 *
 * @returns {string} - the String result.
 * @memberof Converter/Html5Converter
 */
Html5Converter.prototype.convert = function (node, transform, opts) {
  return this.$convert(node, transform, opts)
};

/* global Opal, fromHash, toHash, initializeClass */
// Extensions API

/**
 * @private
 */
const toBlock = function (block) {
  // arity is a mandatory field
  block.$$arity = block.length;
  return block
};

const registerExtension = function (registry, type, processor, name) {
  if (typeof processor === 'object' || processor.$$is_class) {
    // processor is an instance or a class
    return registry['$' + type](processor, name)
  } else {
    // processor is a function/lambda
    return Opal.send(registry, type, name && [name], toBlock(processor))
  }
};

/**
 * @namespace
 * @description
 * Extensions provide a way to participate in the parsing and converting
 * phases of the AsciiDoc processor or extend the AsciiDoc syntax.
 *
 * The various extensions participate in AsciiDoc processing as follows:
 *
 * 1. After the source lines are normalized, {{@link Extensions/Preprocessor}}s modify or replace
 *    the source lines before parsing begins. {{@link Extensions/IncludeProcessor}}s are used to
 *    process include directives for targets which they claim to handle.
 * 2. The Parser parses the block-level content into an abstract syntax tree.
 *    Custom blocks and block macros are processed by associated {{@link Extensions/BlockProcessor}}s
 *    and {{@link Extensions/BlockMacroProcessor}}s, respectively.
 * 3. {{@link Extensions/TreeProcessor}}s are run on the abstract syntax tree.
 * 4. Conversion of the document begins, at which point inline markup is processed
 *    and converted. Custom inline macros are processed by associated {InlineMacroProcessor}s.
 * 5. {{@link Extensions/Postprocessor}}s modify or replace the converted document.
 * 6. The output is written to the output stream.
 *
 * Extensions may be registered globally using the {Extensions.register} method
 * or added to a custom {Registry} instance and passed as an option to a single
 * Asciidoctor processor.
 *
 * @example
 * asciidoctor.Extensions.register(function () {
 *   this.block(function () {
 *     const self = this
 *     self.named('shout')
 *     self.onContext('paragraph')
 *     self.process(function (parent, reader) {
 *       const lines = reader.getLines().map(function (l) { return l.toUpperCase(); })
 *       return self.createBlock(parent, 'paragraph', lines)
 *     })
 *   })
 * })
 */
const Extensions = Opal.const_get_qualified(Opal.Asciidoctor, 'Extensions');

// Alias
Opal.Asciidoctor.Extensions = Extensions;

/**
 * Create a new {@link Extensions/Registry}.
 * @param {string} name
 * @param {function} block
 * @memberof Extensions
 * @returns {Extensions/Registry} - returns a {@link Extensions/Registry}
 */
Extensions.create = function (name, block) {
  if (typeof name === 'function' && typeof block === 'undefined') {
    return Opal.send(this, 'create', null, toBlock(name))
  } else if (typeof block === 'function') {
    return Opal.send(this, 'create', [name], toBlock(block))
  } else {
    return this.$create()
  }
};

/**
 * @memberof Extensions
 */
Extensions.register = function (name, block) {
  if (typeof name === 'function' && typeof block === 'undefined') {
    return Opal.send(this, 'register', null, toBlock(name))
  } else {
    return Opal.send(this, 'register', [name], toBlock(block))
  }
};

/**
 * Get statically-registered extension groups.
 * @memberof Extensions
 */
Extensions.getGroups = function () {
  return fromHash(this.$groups())
};

/**
 * Unregister all statically-registered extension groups.
 * @memberof Extensions
 */
Extensions.unregisterAll = function () {
  this.$unregister_all();
};

/**
 * Unregister the specified statically-registered extension groups.
 *
 * NOTE Opal cannot delete an entry from a Hash that is indexed by symbol, so
 * we have to resort to using low-level operations in this method.
 *
 * @memberof Extensions
 */
Extensions.unregister = function () {
  const names = Array.prototype.concat.apply([], arguments);
  const groups = this.$groups();
  const groupNameIdx = {};
  let i = 0;
  const groupSymbolNames = groups.$$keys;
  for (; i < groupSymbolNames.length; i++) {
    const groupSymbolName = groupSymbolNames[i];
    groupNameIdx[groupSymbolName.toString()] = groupSymbolName;
  }
  for (let j = 0; j < names.length; j++) {
    const groupStringName = names[j];
    if (groupStringName in groupNameIdx) Opal.hash_delete(groups, groupNameIdx[groupStringName]);
  }
};

/**
 * @namespace
 * @module Extensions/Registry
 */
const Registry = Extensions.Registry;

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.getGroups = Extensions.getGroups;

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.unregisterAll = function () {
  this.groups = Opal.hash();
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.unregister = Extensions.unregister;

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.prefer = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  if (typeof processor === 'object' || processor.$$is_class) {
    // processor is an instance or a class
    return this.$prefer(name, processor)
  } else {
    // processor is a function/lambda
    return Opal.send(this, 'prefer', name && [name], toBlock(processor))
  }
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.block = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'block', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.inlineMacro = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'inline_macro', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.includeProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'include_processor', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.blockMacro = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'block_macro', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.treeProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'tree_processor', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.postprocessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'postprocessor', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.preprocessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'preprocessor', processor, name)
};

/**
 * @memberof Extensions/Registry
 */
Registry.prototype.docinfoProcessor = function (name, processor) {
  if (arguments.length === 1) {
    processor = name;
    name = null;
  }
  return registerExtension(this, 'docinfo_processor', processor, name)
};

/**
 * Checks whether any {{@link Extensions/Preprocessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/Preprocessor}} extensions are registered.
 */
Registry.prototype.hasPreprocessors = function () {
  return this['$preprocessors?']()
};

/**
 * Checks whether any {{@link Extensions/TreeProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/TreeProcessor}} extensions are registered.
 */
Registry.prototype.hasTreeProcessors = function () {
  return this['$tree_processors?']()
};

/**
 * Checks whether any {{@link Extensions/IncludeProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/IncludeProcessor}} extensions are registered.
 */
Registry.prototype.hasIncludeProcessors = function () {
  return this['$include_processors?']()
};

/**
 * Checks whether any {{@link Extensions/Postprocessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/Postprocessor}} extensions are registered.
 */
Registry.prototype.hasPostprocessors = function () {
  return this['$postprocessors?']()
};

/**
 * Checks whether any {{@link Extensions/DocinfoProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @param location - A {string} for selecting docinfo extensions at a given location (head or footer) (default: undefined)
 * @returns a {boolean} indicating whether any {{@link Extensions/DocinfoProcessor}} extensions are registered.
 */
Registry.prototype.hasDocinfoProcessors = function (location) {
  return this['$docinfo_processors?'](location)
};

/**
 * Checks whether any {{@link Extensions/BlockProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/BlockProcessor}} extensions are registered.
 */
Registry.prototype.hasBlocks = function () {
  return this['$blocks?']()
};

/**
 * Checks whether any {{@link Extensions/BlockMacroProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/BlockMacroProcessor}} extensions are registered.
 */
Registry.prototype.hasBlockMacros = function () {
  return this['$block_macros?']()
};

/**
 * Checks whether any {{@link Extensions/InlineMacroProcessor}} extensions have been registered.
 *
 * @memberof Extensions/Registry
 * @returns a {boolean} indicating whether any {{@link Extensions/InlineMacroProcessor}} extensions are registered.
 */
Registry.prototype.hasInlineMacros = function () {
  return this['$inline_macros?']()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/Preprocessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getPreprocessors = function () {
  return this.$preprocessors()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/TreeProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getTreeProcessors = function () {
  return this.$tree_processors()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/IncludeProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getIncludeProcessors = function () {
  return this.$include_processors()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/Postprocessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getPostprocessors = function () {
  return this.$postprocessors()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/DocinfoProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @param location - A {string} for selecting docinfo extensions at a given location (head or footer) (default: undefined)
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getDocinfoProcessors = function (location) {
  return this.$docinfo_processors(location)
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/BlockProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getBlocks = function () {
  return this.block_extensions.$values()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/BlockMacroProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getBlockMacros = function () {
  return this.block_macro_extensions.$values()
};

/**
 * Retrieves the Extension proxy objects for all the {{@link Extensions/InlineMacroProcessor}} instances stored in this registry.
 *
 * @memberof Extensions/Registry
 * @returns an {array} of Extension proxy objects.
 */
Registry.prototype.getInlineMacros = function () {
  return this.$inline_macros()
};

/**
 * Get any {{@link Extensions/InlineMacroProcessor}} extensions are registered to handle the specified inline macro name.
 *
 * @param name - the {string} inline macro name
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/InlineMacroProcessor}} that matches the inline macro name or undefined if no match is found.
 */
Registry.prototype.getInlineMacroFor = function (name) {
  const result = this['$registered_for_inline_macro?'](name);
  return result === false ? undefined : result
};

/**
 * Get any {{@link Extensions/BlockProcessor}} extensions are registered to handle the specified block name appearing on the specified context.
 * @param name - the {string} block name
 * @param context - the context of the block: paragraph, open... (optional)
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/BlockProcessor}} that matches the block name and context or undefined if no match is found.
 */
Registry.prototype.getBlockFor = function (name, context) {
  if (typeof context === 'undefined') {
    const ext = this.$find_block_extension(name);
    return ext === Opal.nil ? undefined : ext
  }
  const result = this['$registered_for_block?'](name, context);
  return result === false ? undefined : result
};

/**
 * Get any {{@link Extensions/BlockMacroProcessor}} extensions are registered to handle the specified macro name.
 *
 * @param name - the {string} macro name
 * @memberof Extensions/Registry
 * @returns the Extension proxy object for the {{@link Extensions/BlockMacroProcessor}} that matches the macro name or undefined if no match is found.
 */
Registry.prototype.getBlockMacroFor = function (name) {
  const result = this['$registered_for_block_macro?'](name);
  return result === false ? undefined : result
};

/**
 * @namespace
 * @module Extensions/Processor
 */
const Processor = Extensions.Processor;

/**
 * The extension will be added to the beginning of the list for that extension type. (default is append).
 * @memberof Extensions/Processor
 * @deprecated Please use the <code>prefer</pre> function on the {@link Extensions/Registry},
 * the {@link Extensions/IncludeProcessor},
 * the {@link Extensions/TreeProcessor},
 * the {@link Extensions/Postprocessor},
 * the {@link Extensions/Preprocessor}
 * or the {@link Extensions/DocinfoProcessor}
 */
Processor.prototype.prepend = function () {
  this.$option('position', '>>');
};

/**
 * @memberof Extensions/Processor
 */
Processor.prototype.process = function (block) {
  const handler = {
    apply: function (target, thisArg, argumentsList) {
      for (let i = 0; i < argumentsList.length; i++) {
        // convert all (Opal) Hash arguments to JSON.
        if (typeof argumentsList[i] === 'object' && '$$smap' in argumentsList[i]) {
          argumentsList[i] = fromHash(argumentsList[i]);
        }
      }
      return target.apply(thisArg, argumentsList)
    }
  };
  const blockProxy = new Proxy(block, handler);
  return Opal.send(this, 'process', null, toBlock(blockProxy))
};

/**
 * @param {string} name
 * @memberof Extensions/Processor
 */
Processor.prototype.named = function (name) {
  return this.$named(name)
};

/**
 * Creates a block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} context
 * @param {string|Array<string>} source
 * @param {Object|undefined} attrs - A JSON of attributes
 * @param {Object|undefined} opts - A JSON of options
 * @return {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createBlock = function (parent, context, source, attrs, opts) {
  return this.$create_block(parent, context, source, toHash(attrs), toHash(opts))
};

/**
 * Creates a list block node and links it to the specified parent.
 *
 * @param parent - The parent Block (Block, Section, or Document) of this new list block.
 * @param {string} context - The list context (e.g., ulist, olist, colist, dlist)
 * @param {Object} attrs - An object of attributes to set on this list block
 * @returns {List}
 * @memberof Extensions/Processor
 */
Processor.prototype.createList = function (parent, context, attrs) {
  return this.$create_list(parent, context, toHash(attrs))
};

/**
 * Creates a list item node and links it to the specified parent.
 *
 * @param {List} parent - The parent {List} of this new list item block.
 * @param {string} text - The text of the list item.
 * @returns {ListItem}
 * @memberof Extensions/Processor
 */
Processor.prototype.createListItem = function (parent, text) {
  return this.$create_list_item(parent, text)
};

/**
 * Creates an image block node and links it to the specified parent.
 * @param {Block|Section|Document} parent - The parent Block of this new image block.
 * @param {Object} attrs - A JSON of attributes
 * @param {string} attrs.target - the target attribute to set the source of the image.
 * @param {string} attrs.alt - the alt attribute to specify an alternative text for the image.
 * @param {Object} opts - A JSON of options
 * @returns {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createImageBlock = function (parent, attrs, opts) {
  return this.$create_image_block(parent, toHash(attrs), toHash(opts))
};

/**
 * Creates a paragraph block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a paragraph {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createParagraph = function (parent, source, attrs, opts) {
  return this.$create_paragraph(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates an open block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - an open {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createOpenBlock = function (parent, source, attrs, opts) {
  return this.$create_open_block(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates an example block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - an example {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createExampleBlock = function (parent, source, attrs, opts) {
  return this.$create_example_block(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates a literal block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a literal {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createPassBlock = function (parent, source, attrs, opts) {
  return this.$create_pass_block(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates a listing block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a listing {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createListingBlock = function (parent, source, attrs, opts) {
  return this.$create_listing_block(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates a literal block and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string|Array<string>} source - The source
 * @param {Object|undefined} attrs - An object of attributes to set on this block
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Block} - a literal {Block}
 * @memberof Extensions/Processor
 */
Processor.prototype.createLiteralBlock = function (parent, source, attrs, opts) {
  return this.$create_literal_block(parent, source, toHash(attrs), toHash(opts))
};

/**
 * Creates an inline anchor and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} text - The text
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Inline} - an {Inline} anchor
 * @memberof Extensions/Processor
 */
Processor.prototype.createAnchor = function (parent, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return this.$create_anchor(parent, text, toHash(opts))
};

/**
 * Creates an inline pass and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block (Block, Section, or Document) of this new block.
 * @param {string} text - The text
 * @param {Object|undefined} opts - An object of options to set on this block
 * @returns {Inline} - an {Inline} pass
 * @memberof Extensions/Processor
 */
Processor.prototype.createInlinePass = function (parent, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return this.$create_inline_pass(parent, text, toHash(opts))
};

/**
 * Creates an inline node and links it to the specified parent.
 *
 * @param {Block|Section|Document} parent - The parent Block of this new inline node.
 * @param {string} context - The context name
 * @param {string} text - The text
 * @param {Object|undefined} opts - A JSON of options
 * @returns {Inline} - an {Inline} node
 * @memberof Extensions/Processor
 */
Processor.prototype.createInline = function (parent, context, text, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return this.$create_inline(parent, context, text, toHash(opts))
};

/**
 * Parses blocks in the content and attaches the block to the parent.
 * @param {AbstractBlock} parent - the parent block
 * @param {string|Array<string>} content - the content
 * @param {Object|undefined} attrs - an object of attributes
 * @returns {AbstractNode} - The parent node into which the blocks are parsed.
 * @memberof Extensions/Processor
 */
Processor.prototype.parseContent = function (parent, content, attrs) {
  return this.$parse_content(parent, content, toHash(attrs))
};

/**
 *  Parses the attrlist String into a JSON of attributes
 * @param {AbstractBlock} block - the current AbstractBlock or the parent AbstractBlock if there is no current block (used for applying subs)
 * @param {string} attrlist - the list of attributes as a String
 * @param {Object|undefined} opts - an optional JSON of options to control processing:
 * - positional_attributes: an Array of attribute names to map positional arguments to (optional, default: [])
 * - sub_attributes: enables attribute substitution on the attrlist argument (optional, default: false)
 *
 * @returns - a JSON of parsed attributes
 * @memberof Extensions/Processor
 */
Processor.prototype.parseAttributes = function (block, attrlist, opts) {
  if (opts && opts.attributes) {
    opts.attributes = toHash(opts.attributes);
  }
  return fromHash(this.$parse_attributes(block, attrlist, toHash(opts)))
};

/**
 * @param {string|Array<string>} value - Name of a positional attribute or an Array of positional attribute names
 * @memberof Extensions/Processor
 */
Processor.prototype.positionalAttributes = function (value) {
  return this.$positional_attrs(value)
};

/**
 * Specify how to resolve attributes.
 *
 * @param {string|Array<string>|Object|boolean} [value] - A specification to resolve attributes.
 * @memberof Extensions/Processor
 */
Processor.prototype.resolveAttributes = function (value) {
  if (typeof value === 'object' && !Array.isArray(value)) {
    return this.$resolves_attributes(toHash(value))
  }
  if (arguments.length > 1) {
    return this.$resolves_attributes(Array.prototype.slice.call(arguments))
  }
  if (typeof value === 'undefined') {
    // Convert to nil otherwise an exception is thrown at:
    // https://github.com/asciidoctor/asciidoctor/blob/0bcb4addc17b307f62975aad203fb556a1bcd8a5/lib/asciidoctor/extensions.rb#L583
    //
    // if args.size == 1 && !args[0]
    //
    // In the above Ruby code, args[0] is undefined and Opal will try to call the function "!" on an undefined object.
    return this.$resolves_attributes(Opal.nil)
  }
  return this.$resolves_attributes(value)
};

/**
 * @deprecated Please use the <code>resolveAttributes</pre> function on the {@link Extensions/Processor}.
 * @memberof Extensions/Processor
 * @see {Processor#resolveAttributes}
 */
Processor.prototype.resolvesAttributes = Processor.prototype.resolveAttributes;

/**
 * Get the configuration JSON for this processor instance.
 * @memberof Extensions/Processor
 */
Processor.prototype.getConfig = function () {
  return fromHash(this.config)
};

/**
 * @memberof Extensions/Processor
 */
Processor.prototype.option = function (key, value) {
  this.$option(key, value);
};

/**
 * @namespace
 * @module Extensions/BlockProcessor
 */
const BlockProcessor = Extensions.BlockProcessor;

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value));
};

/**
 * @param {string} context - A context name
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.onContext = function (context) {
  return this.$on_context(context)
};

/**
 * @param {...string} contexts - A list of context names
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.onContexts = function (contexts) {
  return this.$on_contexts(Array.prototype.slice.call(arguments))
};

/**
 * @returns {string}
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.getName = function () {
  const name = this.name;
  return name === Opal.nil ? undefined : name
};

/**
 * @param {string} value
 * @memberof Extensions/BlockProcessor
 */
BlockProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value);
};

/**
 * @namespace
 * @module Extensions/BlockMacroProcessor
 */
const BlockMacroProcessor = Extensions.BlockMacroProcessor;

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value));
};

/**
 * @returns {string} - the block macro name
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.getName = function () {
  const name = this.name;
  return name === Opal.nil ? undefined : name
};

/**
 * @param {string} value
 * @memberof Extensions/BlockMacroProcessor
 */
BlockMacroProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value);
};

/**
 * @namespace
 * @module Extensions/InlineMacroProcessor
 */
const InlineMacroProcessor = Extensions.InlineMacroProcessor;

/**
 * @param {Object} value - a JSON of default values for attributes
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.defaultAttributes = function (value) {
  this.$default_attributes(toHash(value));
};

/**
 * @returns {string} - the inline macro name
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.getName = function () {
  const name = this.name;
  return name === Opal.nil ? undefined : name
};

/**
 * @param {string} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.parseContentAs = function (value) {
  this.$parse_content_as(value);
};

/**
 * @param {string} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.matchFormat = function (value) {
  this.$match_format(value);
};

/**
 * @param {RegExp} value
 * @memberof Extensions/InlineMacroProcessor
 */
InlineMacroProcessor.prototype.match = function (value) {
  this.$match(value);
};

/**
 * @namespace
 * @module Extensions/IncludeProcessor
 */
const IncludeProcessor = Extensions.IncludeProcessor;

/**
 * @memberof Extensions/IncludeProcessor
 */
IncludeProcessor.prototype.handles = function (block) {
  return Opal.send(this, 'handles?', null, toBlock(block))
};

/**
 * @memberof Extensions/IncludeProcessor
 */
IncludeProcessor.prototype.prefer = function () {
  this.$prefer();
};

/**
 * @namespace
 * @module Extensions/TreeProcessor
 */
const TreeProcessor = Extensions.TreeProcessor;

/**
 * @memberof Extensions/TreeProcessor
 */
TreeProcessor.prototype.prefer = function () {
  this.$prefer();
};

/**
 * @namespace
 * @module Extensions/Postprocessor
 */
const Postprocessor = Extensions.Postprocessor;

/**
 * @memberof Extensions/Postprocessor
 */
Postprocessor.prototype.prefer = function () {
  this.$prefer();
};

/**
 * @namespace
 * @module Extensions/Preprocessor
 */
const Preprocessor = Extensions.Preprocessor;

/**
 * @memberof Extensions/Preprocessor
 */
Preprocessor.prototype.prefer = function () {
  this.$prefer();
};

/**
 * @namespace
 * @module Extensions/DocinfoProcessor
 */
const DocinfoProcessor = Extensions.DocinfoProcessor;

/**
 * @memberof Extensions/DocinfoProcessor
 */
DocinfoProcessor.prototype.prefer = function () {
  this.$prefer();
};

/**
 * @param {string} value - The docinfo location ("head", "header" or "footer")
 * @memberof Extensions/DocinfoProcessor
 */
DocinfoProcessor.prototype.atLocation = function (value) {
  this.$at_location(value);
};

function initializeProcessorClass (superclassName, className, functions) {
  const superClass = Opal.const_get_qualified(Extensions, superclassName);
  return initializeClass(superClass, className, functions, {
    'handles?': function () {
      return true
    }
  })
}

// Postprocessor

/**
 * Create a postprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createPostprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('Postprocessor', name, functions)
};

/**
 * Create and instantiate a postprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newPostprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createPostprocessor(name, functions).$new()
};

// Preprocessor

/**
 * Create a preprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createPreprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('Preprocessor', name, functions)
};

/**
 * Create and instantiate a preprocessor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newPreprocessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createPreprocessor(name, functions).$new()
};

// Tree Processor

/**
 * Create a tree processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createTreeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('TreeProcessor', name, functions)
};

/**
 * Create and instantiate a tree processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newTreeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createTreeProcessor(name, functions).$new()
};

// Include Processor

/**
 * Create an include processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createIncludeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('IncludeProcessor', name, functions)
};

/**
 * Create and instantiate an include processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newIncludeProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createIncludeProcessor(name, functions).$new()
};

// Docinfo Processor

/**
 * Create a Docinfo processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createDocinfoProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('DocinfoProcessor', name, functions)
};

/**
 * Create and instantiate a Docinfo processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newDocinfoProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createDocinfoProcessor(name, functions).$new()
};

// Block Processor

/**
 * Create a block processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createBlockProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('BlockProcessor', name, functions)
};

/**
 * Create and instantiate a block processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newBlockProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createBlockProcessor(name, functions).$new()
};

// Inline Macro Processor

/**
 * Create an inline macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createInlineMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('InlineMacroProcessor', name, functions)
};

/**
 * Create and instantiate an inline macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newInlineMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createInlineMacroProcessor(name, functions).$new()
};

// Block Macro Processor

/**
 * Create a block macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.createBlockMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return initializeProcessorClass('BlockMacroProcessor', name, functions)
};

/**
 * Create and instantiate a block macro processor
 * @description this API is experimental and subject to change
 * @memberof Extensions
 */
Extensions.newBlockMacroProcessor = function (name, functions) {
  if (arguments.length === 1) {
    functions = name;
    name = null;
  }
  return this.createBlockMacroProcessor(name, functions).$new()
};


var ASCIIDOCTOR_JS_VERSION = '3.0.4';

  /**
   * Get Asciidoctor.js version number.
   *
   * @memberof Asciidoctor
   * @returns {string} - returns the version number of Asciidoctor.js.
   */
  Asciidoctor.prototype.getVersion = function () {
    return ASCIIDOCTOR_JS_VERSION
  };
  return Opal.Asciidoctor
}

module.exports = asciidoctorNode;
